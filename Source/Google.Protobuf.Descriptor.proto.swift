// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "descriptor.proto"
// Syntax "Proto2"

import Foundation

public struct Google { public struct Protobuf { }}

public func == (lhs: Google.Protobuf.FileDescriptorSet, rhs: Google.Protobuf.FileDescriptorSet) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.file == rhs.file)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.FileDescriptorProto, rhs: Google.Protobuf.FileDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasPackage == rhs.hasPackage) && (!lhs.hasPackage || lhs.package == rhs.package)
  fieldCheck = fieldCheck && (lhs.dependency == rhs.dependency)
  fieldCheck = fieldCheck && (lhs.messageType == rhs.messageType)
  fieldCheck = fieldCheck && (lhs.enumType == rhs.enumType)
  fieldCheck = fieldCheck && (lhs.service == rhs.service)
  fieldCheck = fieldCheck && (lhs.extension_ == rhs.extension_)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = fieldCheck && (lhs.hasSourceCodeInfo == rhs.hasSourceCodeInfo) && (!lhs.hasSourceCodeInfo || lhs.sourceCodeInfo == rhs.sourceCodeInfo)
  fieldCheck = fieldCheck && (lhs.publicDependency == rhs.publicDependency)
  fieldCheck = fieldCheck && (lhs.weakDependency == rhs.weakDependency)
  fieldCheck = fieldCheck && (lhs.hasSyntax == rhs.hasSyntax) && (!lhs.hasSyntax || lhs.syntax == rhs.syntax)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.DescriptorProto, rhs: Google.Protobuf.DescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.field == rhs.field)
  fieldCheck = fieldCheck && (lhs.nestedType == rhs.nestedType)
  fieldCheck = fieldCheck && (lhs.enumType == rhs.enumType)
  fieldCheck = fieldCheck && (lhs.extensionRange == rhs.extensionRange)
  fieldCheck = fieldCheck && (lhs.extension_ == rhs.extension_)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = fieldCheck && (lhs.oneofDecl == rhs.oneofDecl)
  fieldCheck = fieldCheck && (lhs.reservedRange == rhs.reservedRange)
  fieldCheck = fieldCheck && (lhs.reservedName == rhs.reservedName)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.DescriptorProto.ExtensionRange, rhs: Google.Protobuf.DescriptorProto.ExtensionRange) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
  fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.DescriptorProto.ReservedRange, rhs: Google.Protobuf.DescriptorProto.ReservedRange) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
  fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.FieldDescriptorProto, rhs: Google.Protobuf.FieldDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasExtendee == rhs.hasExtendee) && (!lhs.hasExtendee || lhs.extendee == rhs.extendee)
  fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
  fieldCheck = fieldCheck && (lhs.hasLabel == rhs.hasLabel) && (!lhs.hasLabel || lhs.label == rhs.label)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasTypeName == rhs.hasTypeName) && (!lhs.hasTypeName || lhs.typeName == rhs.typeName)
  fieldCheck = fieldCheck && (lhs.hasDefaultValue == rhs.hasDefaultValue) && (!lhs.hasDefaultValue || lhs.defaultValue == rhs.defaultValue)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = fieldCheck && (lhs.hasOneofIndex == rhs.hasOneofIndex) && (!lhs.hasOneofIndex || lhs.oneofIndex == rhs.oneofIndex)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.OneofDescriptorProto, rhs: Google.Protobuf.OneofDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.EnumDescriptorProto, rhs: Google.Protobuf.EnumDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.value == rhs.value)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.EnumValueDescriptorProto, rhs: Google.Protobuf.EnumValueDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.ServiceDescriptorProto, rhs: Google.Protobuf.ServiceDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.method == rhs.method)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.MethodDescriptorProto, rhs: Google.Protobuf.MethodDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasInputType == rhs.hasInputType) && (!lhs.hasInputType || lhs.inputType == rhs.inputType)
  fieldCheck = fieldCheck && (lhs.hasOutputType == rhs.hasOutputType) && (!lhs.hasOutputType || lhs.outputType == rhs.outputType)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = fieldCheck && (lhs.hasClientStreaming == rhs.hasClientStreaming) && (!lhs.hasClientStreaming || lhs.clientStreaming == rhs.clientStreaming)
  fieldCheck = fieldCheck && (lhs.hasServerStreaming == rhs.hasServerStreaming) && (!lhs.hasServerStreaming || lhs.serverStreaming == rhs.serverStreaming)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.FileOptions, rhs: Google.Protobuf.FileOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasJavaPackage == rhs.hasJavaPackage) && (!lhs.hasJavaPackage || lhs.javaPackage == rhs.javaPackage)
  fieldCheck = fieldCheck && (lhs.hasJavaOuterClassname == rhs.hasJavaOuterClassname) && (!lhs.hasJavaOuterClassname || lhs.javaOuterClassname == rhs.javaOuterClassname)
  fieldCheck = fieldCheck && (lhs.hasOptimizeFor == rhs.hasOptimizeFor) && (!lhs.hasOptimizeFor || lhs.optimizeFor == rhs.optimizeFor)
  fieldCheck = fieldCheck && (lhs.hasJavaMultipleFiles == rhs.hasJavaMultipleFiles) && (!lhs.hasJavaMultipleFiles || lhs.javaMultipleFiles == rhs.javaMultipleFiles)
  fieldCheck = fieldCheck && (lhs.hasGoPackage == rhs.hasGoPackage) && (!lhs.hasGoPackage || lhs.goPackage == rhs.goPackage)
  fieldCheck = fieldCheck && (lhs.hasCcGenericServices == rhs.hasCcGenericServices) && (!lhs.hasCcGenericServices || lhs.ccGenericServices == rhs.ccGenericServices)
  fieldCheck = fieldCheck && (lhs.hasJavaGenericServices == rhs.hasJavaGenericServices) && (!lhs.hasJavaGenericServices || lhs.javaGenericServices == rhs.javaGenericServices)
  fieldCheck = fieldCheck && (lhs.hasPyGenericServices == rhs.hasPyGenericServices) && (!lhs.hasPyGenericServices || lhs.pyGenericServices == rhs.pyGenericServices)
  fieldCheck = fieldCheck && (lhs.hasJavaGenerateEqualsAndHash == rhs.hasJavaGenerateEqualsAndHash) && (!lhs.hasJavaGenerateEqualsAndHash || lhs.javaGenerateEqualsAndHash == rhs.javaGenerateEqualsAndHash)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.hasJavaStringCheckUtf8 == rhs.hasJavaStringCheckUtf8) && (!lhs.hasJavaStringCheckUtf8 || lhs.javaStringCheckUtf8 == rhs.javaStringCheckUtf8)
  fieldCheck = fieldCheck && (lhs.hasCcEnableArenas == rhs.hasCcEnableArenas) && (!lhs.hasCcEnableArenas || lhs.ccEnableArenas == rhs.ccEnableArenas)
  fieldCheck = fieldCheck && (lhs.hasObjcClassPrefix == rhs.hasObjcClassPrefix) && (!lhs.hasObjcClassPrefix || lhs.objcClassPrefix == rhs.objcClassPrefix)
  fieldCheck = fieldCheck && (lhs.hasCsharpNamespace == rhs.hasCsharpNamespace) && (!lhs.hasCsharpNamespace || lhs.csharpNamespace == rhs.csharpNamespace)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.MessageOptions, rhs: Google.Protobuf.MessageOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMessageSetWireFormat == rhs.hasMessageSetWireFormat) && (!lhs.hasMessageSetWireFormat || lhs.messageSetWireFormat == rhs.messageSetWireFormat)
  fieldCheck = fieldCheck && (lhs.hasNoStandardDescriptorAccessor == rhs.hasNoStandardDescriptorAccessor) && (!lhs.hasNoStandardDescriptorAccessor || lhs.noStandardDescriptorAccessor == rhs.noStandardDescriptorAccessor)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.hasMapEntry == rhs.hasMapEntry) && (!lhs.hasMapEntry || lhs.mapEntry == rhs.mapEntry)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.FieldOptions, rhs: Google.Protobuf.FieldOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCtype == rhs.hasCtype) && (!lhs.hasCtype || lhs.ctype == rhs.ctype)
  fieldCheck = fieldCheck && (lhs.hasPacked == rhs.hasPacked) && (!lhs.hasPacked || lhs.packed == rhs.packed)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.hasLazy == rhs.hasLazy) && (!lhs.hasLazy || lhs.lazy == rhs.lazy)
  fieldCheck = fieldCheck && (lhs.hasJstype == rhs.hasJstype) && (!lhs.hasJstype || lhs.jstype == rhs.jstype)
  fieldCheck = fieldCheck && (lhs.hasWeak == rhs.hasWeak) && (!lhs.hasWeak || lhs.weak == rhs.weak)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.EnumOptions, rhs: Google.Protobuf.EnumOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasAllowAlias == rhs.hasAllowAlias) && (!lhs.hasAllowAlias || lhs.allowAlias == rhs.allowAlias)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.EnumValueOptions, rhs: Google.Protobuf.EnumValueOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.ServiceOptions, rhs: Google.Protobuf.ServiceOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.MethodOptions, rhs: Google.Protobuf.MethodOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.UninterpretedOption, rhs: Google.Protobuf.UninterpretedOption) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasIdentifierValue == rhs.hasIdentifierValue) && (!lhs.hasIdentifierValue || lhs.identifierValue == rhs.identifierValue)
  fieldCheck = fieldCheck && (lhs.hasPositiveIntValue == rhs.hasPositiveIntValue) && (!lhs.hasPositiveIntValue || lhs.positiveIntValue == rhs.positiveIntValue)
  fieldCheck = fieldCheck && (lhs.hasNegativeIntValue == rhs.hasNegativeIntValue) && (!lhs.hasNegativeIntValue || lhs.negativeIntValue == rhs.negativeIntValue)
  fieldCheck = fieldCheck && (lhs.hasDoubleValue == rhs.hasDoubleValue) && (!lhs.hasDoubleValue || lhs.doubleValue == rhs.doubleValue)
  fieldCheck = fieldCheck && (lhs.hasStringValue == rhs.hasStringValue) && (!lhs.hasStringValue || lhs.stringValue == rhs.stringValue)
  fieldCheck = fieldCheck && (lhs.hasAggregateValue == rhs.hasAggregateValue) && (!lhs.hasAggregateValue || lhs.aggregateValue == rhs.aggregateValue)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.UninterpretedOption.NamePart, rhs: Google.Protobuf.UninterpretedOption.NamePart) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNamePart == rhs.hasNamePart) && (!lhs.hasNamePart || lhs.namePart == rhs.namePart)
  fieldCheck = fieldCheck && (lhs.hasIsExtension == rhs.hasIsExtension) && (!lhs.hasIsExtension || lhs.isExtension == rhs.isExtension)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.SourceCodeInfo, rhs: Google.Protobuf.SourceCodeInfo) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.location == rhs.location)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Google.Protobuf.SourceCodeInfo.Location, rhs: Google.Protobuf.SourceCodeInfo.Location) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.path == rhs.path)
  fieldCheck = fieldCheck && (lhs.span == rhs.span)
  fieldCheck = fieldCheck && (lhs.hasLeadingComments == rhs.hasLeadingComments) && (!lhs.hasLeadingComments || lhs.leadingComments == rhs.leadingComments)
  fieldCheck = fieldCheck && (lhs.hasTrailingComments == rhs.hasTrailingComments) && (!lhs.hasTrailingComments || lhs.trailingComments == rhs.trailingComments)
  fieldCheck = fieldCheck && (lhs.leadingDetachedComments == rhs.leadingDetachedComments)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Google.Protobuf {
  public struct DescriptorRoot {
    public static var sharedInstance : DescriptorRoot {
     struct Static {
         static let instance : DescriptorRoot = DescriptorRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(_ registry:ExtensionRegistry) {
    }
  }

  // The protocol compiler can output a FileDescriptorSet containing the .proto
  // files it parses.
  final public class FileDescriptorSet : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var file:Array<Google.Protobuf.FileDescriptorProto>  = Array<Google.Protobuf.FileDescriptorProto>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitFile:Bool = true
      for oneElementFile in file {
        if !oneElementFile.isInitialized() {
          isInitFile = false
          break 
        }
      }
      if !isInitFile {
        return isInitFile
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      for oneElementFile in file {
          try output.writeMessage(1, value:oneElementFile)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementFile in file {
          serialize_size += oneElementFile.computeMessageSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.FileDescriptorSet> {
      var mergedArray = Array<Google.Protobuf.FileDescriptorSet>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FileDescriptorSet? {
      return try Google.Protobuf.FileDescriptorSet.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.FileDescriptorSet.Builder {
      return Google.Protobuf.FileDescriptorSet.classBuilder() as! Google.Protobuf.FileDescriptorSet.Builder
    }
    public func getBuilder() -> Google.Protobuf.FileDescriptorSet.Builder {
      return classBuilder() as! Google.Protobuf.FileDescriptorSet.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FileDescriptorSet.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FileDescriptorSet.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FileDescriptorSet.Builder {
      return try Google.Protobuf.FileDescriptorSet.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.FileDescriptorSet) throws -> Google.Protobuf.FileDescriptorSet.Builder {
      return try Google.Protobuf.FileDescriptorSet.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !file.isEmpty {
        var jsonArrayFile:Array<Dictionary<String,AnyObject>> = []
          for oneValueFile in file {
            let ecodedMessageFile = try oneValueFile.encode()
            jsonArrayFile += [ecodedMessageFile]
          }
        jsonMap["file"] = jsonArrayFile
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.FileDescriptorSet {
      return try Google.Protobuf.FileDescriptorSet.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      var fileElementIndex:Int = 0
      for oneElementFile in file {
          output += "\(indent) file[\(fileElementIndex)] {\n"
          output += try oneElementFile.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          fileElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementFile in file {
                hashCode = (hashCode &* 31) &+ oneElementFile.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FileDescriptorSet"
    }
    override public func className() -> String {
        return "Google.Protobuf.FileDescriptorSet"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.FileDescriptorSet.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.FileDescriptorSet = Google.Protobuf.FileDescriptorSet()
      public func getMessage() -> Google.Protobuf.FileDescriptorSet {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var file:Array<Google.Protobuf.FileDescriptorProto> {
           get {
               return builderResult.file
           }
           set (value) {
               builderResult.file = value
           }
      }
      public func setFile(_ value:Array<Google.Protobuf.FileDescriptorProto>) -> Google.Protobuf.FileDescriptorSet.Builder {
        self.file = value
        return self
      }
      public func clearFile() -> Google.Protobuf.FileDescriptorSet.Builder {
        builderResult.file.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.FileDescriptorSet.Builder {
        builderResult = Google.Protobuf.FileDescriptorSet()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FileDescriptorSet.Builder {
        return try Google.Protobuf.FileDescriptorSet.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.FileDescriptorSet {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FileDescriptorSet {
        let returnMe:Google.Protobuf.FileDescriptorSet = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.FileDescriptorSet) throws -> Google.Protobuf.FileDescriptorSet.Builder {
        if other == Google.Protobuf.FileDescriptorSet() {
         return self
        }
        if !other.file.isEmpty  {
           builderResult.file += other.file
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FileDescriptorSet.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorSet.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Google.Protobuf.FileDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            file += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FileDescriptorSet.Builder {
        let resultDecodedBuilder = Google.Protobuf.FileDescriptorSet.Builder()
        if let jsonValueFile = jsonMap["file"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayFile:Array<Google.Protobuf.FileDescriptorProto> = []
          for oneValueFile in jsonValueFile {
            let messageFromStringFile = try Google.Protobuf.FileDescriptorProto.Builder.decodeToBuilder(oneValueFile).build()

            jsonArrayFile += [messageFromStringFile]
          }
          resultDecodedBuilder.file = jsonArrayFile
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.FileDescriptorSet.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FileDescriptorSet.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Describes a complete .proto file.
  final public class FileDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    // file name, relative to root of source tree
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    // e.g. "foo", "foo.bar", etc.
    public private(set) var hasPackage:Bool = false
    public private(set) var package:String = ""

    // Names of files imported by this file.
    public private(set) var dependency:Array<String> = Array<String>()
    // Indexes of the public imported files in the dependency list above.
    public private(set) var publicDependency:Array<Int32> = Array<Int32>()
    // Indexes of the weak imported files in the dependency list.
    // For Google-internal migration only. Do not use.
    public private(set) var weakDependency:Array<Int32> = Array<Int32>()
    public private(set) var messageType:Array<Google.Protobuf.DescriptorProto>  = Array<Google.Protobuf.DescriptorProto>()
    public private(set) var enumType:Array<Google.Protobuf.EnumDescriptorProto>  = Array<Google.Protobuf.EnumDescriptorProto>()
    public private(set) var service:Array<Google.Protobuf.ServiceDescriptorProto>  = Array<Google.Protobuf.ServiceDescriptorProto>()
    public private(set) var extension_:Array<Google.Protobuf.FieldDescriptorProto>  = Array<Google.Protobuf.FieldDescriptorProto>()
    public private(set) var hasOptions:Bool = false
    public private(set) var options:Google.Protobuf.FileOptions!
    public private(set) var hasSourceCodeInfo:Bool = false
    public private(set) var sourceCodeInfo:Google.Protobuf.SourceCodeInfo!
    // The syntax of the proto file.
    // The supported values are "proto2" and "proto3".
    public private(set) var hasSyntax:Bool = false
    public private(set) var syntax:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitMessageType:Bool = true
      for oneElementMessageType in messageType {
        if !oneElementMessageType.isInitialized() {
          isInitMessageType = false
          break 
        }
      }
      if !isInitMessageType {
        return isInitMessageType
      }
      var isInitEnumType:Bool = true
      for oneElementEnumType in enumType {
        if !oneElementEnumType.isInitialized() {
          isInitEnumType = false
          break 
        }
      }
      if !isInitEnumType {
        return isInitEnumType
      }
      var isInitService:Bool = true
      for oneElementService in service {
        if !oneElementService.isInitialized() {
          isInitService = false
          break 
        }
      }
      if !isInitService {
        return isInitService
      }
      var isInitExtension:Bool = true
      for oneElementExtension in extension_ {
        if !oneElementExtension.isInitialized() {
          isInitExtension = false
          break 
        }
      }
      if !isInitExtension {
        return isInitExtension
      }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasName {
        try output.writeString(1, value:name)
      }
      if hasPackage {
        try output.writeString(2, value:package)
      }
      if !dependency.isEmpty {
        for oneValuedependency in dependency {
          try output.writeString(3, value:oneValuedependency)
        }
      }
      for oneElementMessageType in messageType {
          try output.writeMessage(4, value:oneElementMessageType)
      }
      for oneElementEnumType in enumType {
          try output.writeMessage(5, value:oneElementEnumType)
      }
      for oneElementService in service {
          try output.writeMessage(6, value:oneElementService)
      }
      for oneElementExtension in extension_ {
          try output.writeMessage(7, value:oneElementExtension)
      }
      if hasOptions {
        try output.writeMessage(8, value:options)
      }
      if hasSourceCodeInfo {
        try output.writeMessage(9, value:sourceCodeInfo)
      }
      if !publicDependency.isEmpty {
        for oneValuepublicDependency in publicDependency {
          try output.writeInt32(10, value:oneValuepublicDependency)
        }
      }
      if !weakDependency.isEmpty {
        for oneValueweakDependency in weakDependency {
          try output.writeInt32(11, value:oneValueweakDependency)
        }
      }
      if hasSyntax {
        try output.writeString(12, value:syntax)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      if hasPackage {
        serialize_size += package.computeStringSize(2)
      }
      var dataSizeDependency:Int32 = 0
      for oneValuedependency in dependency {
          dataSizeDependency += oneValuedependency.computeStringSizeNoTag()
      }
      serialize_size += dataSizeDependency
      serialize_size += 1 * Int32(dependency.count)
      for oneElementMessageType in messageType {
          serialize_size += oneElementMessageType.computeMessageSize(4)
      }
      for oneElementEnumType in enumType {
          serialize_size += oneElementEnumType.computeMessageSize(5)
      }
      for oneElementService in service {
          serialize_size += oneElementService.computeMessageSize(6)
      }
      for oneElementExtension in extension_ {
          serialize_size += oneElementExtension.computeMessageSize(7)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(8) {
              serialize_size += varSizeoptions
          }
      }
      if hasSourceCodeInfo {
          if let varSizesourceCodeInfo = sourceCodeInfo?.computeMessageSize(9) {
              serialize_size += varSizesourceCodeInfo
          }
      }
      var dataSizePublicDependency:Int32 = 0
      for oneValuepublicDependency in publicDependency {
          dataSizePublicDependency += oneValuepublicDependency.computeInt32SizeNoTag()
      }
      serialize_size += dataSizePublicDependency
      serialize_size += 1 * Int32(publicDependency.count)
      var dataSizeWeakDependency:Int32 = 0
      for oneValueweakDependency in weakDependency {
          dataSizeWeakDependency += oneValueweakDependency.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeWeakDependency
      serialize_size += 1 * Int32(weakDependency.count)
      if hasSyntax {
        serialize_size += syntax.computeStringSize(12)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.FileDescriptorProto> {
      var mergedArray = Array<Google.Protobuf.FileDescriptorProto>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FileDescriptorProto? {
      return try Google.Protobuf.FileDescriptorProto.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.FileDescriptorProto.Builder {
      return Google.Protobuf.FileDescriptorProto.classBuilder() as! Google.Protobuf.FileDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.FileDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.FileDescriptorProto.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FileDescriptorProto.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FileDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FileDescriptorProto.Builder {
      return try Google.Protobuf.FileDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.FileDescriptorProto) throws -> Google.Protobuf.FileDescriptorProto.Builder {
      return try Google.Protobuf.FileDescriptorProto.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasName {
        jsonMap["name"] = name
      }
      if hasPackage {
        jsonMap["package"] = package
      }
      if !dependency.isEmpty {
        jsonMap["dependency"] = dependency
      }
      if !publicDependency.isEmpty {
        var jsonArrayPublicDependency:Array<NSNumber> = []
          for oneValuePublicDependency in publicDependency {
            jsonArrayPublicDependency += [NSNumber(value:oneValuePublicDependency)]
          }
        jsonMap["publicDependency"] = jsonArrayPublicDependency
      }
      if !weakDependency.isEmpty {
        var jsonArrayWeakDependency:Array<NSNumber> = []
          for oneValueWeakDependency in weakDependency {
            jsonArrayWeakDependency += [NSNumber(value:oneValueWeakDependency)]
          }
        jsonMap["weakDependency"] = jsonArrayWeakDependency
      }
      if !messageType.isEmpty {
        var jsonArrayMessageType:Array<Dictionary<String,AnyObject>> = []
          for oneValueMessageType in messageType {
            let ecodedMessageMessageType = try oneValueMessageType.encode()
            jsonArrayMessageType += [ecodedMessageMessageType]
          }
        jsonMap["messageType"] = jsonArrayMessageType
      }
      if !enumType.isEmpty {
        var jsonArrayEnumType:Array<Dictionary<String,AnyObject>> = []
          for oneValueEnumType in enumType {
            let ecodedMessageEnumType = try oneValueEnumType.encode()
            jsonArrayEnumType += [ecodedMessageEnumType]
          }
        jsonMap["enumType"] = jsonArrayEnumType
      }
      if !service.isEmpty {
        var jsonArrayService:Array<Dictionary<String,AnyObject>> = []
          for oneValueService in service {
            let ecodedMessageService = try oneValueService.encode()
            jsonArrayService += [ecodedMessageService]
          }
        jsonMap["service"] = jsonArrayService
      }
      if !extension_.isEmpty {
        var jsonArrayExtension:Array<Dictionary<String,AnyObject>> = []
          for oneValueExtension in extension_ {
            let ecodedMessageExtension = try oneValueExtension.encode()
            jsonArrayExtension += [ecodedMessageExtension]
          }
        jsonMap["extension"] = jsonArrayExtension
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      if hasSourceCodeInfo {
        jsonMap["sourceCodeInfo"] = try sourceCodeInfo.encode()
      }
      if hasSyntax {
        jsonMap["syntax"] = syntax
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.FileDescriptorProto {
      return try Google.Protobuf.FileDescriptorProto.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasPackage {
        output += "\(indent) package: \(package) \n"
      }
      var dependencyElementIndex:Int = 0
      for oneValueDependency in dependency  {
          output += "\(indent) dependency[\(dependencyElementIndex)]: \(oneValueDependency)\n"
          dependencyElementIndex += 1
      }
      var messageTypeElementIndex:Int = 0
      for oneElementMessageType in messageType {
          output += "\(indent) messageType[\(messageTypeElementIndex)] {\n"
          output += try oneElementMessageType.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          messageTypeElementIndex += 1
      }
      var enumTypeElementIndex:Int = 0
      for oneElementEnumType in enumType {
          output += "\(indent) enumType[\(enumTypeElementIndex)] {\n"
          output += try oneElementEnumType.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          enumTypeElementIndex += 1
      }
      var serviceElementIndex:Int = 0
      for oneElementService in service {
          output += "\(indent) service[\(serviceElementIndex)] {\n"
          output += try oneElementService.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          serviceElementIndex += 1
      }
      var extension_ElementIndex:Int = 0
      for oneElementExtension in extension_ {
          output += "\(indent) extension_[\(extension_ElementIndex)] {\n"
          output += try oneElementExtension.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          extension_ElementIndex += 1
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasSourceCodeInfo {
        output += "\(indent) sourceCodeInfo {\n"
        if let outDescSourceCodeInfo = sourceCodeInfo {
          output += try outDescSourceCodeInfo.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var publicDependencyElementIndex:Int = 0
      for oneValuePublicDependency in publicDependency  {
          output += "\(indent) publicDependency[\(publicDependencyElementIndex)]: \(oneValuePublicDependency)\n"
          publicDependencyElementIndex += 1
      }
      var weakDependencyElementIndex:Int = 0
      for oneValueWeakDependency in weakDependency  {
          output += "\(indent) weakDependency[\(weakDependencyElementIndex)]: \(oneValueWeakDependency)\n"
          weakDependencyElementIndex += 1
      }
      if hasSyntax {
        output += "\(indent) syntax: \(syntax) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasPackage {
               hashCode = (hashCode &* 31) &+ package.hashValue
            }
            for oneValueDependency in dependency {
                hashCode = (hashCode &* 31) &+ oneValueDependency.hashValue
            }
            for oneElementMessageType in messageType {
                hashCode = (hashCode &* 31) &+ oneElementMessageType.hashValue
            }
            for oneElementEnumType in enumType {
                hashCode = (hashCode &* 31) &+ oneElementEnumType.hashValue
            }
            for oneElementService in service {
                hashCode = (hashCode &* 31) &+ oneElementService.hashValue
            }
            for oneElementExtension in extension_ {
                hashCode = (hashCode &* 31) &+ oneElementExtension.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            if hasSourceCodeInfo {
                if let hashValuesourceCodeInfo = sourceCodeInfo?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesourceCodeInfo
                }
            }
            for oneValuePublicDependency in publicDependency {
                hashCode = (hashCode &* 31) &+ oneValuePublicDependency.hashValue
            }
            for oneValueWeakDependency in weakDependency {
                hashCode = (hashCode &* 31) &+ oneValueWeakDependency.hashValue
            }
            if hasSyntax {
               hashCode = (hashCode &* 31) &+ syntax.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FileDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.FileDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.FileDescriptorProto.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.FileDescriptorProto = Google.Protobuf.FileDescriptorProto()
      public func getMessage() -> Google.Protobuf.FileDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(_ value:String) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Google.Protobuf.FileDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var hasPackage:Bool {
           get {
                return builderResult.hasPackage
           }
      }
      public var package:String {
           get {
                return builderResult.package
           }
           set (value) {
               builderResult.hasPackage = true
               builderResult.package = value
           }
      }
      public func setPackage(_ value:String) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.package = value
        return self
      }
      public func clearPackage() -> Google.Protobuf.FileDescriptorProto.Builder{
           builderResult.hasPackage = false
           builderResult.package = ""
           return self
      }
      public var dependency:Array<String> {
           get {
               return builderResult.dependency
           }
           set (array) {
               builderResult.dependency = array
           }
      }
      public func setDependency(_ value:Array<String>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.dependency = value
        return self
      }
      public func clearDependency() -> Google.Protobuf.FileDescriptorProto.Builder {
         builderResult.dependency.removeAll(keepingCapacity: false)
         return self
      }
      public var publicDependency:Array<Int32> {
           get {
               return builderResult.publicDependency
           }
           set (array) {
               builderResult.publicDependency = array
           }
      }
      public func setPublicDependency(_ value:Array<Int32>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.publicDependency = value
        return self
      }
      public func clearPublicDependency() -> Google.Protobuf.FileDescriptorProto.Builder {
         builderResult.publicDependency.removeAll(keepingCapacity: false)
         return self
      }
      public var weakDependency:Array<Int32> {
           get {
               return builderResult.weakDependency
           }
           set (array) {
               builderResult.weakDependency = array
           }
      }
      public func setWeakDependency(_ value:Array<Int32>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.weakDependency = value
        return self
      }
      public func clearWeakDependency() -> Google.Protobuf.FileDescriptorProto.Builder {
         builderResult.weakDependency.removeAll(keepingCapacity: false)
         return self
      }
      public var messageType:Array<Google.Protobuf.DescriptorProto> {
           get {
               return builderResult.messageType
           }
           set (value) {
               builderResult.messageType = value
           }
      }
      public func setMessageType(_ value:Array<Google.Protobuf.DescriptorProto>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.messageType = value
        return self
      }
      public func clearMessageType() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult.messageType.removeAll(keepingCapacity: false)
        return self
      }
      public var enumType:Array<Google.Protobuf.EnumDescriptorProto> {
           get {
               return builderResult.enumType
           }
           set (value) {
               builderResult.enumType = value
           }
      }
      public func setEnumType(_ value:Array<Google.Protobuf.EnumDescriptorProto>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.enumType = value
        return self
      }
      public func clearEnumType() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult.enumType.removeAll(keepingCapacity: false)
        return self
      }
      public var service:Array<Google.Protobuf.ServiceDescriptorProto> {
           get {
               return builderResult.service
           }
           set (value) {
               builderResult.service = value
           }
      }
      public func setService(_ value:Array<Google.Protobuf.ServiceDescriptorProto>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.service = value
        return self
      }
      public func clearService() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult.service.removeAll(keepingCapacity: false)
        return self
      }
      public var extension_:Array<Google.Protobuf.FieldDescriptorProto> {
           get {
               return builderResult.extension_
           }
           set (value) {
               builderResult.extension_ = value
           }
      }
      public func setExtension(_ value:Array<Google.Protobuf.FieldDescriptorProto>) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.extension_ = value
        return self
      }
      public func clearExtension() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult.extension_.removeAll(keepingCapacity: false)
        return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.FileOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      private var optionsBuilder_:Google.Protobuf.FileOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.FileOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.FileOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(options)
           }
        }
        return optionsBuilder_
      }
      public func setOptions(_ value:Google.Protobuf.FileOptions!) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.options = value
        return self
      }
      public func mergeOptions(_ value:Google.Protobuf.FileOptions) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.FileOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      public func clearOptions() -> Google.Protobuf.FileDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      public var hasSourceCodeInfo:Bool {
           get {
               return builderResult.hasSourceCodeInfo
           }
      }
      public var sourceCodeInfo:Google.Protobuf.SourceCodeInfo! {
           get {
               if sourceCodeInfoBuilder_ != nil {
                  builderResult.sourceCodeInfo = sourceCodeInfoBuilder_.getMessage()
               }
               return builderResult.sourceCodeInfo
           }
           set (value) {
               builderResult.hasSourceCodeInfo = true
               builderResult.sourceCodeInfo = value
           }
      }
      private var sourceCodeInfoBuilder_:Google.Protobuf.SourceCodeInfo.Builder! {
           didSet {
              builderResult.hasSourceCodeInfo = true
           }
      }
      public func getSourceCodeInfoBuilder() -> Google.Protobuf.SourceCodeInfo.Builder {
        if sourceCodeInfoBuilder_ == nil {
           sourceCodeInfoBuilder_ = Google.Protobuf.SourceCodeInfo.Builder()
           builderResult.sourceCodeInfo = sourceCodeInfoBuilder_.getMessage()
           if sourceCodeInfo != nil {
              try! sourceCodeInfoBuilder_.mergeFrom(sourceCodeInfo)
           }
        }
        return sourceCodeInfoBuilder_
      }
      public func setSourceCodeInfo(_ value:Google.Protobuf.SourceCodeInfo!) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.sourceCodeInfo = value
        return self
      }
      public func mergeSourceCodeInfo(_ value:Google.Protobuf.SourceCodeInfo) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        if builderResult.hasSourceCodeInfo {
          builderResult.sourceCodeInfo = try Google.Protobuf.SourceCodeInfo.builderWithPrototype(builderResult.sourceCodeInfo).mergeFrom(value).buildPartial()
        } else {
          builderResult.sourceCodeInfo = value
        }
        builderResult.hasSourceCodeInfo = true
        return self
      }
      public func clearSourceCodeInfo() -> Google.Protobuf.FileDescriptorProto.Builder {
        sourceCodeInfoBuilder_ = nil
        builderResult.hasSourceCodeInfo = false
        builderResult.sourceCodeInfo = nil
        return self
      }
      public var hasSyntax:Bool {
           get {
                return builderResult.hasSyntax
           }
      }
      public var syntax:String {
           get {
                return builderResult.syntax
           }
           set (value) {
               builderResult.hasSyntax = true
               builderResult.syntax = value
           }
      }
      public func setSyntax(_ value:String) -> Google.Protobuf.FileDescriptorProto.Builder {
        self.syntax = value
        return self
      }
      public func clearSyntax() -> Google.Protobuf.FileDescriptorProto.Builder{
           builderResult.hasSyntax = false
           builderResult.syntax = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.FileDescriptorProto.Builder {
        builderResult = Google.Protobuf.FileDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FileDescriptorProto.Builder {
        return try Google.Protobuf.FileDescriptorProto.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.FileDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FileDescriptorProto {
        let returnMe:Google.Protobuf.FileDescriptorProto = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.FileDescriptorProto) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        if other == Google.Protobuf.FileDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if other.hasPackage {
             package = other.package
        }
        if !other.dependency.isEmpty {
            builderResult.dependency += other.dependency
        }
        if !other.publicDependency.isEmpty {
            builderResult.publicDependency += other.publicDependency
        }
        if !other.weakDependency.isEmpty {
            builderResult.weakDependency += other.weakDependency
        }
        if !other.messageType.isEmpty  {
           builderResult.messageType += other.messageType
        }
        if !other.enumType.isEmpty  {
           builderResult.enumType += other.enumType
        }
        if !other.service.isEmpty  {
           builderResult.service += other.service
        }
        if !other.extension_.isEmpty  {
           builderResult.extension_ += other.extension_
        }
        if (other.hasOptions) {
            try mergeOptions(other.options)
        }
        if (other.hasSourceCodeInfo) {
            try mergeSourceCodeInfo(other.sourceCodeInfo)
        }
        if other.hasSyntax {
             syntax = other.syntax
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FileDescriptorProto.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try input.readString()

          case 18:
            package = try input.readString()

          case 26:
            dependency += [try input.readString()]

          case 34:
            let subBuilder = Google.Protobuf.DescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            messageType += [subBuilder.buildPartial()]

          case 42:
            let subBuilder = Google.Protobuf.EnumDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            enumType += [subBuilder.buildPartial()]

          case 50:
            let subBuilder = Google.Protobuf.ServiceDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            service += [subBuilder.buildPartial()]

          case 58:
            let subBuilder = Google.Protobuf.FieldDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            extension_ += [subBuilder.buildPartial()]

          case 66:
            let subBuilder:Google.Protobuf.FileOptions.Builder = Google.Protobuf.FileOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(options)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          case 74:
            let subBuilder:Google.Protobuf.SourceCodeInfo.Builder = Google.Protobuf.SourceCodeInfo.Builder()
            if hasSourceCodeInfo {
              try subBuilder.mergeFrom(sourceCodeInfo)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            sourceCodeInfo = subBuilder.buildPartial()

          case 80:
            publicDependency += [try input.readInt32()]

          case 88:
            weakDependency += [try input.readInt32()]

          case 98:
            syntax = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.FileDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValuePackage = jsonMap["package"] as? String {
          resultDecodedBuilder.package = jsonValuePackage
        }
        if let jsonValueDependency = jsonMap["dependency"] as? Array<String> {
          resultDecodedBuilder.dependency = jsonValueDependency
        }
        if let jsonValuePublicDependency = jsonMap["publicDependency"] as? Array<NSNumber> {
          var jsonArrayPublicDependency:Array<Int32> = []
          for oneValuePublicDependency in jsonValuePublicDependency {
            jsonArrayPublicDependency += [oneValuePublicDependency.int32Value]
          }
          resultDecodedBuilder.publicDependency = jsonArrayPublicDependency
        }
        if let jsonValueWeakDependency = jsonMap["weakDependency"] as? Array<NSNumber> {
          var jsonArrayWeakDependency:Array<Int32> = []
          for oneValueWeakDependency in jsonValueWeakDependency {
            jsonArrayWeakDependency += [oneValueWeakDependency.int32Value]
          }
          resultDecodedBuilder.weakDependency = jsonArrayWeakDependency
        }
        if let jsonValueMessageType = jsonMap["messageType"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayMessageType:Array<Google.Protobuf.DescriptorProto> = []
          for oneValueMessageType in jsonValueMessageType {
            let messageFromStringMessageType = try Google.Protobuf.DescriptorProto.Builder.decodeToBuilder(oneValueMessageType).build()

            jsonArrayMessageType += [messageFromStringMessageType]
          }
          resultDecodedBuilder.messageType = jsonArrayMessageType
        }
        if let jsonValueEnumType = jsonMap["enumType"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayEnumType:Array<Google.Protobuf.EnumDescriptorProto> = []
          for oneValueEnumType in jsonValueEnumType {
            let messageFromStringEnumType = try Google.Protobuf.EnumDescriptorProto.Builder.decodeToBuilder(oneValueEnumType).build()

            jsonArrayEnumType += [messageFromStringEnumType]
          }
          resultDecodedBuilder.enumType = jsonArrayEnumType
        }
        if let jsonValueService = jsonMap["service"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayService:Array<Google.Protobuf.ServiceDescriptorProto> = []
          for oneValueService in jsonValueService {
            let messageFromStringService = try Google.Protobuf.ServiceDescriptorProto.Builder.decodeToBuilder(oneValueService).build()

            jsonArrayService += [messageFromStringService]
          }
          resultDecodedBuilder.service = jsonArrayService
        }
        if let jsonValueExtension = jsonMap["extension"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayExtension:Array<Google.Protobuf.FieldDescriptorProto> = []
          for oneValueExtension in jsonValueExtension {
            let messageFromStringExtension = try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(oneValueExtension).build()

            jsonArrayExtension += [messageFromStringExtension]
          }
          resultDecodedBuilder.extension_ = jsonArrayExtension
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.options = try Google.Protobuf.FileOptions.Builder.decodeToBuilder(jsonValueOptions).build()

        }
        if let jsonValueSourceCodeInfo = jsonMap["sourceCodeInfo"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.sourceCodeInfo = try Google.Protobuf.SourceCodeInfo.Builder.decodeToBuilder(jsonValueSourceCodeInfo).build()

        }
        if let jsonValueSyntax = jsonMap["syntax"] as? String {
          resultDecodedBuilder.syntax = jsonValueSyntax
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.FileDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FileDescriptorProto.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Describes a message type.
  final public class DescriptorProto : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class ExtensionRange : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasStart:Bool = false
        public private(set) var start:Int32 = Int32(0)

        public private(set) var hasEnd:Bool = false
        public private(set) var end:Int32 = Int32(0)

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
          if hasStart {
            try output.writeInt32(1, value:start)
          }
          if hasEnd {
            try output.writeInt32(2, value:end)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasStart {
            serialize_size += start.computeInt32Size(1)
          }
          if hasEnd {
            serialize_size += end.computeInt32Size(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.DescriptorProto.ExtensionRange> {
          var mergedArray = Array<Google.Protobuf.DescriptorProto.ExtensionRange>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.DescriptorProto.ExtensionRange? {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(_ data:Data) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
          return Google.Protobuf.DescriptorProto.ExtensionRange.classBuilder() as! Google.Protobuf.DescriptorProto.ExtensionRange.Builder
        }
        public func getBuilder() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
          return classBuilder() as! Google.Protobuf.DescriptorProto.ExtensionRange.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return Google.Protobuf.DescriptorProto.ExtensionRange.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return Google.Protobuf.DescriptorProto.ExtensionRange.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.builderWithPrototype(self)
        }
        public class func builderWithPrototype(_ prototype:Google.Protobuf.DescriptorProto.ExtensionRange) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasStart {
            jsonMap["start"] = NSNumber(value:start)
          }
          if hasEnd {
            jsonMap["end"] = NSNumber(value:end)
          }
          return jsonMap
        }
        override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
          return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(_ indent:String) throws -> String {
          var output = ""
          if hasStart {
            output += "\(indent) start: \(start) \n"
          }
          if hasEnd {
            output += "\(indent) end: \(end) \n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStart {
                   hashCode = (hashCode &* 31) &+ start.hashValue
                }
                if hasEnd {
                   hashCode = (hashCode &* 31) &+ end.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.DescriptorProto.ExtensionRange"
        }
        override public func className() -> String {
            return "Google.Protobuf.DescriptorProto.ExtensionRange"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Google.Protobuf.DescriptorProto.ExtensionRange.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:Google.Protobuf.DescriptorProto.ExtensionRange = Google.Protobuf.DescriptorProto.ExtensionRange()
          public func getMessage() -> Google.Protobuf.DescriptorProto.ExtensionRange {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasStart:Bool {
               get {
                    return builderResult.hasStart
               }
          }
          public var start:Int32 {
               get {
                    return builderResult.start
               }
               set (value) {
                   builderResult.hasStart = true
                   builderResult.start = value
               }
          }
          public func setStart(_ value:Int32) -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            self.start = value
            return self
          }
          public func clearStart() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder{
               builderResult.hasStart = false
               builderResult.start = Int32(0)
               return self
          }
          public var hasEnd:Bool {
               get {
                    return builderResult.hasEnd
               }
          }
          public var end:Int32 {
               get {
                    return builderResult.end
               }
               set (value) {
                   builderResult.hasEnd = true
                   builderResult.end = value
               }
          }
          public func setEnd(_ value:Int32) -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            self.end = value
            return self
          }
          public func clearEnd() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder{
               builderResult.hasEnd = false
               builderResult.end = Int32(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            builderResult = Google.Protobuf.DescriptorProto.ExtensionRange()
            return self
          }
          override public func clone() throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            return try Google.Protobuf.DescriptorProto.ExtensionRange.builderWithPrototype(builderResult)
          }
          override public func build() throws -> Google.Protobuf.DescriptorProto.ExtensionRange {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Google.Protobuf.DescriptorProto.ExtensionRange {
            let returnMe:Google.Protobuf.DescriptorProto.ExtensionRange = builderResult
            return returnMe
          }
          public func mergeFrom(_ other:Google.Protobuf.DescriptorProto.ExtensionRange) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            if other == Google.Protobuf.DescriptorProto.ExtensionRange() {
             return self
            }
            if other.hasStart {
                 start = other.start
            }
            if other.hasEnd {
                 end = other.end
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8:
                start = try input.readInt32()

              case 16:
                end = try input.readInt32()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            let resultDecodedBuilder = Google.Protobuf.DescriptorProto.ExtensionRange.Builder()
            if let jsonValueStart = jsonMap["start"] as? NSNumber {
              resultDecodedBuilder.start = jsonValueStart.int32Value
            }
            if let jsonValueEnd = jsonMap["end"] as? NSNumber {
              resultDecodedBuilder.end = jsonValueEnd.int32Value
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.DescriptorProto.ExtensionRange.Builder {
            let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Google.Protobuf.DescriptorProto.ExtensionRange.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      // Range of reserved tag numbers. Reserved tag numbers may not be used by
      // fields or extension ranges in the same message. Reserved ranges may
      // not overlap.
      final public class ReservedRange : GeneratedMessage, GeneratedMessageProtocol {
        // Inclusive.
        public private(set) var hasStart:Bool = false
        public private(set) var start:Int32 = Int32(0)

        // Exclusive.
        public private(set) var hasEnd:Bool = false
        public private(set) var end:Int32 = Int32(0)

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
          if hasStart {
            try output.writeInt32(1, value:start)
          }
          if hasEnd {
            try output.writeInt32(2, value:end)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasStart {
            serialize_size += start.computeInt32Size(1)
          }
          if hasEnd {
            serialize_size += end.computeInt32Size(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.DescriptorProto.ReservedRange> {
          var mergedArray = Array<Google.Protobuf.DescriptorProto.ReservedRange>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.DescriptorProto.ReservedRange? {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(_ data:Data) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
          return Google.Protobuf.DescriptorProto.ReservedRange.classBuilder() as! Google.Protobuf.DescriptorProto.ReservedRange.Builder
        }
        public func getBuilder() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
          return classBuilder() as! Google.Protobuf.DescriptorProto.ReservedRange.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return Google.Protobuf.DescriptorProto.ReservedRange.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return Google.Protobuf.DescriptorProto.ReservedRange.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
          return try Google.Protobuf.DescriptorProto.ReservedRange.builderWithPrototype(self)
        }
        public class func builderWithPrototype(_ prototype:Google.Protobuf.DescriptorProto.ReservedRange) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasStart {
            jsonMap["start"] = NSNumber(value:start)
          }
          if hasEnd {
            jsonMap["end"] = NSNumber(value:end)
          }
          return jsonMap
        }
        override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.DescriptorProto.ReservedRange {
          return try Google.Protobuf.DescriptorProto.ReservedRange.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(_ indent:String) throws -> String {
          var output = ""
          if hasStart {
            output += "\(indent) start: \(start) \n"
          }
          if hasEnd {
            output += "\(indent) end: \(end) \n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStart {
                   hashCode = (hashCode &* 31) &+ start.hashValue
                }
                if hasEnd {
                   hashCode = (hashCode &* 31) &+ end.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.DescriptorProto.ReservedRange"
        }
        override public func className() -> String {
            return "Google.Protobuf.DescriptorProto.ReservedRange"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Google.Protobuf.DescriptorProto.ReservedRange.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:Google.Protobuf.DescriptorProto.ReservedRange = Google.Protobuf.DescriptorProto.ReservedRange()
          public func getMessage() -> Google.Protobuf.DescriptorProto.ReservedRange {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasStart:Bool {
               get {
                    return builderResult.hasStart
               }
          }
          public var start:Int32 {
               get {
                    return builderResult.start
               }
               set (value) {
                   builderResult.hasStart = true
                   builderResult.start = value
               }
          }
          public func setStart(_ value:Int32) -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            self.start = value
            return self
          }
          public func clearStart() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder{
               builderResult.hasStart = false
               builderResult.start = Int32(0)
               return self
          }
          public var hasEnd:Bool {
               get {
                    return builderResult.hasEnd
               }
          }
          public var end:Int32 {
               get {
                    return builderResult.end
               }
               set (value) {
                   builderResult.hasEnd = true
                   builderResult.end = value
               }
          }
          public func setEnd(_ value:Int32) -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            self.end = value
            return self
          }
          public func clearEnd() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder{
               builderResult.hasEnd = false
               builderResult.end = Int32(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            builderResult = Google.Protobuf.DescriptorProto.ReservedRange()
            return self
          }
          override public func clone() throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            return try Google.Protobuf.DescriptorProto.ReservedRange.builderWithPrototype(builderResult)
          }
          override public func build() throws -> Google.Protobuf.DescriptorProto.ReservedRange {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Google.Protobuf.DescriptorProto.ReservedRange {
            let returnMe:Google.Protobuf.DescriptorProto.ReservedRange = builderResult
            return returnMe
          }
          public func mergeFrom(_ other:Google.Protobuf.DescriptorProto.ReservedRange) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            if other == Google.Protobuf.DescriptorProto.ReservedRange() {
             return self
            }
            if other.hasStart {
                 start = other.start
            }
            if other.hasEnd {
                 end = other.end
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8:
                start = try input.readInt32()

              case 16:
                end = try input.readInt32()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            let resultDecodedBuilder = Google.Protobuf.DescriptorProto.ReservedRange.Builder()
            if let jsonValueStart = jsonMap["start"] as? NSNumber {
              resultDecodedBuilder.start = jsonValueStart.int32Value
            }
            if let jsonValueEnd = jsonMap["end"] as? NSNumber {
              resultDecodedBuilder.end = jsonValueEnd.int32Value
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.DescriptorProto.ReservedRange.Builder {
            let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Google.Protobuf.DescriptorProto.ReservedRange.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var field:Array<Google.Protobuf.FieldDescriptorProto>  = Array<Google.Protobuf.FieldDescriptorProto>()
    public private(set) var extension_:Array<Google.Protobuf.FieldDescriptorProto>  = Array<Google.Protobuf.FieldDescriptorProto>()
    public private(set) var nestedType:Array<Google.Protobuf.DescriptorProto>  = Array<Google.Protobuf.DescriptorProto>()
    public private(set) var enumType:Array<Google.Protobuf.EnumDescriptorProto>  = Array<Google.Protobuf.EnumDescriptorProto>()
    public private(set) var extensionRange:Array<ExtensionRange>  = Array<Google.Protobuf.DescriptorProto.ExtensionRange>()
    public private(set) var oneofDecl:Array<Google.Protobuf.OneofDescriptorProto>  = Array<Google.Protobuf.OneofDescriptorProto>()
    public private(set) var hasOptions:Bool = false
    public private(set) var options:Google.Protobuf.MessageOptions!
    public private(set) var reservedRange:Array<ReservedRange>  = Array<Google.Protobuf.DescriptorProto.ReservedRange>()
    // Reserved field names, which may not be used by fields in the same message.
    // A given name may only be reserved once.
    public private(set) var reservedName:Array<String> = Array<String>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitField:Bool = true
      for oneElementField in field {
        if !oneElementField.isInitialized() {
          isInitField = false
          break 
        }
      }
      if !isInitField {
        return isInitField
      }
      var isInitExtension:Bool = true
      for oneElementExtension in extension_ {
        if !oneElementExtension.isInitialized() {
          isInitExtension = false
          break 
        }
      }
      if !isInitExtension {
        return isInitExtension
      }
      var isInitNestedType:Bool = true
      for oneElementNestedType in nestedType {
        if !oneElementNestedType.isInitialized() {
          isInitNestedType = false
          break 
        }
      }
      if !isInitNestedType {
        return isInitNestedType
      }
      var isInitEnumType:Bool = true
      for oneElementEnumType in enumType {
        if !oneElementEnumType.isInitialized() {
          isInitEnumType = false
          break 
        }
      }
      if !isInitEnumType {
        return isInitEnumType
      }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasName {
        try output.writeString(1, value:name)
      }
      for oneElementField in field {
          try output.writeMessage(2, value:oneElementField)
      }
      for oneElementNestedType in nestedType {
          try output.writeMessage(3, value:oneElementNestedType)
      }
      for oneElementEnumType in enumType {
          try output.writeMessage(4, value:oneElementEnumType)
      }
      for oneElementExtensionRange in extensionRange {
          try output.writeMessage(5, value:oneElementExtensionRange)
      }
      for oneElementExtension in extension_ {
          try output.writeMessage(6, value:oneElementExtension)
      }
      if hasOptions {
        try output.writeMessage(7, value:options)
      }
      for oneElementOneofDecl in oneofDecl {
          try output.writeMessage(8, value:oneElementOneofDecl)
      }
      for oneElementReservedRange in reservedRange {
          try output.writeMessage(9, value:oneElementReservedRange)
      }
      if !reservedName.isEmpty {
        for oneValuereservedName in reservedName {
          try output.writeString(10, value:oneValuereservedName)
        }
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      for oneElementField in field {
          serialize_size += oneElementField.computeMessageSize(2)
      }
      for oneElementNestedType in nestedType {
          serialize_size += oneElementNestedType.computeMessageSize(3)
      }
      for oneElementEnumType in enumType {
          serialize_size += oneElementEnumType.computeMessageSize(4)
      }
      for oneElementExtensionRange in extensionRange {
          serialize_size += oneElementExtensionRange.computeMessageSize(5)
      }
      for oneElementExtension in extension_ {
          serialize_size += oneElementExtension.computeMessageSize(6)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(7) {
              serialize_size += varSizeoptions
          }
      }
      for oneElementOneofDecl in oneofDecl {
          serialize_size += oneElementOneofDecl.computeMessageSize(8)
      }
      for oneElementReservedRange in reservedRange {
          serialize_size += oneElementReservedRange.computeMessageSize(9)
      }
      var dataSizeReservedName:Int32 = 0
      for oneValuereservedName in reservedName {
          dataSizeReservedName += oneValuereservedName.computeStringSizeNoTag()
      }
      serialize_size += dataSizeReservedName
      serialize_size += 1 * Int32(reservedName.count)
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.DescriptorProto> {
      var mergedArray = Array<Google.Protobuf.DescriptorProto>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.DescriptorProto? {
      return try Google.Protobuf.DescriptorProto.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.DescriptorProto.Builder {
      return Google.Protobuf.DescriptorProto.classBuilder() as! Google.Protobuf.DescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.DescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.DescriptorProto.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.DescriptorProto.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.DescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.DescriptorProto.Builder {
      return try Google.Protobuf.DescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.DescriptorProto) throws -> Google.Protobuf.DescriptorProto.Builder {
      return try Google.Protobuf.DescriptorProto.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasName {
        jsonMap["name"] = name
      }
      if !field.isEmpty {
        var jsonArrayField:Array<Dictionary<String,AnyObject>> = []
          for oneValueField in field {
            let ecodedMessageField = try oneValueField.encode()
            jsonArrayField += [ecodedMessageField]
          }
        jsonMap["field"] = jsonArrayField
      }
      if !extension_.isEmpty {
        var jsonArrayExtension:Array<Dictionary<String,AnyObject>> = []
          for oneValueExtension in extension_ {
            let ecodedMessageExtension = try oneValueExtension.encode()
            jsonArrayExtension += [ecodedMessageExtension]
          }
        jsonMap["extension"] = jsonArrayExtension
      }
      if !nestedType.isEmpty {
        var jsonArrayNestedType:Array<Dictionary<String,AnyObject>> = []
          for oneValueNestedType in nestedType {
            let ecodedMessageNestedType = try oneValueNestedType.encode()
            jsonArrayNestedType += [ecodedMessageNestedType]
          }
        jsonMap["nestedType"] = jsonArrayNestedType
      }
      if !enumType.isEmpty {
        var jsonArrayEnumType:Array<Dictionary<String,AnyObject>> = []
          for oneValueEnumType in enumType {
            let ecodedMessageEnumType = try oneValueEnumType.encode()
            jsonArrayEnumType += [ecodedMessageEnumType]
          }
        jsonMap["enumType"] = jsonArrayEnumType
      }
      if !extensionRange.isEmpty {
        var jsonArrayExtensionRange:Array<Dictionary<String,AnyObject>> = []
          for oneValueExtensionRange in extensionRange {
            let ecodedMessageExtensionRange = try oneValueExtensionRange.encode()
            jsonArrayExtensionRange += [ecodedMessageExtensionRange]
          }
        jsonMap["extensionRange"] = jsonArrayExtensionRange
      }
      if !oneofDecl.isEmpty {
        var jsonArrayOneofDecl:Array<Dictionary<String,AnyObject>> = []
          for oneValueOneofDecl in oneofDecl {
            let ecodedMessageOneofDecl = try oneValueOneofDecl.encode()
            jsonArrayOneofDecl += [ecodedMessageOneofDecl]
          }
        jsonMap["oneofDecl"] = jsonArrayOneofDecl
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      if !reservedRange.isEmpty {
        var jsonArrayReservedRange:Array<Dictionary<String,AnyObject>> = []
          for oneValueReservedRange in reservedRange {
            let ecodedMessageReservedRange = try oneValueReservedRange.encode()
            jsonArrayReservedRange += [ecodedMessageReservedRange]
          }
        jsonMap["reservedRange"] = jsonArrayReservedRange
      }
      if !reservedName.isEmpty {
        jsonMap["reservedName"] = reservedName
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.DescriptorProto {
      return try Google.Protobuf.DescriptorProto.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var fieldElementIndex:Int = 0
      for oneElementField in field {
          output += "\(indent) field[\(fieldElementIndex)] {\n"
          output += try oneElementField.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          fieldElementIndex += 1
      }
      var nestedTypeElementIndex:Int = 0
      for oneElementNestedType in nestedType {
          output += "\(indent) nestedType[\(nestedTypeElementIndex)] {\n"
          output += try oneElementNestedType.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          nestedTypeElementIndex += 1
      }
      var enumTypeElementIndex:Int = 0
      for oneElementEnumType in enumType {
          output += "\(indent) enumType[\(enumTypeElementIndex)] {\n"
          output += try oneElementEnumType.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          enumTypeElementIndex += 1
      }
      var extensionRangeElementIndex:Int = 0
      for oneElementExtensionRange in extensionRange {
          output += "\(indent) extensionRange[\(extensionRangeElementIndex)] {\n"
          output += try oneElementExtensionRange.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          extensionRangeElementIndex += 1
      }
      var extension_ElementIndex:Int = 0
      for oneElementExtension in extension_ {
          output += "\(indent) extension_[\(extension_ElementIndex)] {\n"
          output += try oneElementExtension.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          extension_ElementIndex += 1
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var oneofDeclElementIndex:Int = 0
      for oneElementOneofDecl in oneofDecl {
          output += "\(indent) oneofDecl[\(oneofDeclElementIndex)] {\n"
          output += try oneElementOneofDecl.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          oneofDeclElementIndex += 1
      }
      var reservedRangeElementIndex:Int = 0
      for oneElementReservedRange in reservedRange {
          output += "\(indent) reservedRange[\(reservedRangeElementIndex)] {\n"
          output += try oneElementReservedRange.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          reservedRangeElementIndex += 1
      }
      var reservedNameElementIndex:Int = 0
      for oneValueReservedName in reservedName  {
          output += "\(indent) reservedName[\(reservedNameElementIndex)]: \(oneValueReservedName)\n"
          reservedNameElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneElementField in field {
                hashCode = (hashCode &* 31) &+ oneElementField.hashValue
            }
            for oneElementNestedType in nestedType {
                hashCode = (hashCode &* 31) &+ oneElementNestedType.hashValue
            }
            for oneElementEnumType in enumType {
                hashCode = (hashCode &* 31) &+ oneElementEnumType.hashValue
            }
            for oneElementExtensionRange in extensionRange {
                hashCode = (hashCode &* 31) &+ oneElementExtensionRange.hashValue
            }
            for oneElementExtension in extension_ {
                hashCode = (hashCode &* 31) &+ oneElementExtension.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            for oneElementOneofDecl in oneofDecl {
                hashCode = (hashCode &* 31) &+ oneElementOneofDecl.hashValue
            }
            for oneElementReservedRange in reservedRange {
                hashCode = (hashCode &* 31) &+ oneElementReservedRange.hashValue
            }
            for oneValueReservedName in reservedName {
                hashCode = (hashCode &* 31) &+ oneValueReservedName.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.DescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.DescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.DescriptorProto.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.DescriptorProto = Google.Protobuf.DescriptorProto()
      public func getMessage() -> Google.Protobuf.DescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(_ value:String) -> Google.Protobuf.DescriptorProto.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Google.Protobuf.DescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var field:Array<Google.Protobuf.FieldDescriptorProto> {
           get {
               return builderResult.field
           }
           set (value) {
               builderResult.field = value
           }
      }
      public func setField(_ value:Array<Google.Protobuf.FieldDescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.field = value
        return self
      }
      public func clearField() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.field.removeAll(keepingCapacity: false)
        return self
      }
      public var extension_:Array<Google.Protobuf.FieldDescriptorProto> {
           get {
               return builderResult.extension_
           }
           set (value) {
               builderResult.extension_ = value
           }
      }
      public func setExtension(_ value:Array<Google.Protobuf.FieldDescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.extension_ = value
        return self
      }
      public func clearExtension() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.extension_.removeAll(keepingCapacity: false)
        return self
      }
      public var nestedType:Array<Google.Protobuf.DescriptorProto> {
           get {
               return builderResult.nestedType
           }
           set (value) {
               builderResult.nestedType = value
           }
      }
      public func setNestedType(_ value:Array<Google.Protobuf.DescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.nestedType = value
        return self
      }
      public func clearNestedType() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.nestedType.removeAll(keepingCapacity: false)
        return self
      }
      public var enumType:Array<Google.Protobuf.EnumDescriptorProto> {
           get {
               return builderResult.enumType
           }
           set (value) {
               builderResult.enumType = value
           }
      }
      public func setEnumType(_ value:Array<Google.Protobuf.EnumDescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.enumType = value
        return self
      }
      public func clearEnumType() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.enumType.removeAll(keepingCapacity: false)
        return self
      }
      public var extensionRange:Array<Google.Protobuf.DescriptorProto.ExtensionRange> {
           get {
               return builderResult.extensionRange
           }
           set (value) {
               builderResult.extensionRange = value
           }
      }
      public func setExtensionRange(_ value:Array<Google.Protobuf.DescriptorProto.ExtensionRange>) -> Google.Protobuf.DescriptorProto.Builder {
        self.extensionRange = value
        return self
      }
      public func clearExtensionRange() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.extensionRange.removeAll(keepingCapacity: false)
        return self
      }
      public var oneofDecl:Array<Google.Protobuf.OneofDescriptorProto> {
           get {
               return builderResult.oneofDecl
           }
           set (value) {
               builderResult.oneofDecl = value
           }
      }
      public func setOneofDecl(_ value:Array<Google.Protobuf.OneofDescriptorProto>) -> Google.Protobuf.DescriptorProto.Builder {
        self.oneofDecl = value
        return self
      }
      public func clearOneofDecl() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.oneofDecl.removeAll(keepingCapacity: false)
        return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.MessageOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      private var optionsBuilder_:Google.Protobuf.MessageOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.MessageOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.MessageOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(options)
           }
        }
        return optionsBuilder_
      }
      public func setOptions(_ value:Google.Protobuf.MessageOptions!) -> Google.Protobuf.DescriptorProto.Builder {
        self.options = value
        return self
      }
      public func mergeOptions(_ value:Google.Protobuf.MessageOptions) throws -> Google.Protobuf.DescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.MessageOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      public func clearOptions() -> Google.Protobuf.DescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      public var reservedRange:Array<Google.Protobuf.DescriptorProto.ReservedRange> {
           get {
               return builderResult.reservedRange
           }
           set (value) {
               builderResult.reservedRange = value
           }
      }
      public func setReservedRange(_ value:Array<Google.Protobuf.DescriptorProto.ReservedRange>) -> Google.Protobuf.DescriptorProto.Builder {
        self.reservedRange = value
        return self
      }
      public func clearReservedRange() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult.reservedRange.removeAll(keepingCapacity: false)
        return self
      }
      public var reservedName:Array<String> {
           get {
               return builderResult.reservedName
           }
           set (array) {
               builderResult.reservedName = array
           }
      }
      public func setReservedName(_ value:Array<String>) -> Google.Protobuf.DescriptorProto.Builder {
        self.reservedName = value
        return self
      }
      public func clearReservedName() -> Google.Protobuf.DescriptorProto.Builder {
         builderResult.reservedName.removeAll(keepingCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.DescriptorProto.Builder {
        builderResult = Google.Protobuf.DescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.DescriptorProto.Builder {
        return try Google.Protobuf.DescriptorProto.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.DescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.DescriptorProto {
        let returnMe:Google.Protobuf.DescriptorProto = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.DescriptorProto) throws -> Google.Protobuf.DescriptorProto.Builder {
        if other == Google.Protobuf.DescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if !other.field.isEmpty  {
           builderResult.field += other.field
        }
        if !other.extension_.isEmpty  {
           builderResult.extension_ += other.extension_
        }
        if !other.nestedType.isEmpty  {
           builderResult.nestedType += other.nestedType
        }
        if !other.enumType.isEmpty  {
           builderResult.enumType += other.enumType
        }
        if !other.extensionRange.isEmpty  {
           builderResult.extensionRange += other.extensionRange
        }
        if !other.oneofDecl.isEmpty  {
           builderResult.oneofDecl += other.oneofDecl
        }
        if (other.hasOptions) {
            try mergeOptions(other.options)
        }
        if !other.reservedRange.isEmpty  {
           builderResult.reservedRange += other.reservedRange
        }
        if !other.reservedName.isEmpty {
            builderResult.reservedName += other.reservedName
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.DescriptorProto.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.DescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try input.readString()

          case 18:
            let subBuilder = Google.Protobuf.FieldDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            field += [subBuilder.buildPartial()]

          case 26:
            let subBuilder = Google.Protobuf.DescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            nestedType += [subBuilder.buildPartial()]

          case 34:
            let subBuilder = Google.Protobuf.EnumDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            enumType += [subBuilder.buildPartial()]

          case 42:
            let subBuilder = Google.Protobuf.DescriptorProto.ExtensionRange.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            extensionRange += [subBuilder.buildPartial()]

          case 50:
            let subBuilder = Google.Protobuf.FieldDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            extension_ += [subBuilder.buildPartial()]

          case 58:
            let subBuilder:Google.Protobuf.MessageOptions.Builder = Google.Protobuf.MessageOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(options)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          case 66:
            let subBuilder = Google.Protobuf.OneofDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            oneofDecl += [subBuilder.buildPartial()]

          case 74:
            let subBuilder = Google.Protobuf.DescriptorProto.ReservedRange.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            reservedRange += [subBuilder.buildPartial()]

          case 82:
            reservedName += [try input.readString()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.DescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.DescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueField = jsonMap["field"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayField:Array<Google.Protobuf.FieldDescriptorProto> = []
          for oneValueField in jsonValueField {
            let messageFromStringField = try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(oneValueField).build()

            jsonArrayField += [messageFromStringField]
          }
          resultDecodedBuilder.field = jsonArrayField
        }
        if let jsonValueExtension = jsonMap["extension"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayExtension:Array<Google.Protobuf.FieldDescriptorProto> = []
          for oneValueExtension in jsonValueExtension {
            let messageFromStringExtension = try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(oneValueExtension).build()

            jsonArrayExtension += [messageFromStringExtension]
          }
          resultDecodedBuilder.extension_ = jsonArrayExtension
        }
        if let jsonValueNestedType = jsonMap["nestedType"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayNestedType:Array<Google.Protobuf.DescriptorProto> = []
          for oneValueNestedType in jsonValueNestedType {
            let messageFromStringNestedType = try Google.Protobuf.DescriptorProto.Builder.decodeToBuilder(oneValueNestedType).build()

            jsonArrayNestedType += [messageFromStringNestedType]
          }
          resultDecodedBuilder.nestedType = jsonArrayNestedType
        }
        if let jsonValueEnumType = jsonMap["enumType"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayEnumType:Array<Google.Protobuf.EnumDescriptorProto> = []
          for oneValueEnumType in jsonValueEnumType {
            let messageFromStringEnumType = try Google.Protobuf.EnumDescriptorProto.Builder.decodeToBuilder(oneValueEnumType).build()

            jsonArrayEnumType += [messageFromStringEnumType]
          }
          resultDecodedBuilder.enumType = jsonArrayEnumType
        }
        if let jsonValueExtensionRange = jsonMap["extensionRange"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayExtensionRange:Array<Google.Protobuf.DescriptorProto.ExtensionRange> = []
          for oneValueExtensionRange in jsonValueExtensionRange {
            let messageFromStringExtensionRange = try Google.Protobuf.DescriptorProto.ExtensionRange.Builder.decodeToBuilder(oneValueExtensionRange).build()

            jsonArrayExtensionRange += [messageFromStringExtensionRange]
          }
          resultDecodedBuilder.extensionRange = jsonArrayExtensionRange
        }
        if let jsonValueOneofDecl = jsonMap["oneofDecl"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayOneofDecl:Array<Google.Protobuf.OneofDescriptorProto> = []
          for oneValueOneofDecl in jsonValueOneofDecl {
            let messageFromStringOneofDecl = try Google.Protobuf.OneofDescriptorProto.Builder.decodeToBuilder(oneValueOneofDecl).build()

            jsonArrayOneofDecl += [messageFromStringOneofDecl]
          }
          resultDecodedBuilder.oneofDecl = jsonArrayOneofDecl
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.options = try Google.Protobuf.MessageOptions.Builder.decodeToBuilder(jsonValueOptions).build()

        }
        if let jsonValueReservedRange = jsonMap["reservedRange"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayReservedRange:Array<Google.Protobuf.DescriptorProto.ReservedRange> = []
          for oneValueReservedRange in jsonValueReservedRange {
            let messageFromStringReservedRange = try Google.Protobuf.DescriptorProto.ReservedRange.Builder.decodeToBuilder(oneValueReservedRange).build()

            jsonArrayReservedRange += [messageFromStringReservedRange]
          }
          resultDecodedBuilder.reservedRange = jsonArrayReservedRange
        }
        if let jsonValueReservedName = jsonMap["reservedName"] as? Array<String> {
          resultDecodedBuilder.reservedName = jsonValueReservedName
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.DescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.DescriptorProto.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Describes a field within a message.
  final public class FieldDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Types:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // 0 is reserved for errors.
        // Order is weird for historical reasons.
        case typeDouble = 1
        case typeFloat = 2

        // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
        // negative values are likely.
        case typeInt64 = 3
        case typeUint64 = 4

        // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
        // negative values are likely.
        case typeInt32 = 5
        case typeFixed64 = 6
        case typeFixed32 = 7
        case typeBool = 8
        case typeString = 9

        // Tag-delimited aggregate.
        case typeGroup = 10

        // Length-delimited aggregate.
        case typeMessage = 11

        // New in version 2.
        case typeBytes = 12
        case typeUint32 = 13
        case typeEnum = 14
        case typeSfixed32 = 15
        case typeSfixed64 = 16

        // Uses ZigZag encoding.
        case typeSint32 = 17

        // Uses ZigZag encoding.
        case typeSint64 = 18
        public func toString() -> String {
          switch self {
          case .typeDouble: return "TYPE_DOUBLE"
          case .typeFloat: return "TYPE_FLOAT"
          case .typeInt64: return "TYPE_INT64"
          case .typeUint64: return "TYPE_UINT64"
          case .typeInt32: return "TYPE_INT32"
          case .typeFixed64: return "TYPE_FIXED64"
          case .typeFixed32: return "TYPE_FIXED32"
          case .typeBool: return "TYPE_BOOL"
          case .typeString: return "TYPE_STRING"
          case .typeGroup: return "TYPE_GROUP"
          case .typeMessage: return "TYPE_MESSAGE"
          case .typeBytes: return "TYPE_BYTES"
          case .typeUint32: return "TYPE_UINT32"
          case .typeEnum: return "TYPE_ENUM"
          case .typeSfixed32: return "TYPE_SFIXED32"
          case .typeSfixed64: return "TYPE_SFIXED64"
          case .typeSint32: return "TYPE_SINT32"
          case .typeSint64: return "TYPE_SINT64"
          }
        }
        public static func fromString(_ str:String) throws -> Google.Protobuf.FieldDescriptorProto.Types {
          switch str {
          case "TYPE_DOUBLE":  return .typeDouble
          case "TYPE_FLOAT":  return .typeFloat
          case "TYPE_INT64":  return .typeInt64
          case "TYPE_UINT64":  return .typeUint64
          case "TYPE_INT32":  return .typeInt32
          case "TYPE_FIXED64":  return .typeFixed64
          case "TYPE_FIXED32":  return .typeFixed32
          case "TYPE_BOOL":  return .typeBool
          case "TYPE_STRING":  return .typeString
          case "TYPE_GROUP":  return .typeGroup
          case "TYPE_MESSAGE":  return .typeMessage
          case "TYPE_BYTES":  return .typeBytes
          case "TYPE_UINT32":  return .typeUint32
          case "TYPE_ENUM":  return .typeEnum
          case "TYPE_SFIXED32":  return .typeSfixed32
          case "TYPE_SFIXED64":  return .typeSfixed64
          case "TYPE_SINT32":  return .typeSint32
          case "TYPE_SINT64":  return .typeSint64
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .typeDouble: return ".TypeDouble"
                case .typeFloat: return ".TypeFloat"
                case .typeInt64: return ".TypeInt64"
                case .typeUint64: return ".TypeUint64"
                case .typeInt32: return ".TypeInt32"
                case .typeFixed64: return ".TypeFixed64"
                case .typeFixed32: return ".TypeFixed32"
                case .typeBool: return ".TypeBool"
                case .typeString: return ".TypeString"
                case .typeGroup: return ".TypeGroup"
                case .typeMessage: return ".TypeMessage"
                case .typeBytes: return ".TypeBytes"
                case .typeUint32: return ".TypeUint32"
                case .typeEnum: return ".TypeEnum"
                case .typeSfixed32: return ".TypeSfixed32"
                case .typeSfixed64: return ".TypeSfixed64"
                case .typeSint32: return ".TypeSint32"
                case .typeSint64: return ".TypeSint64"
            }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      public enum Label:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // 0 is reserved for errors
        case labelOptional = 1
        case labelRequired = 2

        // TODO(sanjay): Should we add LABEL_MAP?
        case labelRepeated = 3
        public func toString() -> String {
          switch self {
          case .labelOptional: return "LABEL_OPTIONAL"
          case .labelRequired: return "LABEL_REQUIRED"
          case .labelRepeated: return "LABEL_REPEATED"
          }
        }
        public static func fromString(_ str:String) throws -> Google.Protobuf.FieldDescriptorProto.Label {
          switch str {
          case "LABEL_OPTIONAL":  return .labelOptional
          case "LABEL_REQUIRED":  return .labelRequired
          case "LABEL_REPEATED":  return .labelRepeated
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .labelOptional: return ".LabelOptional"
                case .labelRequired: return ".LabelRequired"
                case .labelRepeated: return ".LabelRepeated"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasNumber:Bool = false
    public private(set) var number:Int32 = Int32(0)

    public private(set) var label:Label = Google.Protobuf.FieldDescriptorProto.Label.labelOptional
    public private(set) var hasLabel:Bool = false
    public private(set) var types:Types = Google.Protobuf.FieldDescriptorProto.Types.typeDouble
    public private(set) var hasTypes:Bool = false
    // For message and enum types, this is the name of the type.  If the name
    // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
    // rules are used to find the type (i.e. first the nested types within this
    // message are searched, then within the parent, on up to the root
    // namespace).
    public private(set) var hasTypeName:Bool = false
    public private(set) var typeName:String = ""

    // For extensions, this is the name of the type being extended.  It is
    // resolved in the same manner as type_name.
    public private(set) var hasExtendee:Bool = false
    public private(set) var extendee:String = ""

    // For numeric types, contains the original text representation of the value.
    // For booleans, "true" or "false".
    // For strings, contains the default text contents (not escaped in any way).
    // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
    // TODO(kenton):  Base-64 encode?
    public private(set) var hasDefaultValue:Bool = false
    public private(set) var defaultValue:String = ""

    // If set, gives the index of a oneof in the containing type's oneof_decl
    // list.  This field is a member of that oneof.
    public private(set) var hasOneofIndex:Bool = false
    public private(set) var oneofIndex:Int32 = Int32(0)

    public private(set) var hasOptions:Bool = false
    public private(set) var options:Google.Protobuf.FieldOptions!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasName {
        try output.writeString(1, value:name)
      }
      if hasExtendee {
        try output.writeString(2, value:extendee)
      }
      if hasNumber {
        try output.writeInt32(3, value:number)
      }
      if hasLabel {
        try output.writeEnum(4, value:label.rawValue)
      }
      if hasTypes {
        try output.writeEnum(5, value:types.rawValue)
      }
      if hasTypeName {
        try output.writeString(6, value:typeName)
      }
      if hasDefaultValue {
        try output.writeString(7, value:defaultValue)
      }
      if hasOptions {
        try output.writeMessage(8, value:options)
      }
      if hasOneofIndex {
        try output.writeInt32(9, value:oneofIndex)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      if hasExtendee {
        serialize_size += extendee.computeStringSize(2)
      }
      if hasNumber {
        serialize_size += number.computeInt32Size(3)
      }
      if (hasLabel) {
        serialize_size += label.rawValue.computeEnumSize(4)
      }
      if (hasTypes) {
        serialize_size += types.rawValue.computeEnumSize(5)
      }
      if hasTypeName {
        serialize_size += typeName.computeStringSize(6)
      }
      if hasDefaultValue {
        serialize_size += defaultValue.computeStringSize(7)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(8) {
              serialize_size += varSizeoptions
          }
      }
      if hasOneofIndex {
        serialize_size += oneofIndex.computeInt32Size(9)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.FieldDescriptorProto> {
      var mergedArray = Array<Google.Protobuf.FieldDescriptorProto>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FieldDescriptorProto? {
      return try Google.Protobuf.FieldDescriptorProto.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.FieldDescriptorProto.Builder {
      return Google.Protobuf.FieldDescriptorProto.classBuilder() as! Google.Protobuf.FieldDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.FieldDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.FieldDescriptorProto.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FieldDescriptorProto.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FieldDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FieldDescriptorProto.Builder {
      return try Google.Protobuf.FieldDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.FieldDescriptorProto) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
      return try Google.Protobuf.FieldDescriptorProto.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasName {
        jsonMap["name"] = name
      }
      if hasNumber {
        jsonMap["number"] = NSNumber(value:number)
      }
      if hasLabel {
        jsonMap["label"] = label.toString()
      }
      if hasTypes {
        jsonMap["type"] = types.toString()
      }
      if hasTypeName {
        jsonMap["typeName"] = typeName
      }
      if hasExtendee {
        jsonMap["extendee"] = extendee
      }
      if hasDefaultValue {
        jsonMap["defaultValue"] = defaultValue
      }
      if hasOneofIndex {
        jsonMap["oneofIndex"] = NSNumber(value:oneofIndex)
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.FieldDescriptorProto {
      return try Google.Protobuf.FieldDescriptorProto.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasExtendee {
        output += "\(indent) extendee: \(extendee) \n"
      }
      if hasNumber {
        output += "\(indent) number: \(number) \n"
      }
      if (hasLabel) {
        output += "\(indent) label: \(label.description)\n"
      }
      if (hasTypes) {
        output += "\(indent) types: \(types.description)\n"
      }
      if hasTypeName {
        output += "\(indent) typeName: \(typeName) \n"
      }
      if hasDefaultValue {
        output += "\(indent) defaultValue: \(defaultValue) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasOneofIndex {
        output += "\(indent) oneofIndex: \(oneofIndex) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasExtendee {
               hashCode = (hashCode &* 31) &+ extendee.hashValue
            }
            if hasNumber {
               hashCode = (hashCode &* 31) &+ number.hashValue
            }
            if hasLabel {
               hashCode = (hashCode &* 31) &+ Int(label.rawValue)
            }
            if hasTypes {
               hashCode = (hashCode &* 31) &+ Int(types.rawValue)
            }
            if hasTypeName {
               hashCode = (hashCode &* 31) &+ typeName.hashValue
            }
            if hasDefaultValue {
               hashCode = (hashCode &* 31) &+ defaultValue.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            if hasOneofIndex {
               hashCode = (hashCode &* 31) &+ oneofIndex.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FieldDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.FieldDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.FieldDescriptorProto.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.FieldDescriptorProto = Google.Protobuf.FieldDescriptorProto()
      public func getMessage() -> Google.Protobuf.FieldDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(_ value:String) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var hasNumber:Bool {
           get {
                return builderResult.hasNumber
           }
      }
      public var number:Int32 {
           get {
                return builderResult.number
           }
           set (value) {
               builderResult.hasNumber = true
               builderResult.number = value
           }
      }
      public func setNumber(_ value:Int32) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.number = value
        return self
      }
      public func clearNumber() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasNumber = false
           builderResult.number = Int32(0)
           return self
      }
        public var hasLabel:Bool{
            get {
                return builderResult.hasLabel
            }
        }
        public var label:Google.Protobuf.FieldDescriptorProto.Label {
            get {
                return builderResult.label
            }
            set (value) {
                builderResult.hasLabel = true
                builderResult.label = value
            }
        }
        public func setLabel(_ value:Google.Protobuf.FieldDescriptorProto.Label) -> Google.Protobuf.FieldDescriptorProto.Builder {
          self.label = value
          return self
        }
        public func clearLabel() -> Google.Protobuf.FieldDescriptorProto.Builder {
           builderResult.hasLabel = false
           builderResult.label = .labelOptional
           return self
        }
        public var hasTypes:Bool{
            get {
                return builderResult.hasTypes
            }
        }
        public var types:Google.Protobuf.FieldDescriptorProto.Types {
            get {
                return builderResult.types
            }
            set (value) {
                builderResult.hasTypes = true
                builderResult.types = value
            }
        }
        public func setTypes(_ value:Google.Protobuf.FieldDescriptorProto.Types) -> Google.Protobuf.FieldDescriptorProto.Builder {
          self.types = value
          return self
        }
        public func clearTypes() -> Google.Protobuf.FieldDescriptorProto.Builder {
           builderResult.hasTypes = false
           builderResult.types = .typeDouble
           return self
        }
      public var hasTypeName:Bool {
           get {
                return builderResult.hasTypeName
           }
      }
      public var typeName:String {
           get {
                return builderResult.typeName
           }
           set (value) {
               builderResult.hasTypeName = true
               builderResult.typeName = value
           }
      }
      public func setTypeName(_ value:String) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.typeName = value
        return self
      }
      public func clearTypeName() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasTypeName = false
           builderResult.typeName = ""
           return self
      }
      public var hasExtendee:Bool {
           get {
                return builderResult.hasExtendee
           }
      }
      public var extendee:String {
           get {
                return builderResult.extendee
           }
           set (value) {
               builderResult.hasExtendee = true
               builderResult.extendee = value
           }
      }
      public func setExtendee(_ value:String) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.extendee = value
        return self
      }
      public func clearExtendee() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasExtendee = false
           builderResult.extendee = ""
           return self
      }
      public var hasDefaultValue:Bool {
           get {
                return builderResult.hasDefaultValue
           }
      }
      public var defaultValue:String {
           get {
                return builderResult.defaultValue
           }
           set (value) {
               builderResult.hasDefaultValue = true
               builderResult.defaultValue = value
           }
      }
      public func setDefaultValue(_ value:String) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.defaultValue = value
        return self
      }
      public func clearDefaultValue() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasDefaultValue = false
           builderResult.defaultValue = ""
           return self
      }
      public var hasOneofIndex:Bool {
           get {
                return builderResult.hasOneofIndex
           }
      }
      public var oneofIndex:Int32 {
           get {
                return builderResult.oneofIndex
           }
           set (value) {
               builderResult.hasOneofIndex = true
               builderResult.oneofIndex = value
           }
      }
      public func setOneofIndex(_ value:Int32) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.oneofIndex = value
        return self
      }
      public func clearOneofIndex() -> Google.Protobuf.FieldDescriptorProto.Builder{
           builderResult.hasOneofIndex = false
           builderResult.oneofIndex = Int32(0)
           return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.FieldOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      private var optionsBuilder_:Google.Protobuf.FieldOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.FieldOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.FieldOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(options)
           }
        }
        return optionsBuilder_
      }
      public func setOptions(_ value:Google.Protobuf.FieldOptions!) -> Google.Protobuf.FieldDescriptorProto.Builder {
        self.options = value
        return self
      }
      public func mergeOptions(_ value:Google.Protobuf.FieldOptions) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.FieldOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      public func clearOptions() -> Google.Protobuf.FieldDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.FieldDescriptorProto.Builder {
        builderResult = Google.Protobuf.FieldDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        return try Google.Protobuf.FieldDescriptorProto.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.FieldDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FieldDescriptorProto {
        let returnMe:Google.Protobuf.FieldDescriptorProto = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.FieldDescriptorProto) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        if other == Google.Protobuf.FieldDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if other.hasNumber {
             number = other.number
        }
        if other.hasLabel {
             label = other.label
        }
        if other.hasTypes {
             types = other.types
        }
        if other.hasTypeName {
             typeName = other.typeName
        }
        if other.hasExtendee {
             extendee = other.extendee
        }
        if other.hasDefaultValue {
             defaultValue = other.defaultValue
        }
        if other.hasOneofIndex {
             oneofIndex = other.oneofIndex
        }
        if (other.hasOptions) {
            try mergeOptions(other.options)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try input.readString()

          case 18:
            extendee = try input.readString()

          case 24:
            number = try input.readInt32()

          case 32:
            let valueIntlabel = try input.readEnum()
            if let enumslabel = Google.Protobuf.FieldDescriptorProto.Label(rawValue:valueIntlabel){
                 label = enumslabel
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntlabel))
            }

          case 40:
            let valueInttypes = try input.readEnum()
            if let enumstypes = Google.Protobuf.FieldDescriptorProto.Types(rawValue:valueInttypes){
                 types = enumstypes
            } else {
                 try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueInttypes))
            }

          case 50:
            typeName = try input.readString()

          case 58:
            defaultValue = try input.readString()

          case 66:
            let subBuilder:Google.Protobuf.FieldOptions.Builder = Google.Protobuf.FieldOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(options)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          case 72:
            oneofIndex = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.FieldDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueNumber = jsonMap["number"] as? NSNumber {
          resultDecodedBuilder.number = jsonValueNumber.int32Value
        }
        if let jsonValueLabel = jsonMap["label"] as? String {
          resultDecodedBuilder.label = try Google.Protobuf.FieldDescriptorProto.Label.fromString(jsonValueLabel)
        }
        if let jsonValueTypes = jsonMap["type"] as? String {
          resultDecodedBuilder.types = try Google.Protobuf.FieldDescriptorProto.Types.fromString(jsonValueTypes)
        }
        if let jsonValueTypeName = jsonMap["typeName"] as? String {
          resultDecodedBuilder.typeName = jsonValueTypeName
        }
        if let jsonValueExtendee = jsonMap["extendee"] as? String {
          resultDecodedBuilder.extendee = jsonValueExtendee
        }
        if let jsonValueDefaultValue = jsonMap["defaultValue"] as? String {
          resultDecodedBuilder.defaultValue = jsonValueDefaultValue
        }
        if let jsonValueOneofIndex = jsonMap["oneofIndex"] as? NSNumber {
          resultDecodedBuilder.oneofIndex = jsonValueOneofIndex.int32Value
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.options = try Google.Protobuf.FieldOptions.Builder.decodeToBuilder(jsonValueOptions).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.FieldDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FieldDescriptorProto.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Describes a oneof.
  final public class OneofDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasName {
        try output.writeString(1, value:name)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.OneofDescriptorProto> {
      var mergedArray = Array<Google.Protobuf.OneofDescriptorProto>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.OneofDescriptorProto? {
      return try Google.Protobuf.OneofDescriptorProto.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.OneofDescriptorProto.Builder {
      return Google.Protobuf.OneofDescriptorProto.classBuilder() as! Google.Protobuf.OneofDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.OneofDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.OneofDescriptorProto.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.OneofDescriptorProto.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.OneofDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.OneofDescriptorProto.Builder {
      return try Google.Protobuf.OneofDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.OneofDescriptorProto) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
      return try Google.Protobuf.OneofDescriptorProto.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasName {
        jsonMap["name"] = name
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.OneofDescriptorProto {
      return try Google.Protobuf.OneofDescriptorProto.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.OneofDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.OneofDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.OneofDescriptorProto.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.OneofDescriptorProto = Google.Protobuf.OneofDescriptorProto()
      public func getMessage() -> Google.Protobuf.OneofDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(_ value:String) -> Google.Protobuf.OneofDescriptorProto.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Google.Protobuf.OneofDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.OneofDescriptorProto.Builder {
        builderResult = Google.Protobuf.OneofDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        return try Google.Protobuf.OneofDescriptorProto.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.OneofDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.OneofDescriptorProto {
        let returnMe:Google.Protobuf.OneofDescriptorProto = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.OneofDescriptorProto) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        if other == Google.Protobuf.OneofDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.OneofDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.OneofDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.OneofDescriptorProto.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Describes an enum type.
  final public class EnumDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var value:Array<Google.Protobuf.EnumValueDescriptorProto>  = Array<Google.Protobuf.EnumValueDescriptorProto>()
    public private(set) var hasOptions:Bool = false
    public private(set) var options:Google.Protobuf.EnumOptions!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitValue:Bool = true
      for oneElementValue in value {
        if !oneElementValue.isInitialized() {
          isInitValue = false
          break 
        }
      }
      if !isInitValue {
        return isInitValue
      }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasName {
        try output.writeString(1, value:name)
      }
      for oneElementValue in value {
          try output.writeMessage(2, value:oneElementValue)
      }
      if hasOptions {
        try output.writeMessage(3, value:options)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      for oneElementValue in value {
          serialize_size += oneElementValue.computeMessageSize(2)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(3) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.EnumDescriptorProto> {
      var mergedArray = Array<Google.Protobuf.EnumDescriptorProto>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.EnumDescriptorProto? {
      return try Google.Protobuf.EnumDescriptorProto.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.EnumDescriptorProto.Builder {
      return Google.Protobuf.EnumDescriptorProto.classBuilder() as! Google.Protobuf.EnumDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.EnumDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.EnumDescriptorProto.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.EnumDescriptorProto.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.EnumDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.EnumDescriptorProto.Builder {
      return try Google.Protobuf.EnumDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.EnumDescriptorProto) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
      return try Google.Protobuf.EnumDescriptorProto.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasName {
        jsonMap["name"] = name
      }
      if !value.isEmpty {
        var jsonArrayValue:Array<Dictionary<String,AnyObject>> = []
          for oneValueValue in value {
            let ecodedMessageValue = try oneValueValue.encode()
            jsonArrayValue += [ecodedMessageValue]
          }
        jsonMap["value"] = jsonArrayValue
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.EnumDescriptorProto {
      return try Google.Protobuf.EnumDescriptorProto.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var valueElementIndex:Int = 0
      for oneElementValue in value {
          output += "\(indent) value[\(valueElementIndex)] {\n"
          output += try oneElementValue.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          valueElementIndex += 1
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneElementValue in value {
                hashCode = (hashCode &* 31) &+ oneElementValue.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.EnumDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.EnumDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.EnumDescriptorProto.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.EnumDescriptorProto = Google.Protobuf.EnumDescriptorProto()
      public func getMessage() -> Google.Protobuf.EnumDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(_ value:String) -> Google.Protobuf.EnumDescriptorProto.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Google.Protobuf.EnumDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var value:Array<Google.Protobuf.EnumValueDescriptorProto> {
           get {
               return builderResult.value
           }
           set (value) {
               builderResult.value = value
           }
      }
      public func setValue(_ value:Array<Google.Protobuf.EnumValueDescriptorProto>) -> Google.Protobuf.EnumDescriptorProto.Builder {
        self.value = value
        return self
      }
      public func clearValue() -> Google.Protobuf.EnumDescriptorProto.Builder {
        builderResult.value.removeAll(keepingCapacity: false)
        return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.EnumOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      private var optionsBuilder_:Google.Protobuf.EnumOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.EnumOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.EnumOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(options)
           }
        }
        return optionsBuilder_
      }
      public func setOptions(_ value:Google.Protobuf.EnumOptions!) -> Google.Protobuf.EnumDescriptorProto.Builder {
        self.options = value
        return self
      }
      public func mergeOptions(_ value:Google.Protobuf.EnumOptions) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.EnumOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      public func clearOptions() -> Google.Protobuf.EnumDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.EnumDescriptorProto.Builder {
        builderResult = Google.Protobuf.EnumDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        return try Google.Protobuf.EnumDescriptorProto.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.EnumDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.EnumDescriptorProto {
        let returnMe:Google.Protobuf.EnumDescriptorProto = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.EnumDescriptorProto) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        if other == Google.Protobuf.EnumDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if !other.value.isEmpty  {
           builderResult.value += other.value
        }
        if (other.hasOptions) {
            try mergeOptions(other.options)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try input.readString()

          case 18:
            let subBuilder = Google.Protobuf.EnumValueDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            value += [subBuilder.buildPartial()]

          case 26:
            let subBuilder:Google.Protobuf.EnumOptions.Builder = Google.Protobuf.EnumOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(options)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.EnumDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueValue = jsonMap["value"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayValue:Array<Google.Protobuf.EnumValueDescriptorProto> = []
          for oneValueValue in jsonValueValue {
            let messageFromStringValue = try Google.Protobuf.EnumValueDescriptorProto.Builder.decodeToBuilder(oneValueValue).build()

            jsonArrayValue += [messageFromStringValue]
          }
          resultDecodedBuilder.value = jsonArrayValue
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.options = try Google.Protobuf.EnumOptions.Builder.decodeToBuilder(jsonValueOptions).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.EnumDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.EnumDescriptorProto.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Describes a value within an enum.
  final public class EnumValueDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasNumber:Bool = false
    public private(set) var number:Int32 = Int32(0)

    public private(set) var hasOptions:Bool = false
    public private(set) var options:Google.Protobuf.EnumValueOptions!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasName {
        try output.writeString(1, value:name)
      }
      if hasNumber {
        try output.writeInt32(2, value:number)
      }
      if hasOptions {
        try output.writeMessage(3, value:options)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      if hasNumber {
        serialize_size += number.computeInt32Size(2)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(3) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.EnumValueDescriptorProto> {
      var mergedArray = Array<Google.Protobuf.EnumValueDescriptorProto>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.EnumValueDescriptorProto? {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.EnumValueDescriptorProto.Builder {
      return Google.Protobuf.EnumValueDescriptorProto.classBuilder() as! Google.Protobuf.EnumValueDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.EnumValueDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.EnumValueDescriptorProto.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.EnumValueDescriptorProto.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.EnumValueDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
      return try Google.Protobuf.EnumValueDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.EnumValueDescriptorProto) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasName {
        jsonMap["name"] = name
      }
      if hasNumber {
        jsonMap["number"] = NSNumber(value:number)
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.EnumValueDescriptorProto {
      return try Google.Protobuf.EnumValueDescriptorProto.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasNumber {
        output += "\(indent) number: \(number) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasNumber {
               hashCode = (hashCode &* 31) &+ number.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.EnumValueDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.EnumValueDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.EnumValueDescriptorProto.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.EnumValueDescriptorProto = Google.Protobuf.EnumValueDescriptorProto()
      public func getMessage() -> Google.Protobuf.EnumValueDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(_ value:String) -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Google.Protobuf.EnumValueDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var hasNumber:Bool {
           get {
                return builderResult.hasNumber
           }
      }
      public var number:Int32 {
           get {
                return builderResult.number
           }
           set (value) {
               builderResult.hasNumber = true
               builderResult.number = value
           }
      }
      public func setNumber(_ value:Int32) -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        self.number = value
        return self
      }
      public func clearNumber() -> Google.Protobuf.EnumValueDescriptorProto.Builder{
           builderResult.hasNumber = false
           builderResult.number = Int32(0)
           return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.EnumValueOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      private var optionsBuilder_:Google.Protobuf.EnumValueOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.EnumValueOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.EnumValueOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(options)
           }
        }
        return optionsBuilder_
      }
      public func setOptions(_ value:Google.Protobuf.EnumValueOptions!) -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        self.options = value
        return self
      }
      public func mergeOptions(_ value:Google.Protobuf.EnumValueOptions) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.EnumValueOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      public func clearOptions() -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        builderResult = Google.Protobuf.EnumValueDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        return try Google.Protobuf.EnumValueDescriptorProto.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.EnumValueDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.EnumValueDescriptorProto {
        let returnMe:Google.Protobuf.EnumValueDescriptorProto = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.EnumValueDescriptorProto) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        if other == Google.Protobuf.EnumValueDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if other.hasNumber {
             number = other.number
        }
        if (other.hasOptions) {
            try mergeOptions(other.options)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try input.readString()

          case 16:
            number = try input.readInt32()

          case 26:
            let subBuilder:Google.Protobuf.EnumValueOptions.Builder = Google.Protobuf.EnumValueOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(options)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.EnumValueDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueNumber = jsonMap["number"] as? NSNumber {
          resultDecodedBuilder.number = jsonValueNumber.int32Value
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.options = try Google.Protobuf.EnumValueOptions.Builder.decodeToBuilder(jsonValueOptions).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.EnumValueDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.EnumValueDescriptorProto.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Describes a service.
  final public class ServiceDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var method:Array<Google.Protobuf.MethodDescriptorProto>  = Array<Google.Protobuf.MethodDescriptorProto>()
    public private(set) var hasOptions:Bool = false
    public private(set) var options:Google.Protobuf.ServiceOptions!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitMethod:Bool = true
      for oneElementMethod in method {
        if !oneElementMethod.isInitialized() {
          isInitMethod = false
          break 
        }
      }
      if !isInitMethod {
        return isInitMethod
      }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasName {
        try output.writeString(1, value:name)
      }
      for oneElementMethod in method {
          try output.writeMessage(2, value:oneElementMethod)
      }
      if hasOptions {
        try output.writeMessage(3, value:options)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      for oneElementMethod in method {
          serialize_size += oneElementMethod.computeMessageSize(2)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(3) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.ServiceDescriptorProto> {
      var mergedArray = Array<Google.Protobuf.ServiceDescriptorProto>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.ServiceDescriptorProto? {
      return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.ServiceDescriptorProto.Builder {
      return Google.Protobuf.ServiceDescriptorProto.classBuilder() as! Google.Protobuf.ServiceDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.ServiceDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.ServiceDescriptorProto.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.ServiceDescriptorProto.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.ServiceDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
      return try Google.Protobuf.ServiceDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.ServiceDescriptorProto) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
      return try Google.Protobuf.ServiceDescriptorProto.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasName {
        jsonMap["name"] = name
      }
      if !method.isEmpty {
        var jsonArrayMethod:Array<Dictionary<String,AnyObject>> = []
          for oneValueMethod in method {
            let ecodedMessageMethod = try oneValueMethod.encode()
            jsonArrayMethod += [ecodedMessageMethod]
          }
        jsonMap["method"] = jsonArrayMethod
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.ServiceDescriptorProto {
      return try Google.Protobuf.ServiceDescriptorProto.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var methodElementIndex:Int = 0
      for oneElementMethod in method {
          output += "\(indent) method[\(methodElementIndex)] {\n"
          output += try oneElementMethod.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          methodElementIndex += 1
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneElementMethod in method {
                hashCode = (hashCode &* 31) &+ oneElementMethod.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.ServiceDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.ServiceDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.ServiceDescriptorProto.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.ServiceDescriptorProto = Google.Protobuf.ServiceDescriptorProto()
      public func getMessage() -> Google.Protobuf.ServiceDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(_ value:String) -> Google.Protobuf.ServiceDescriptorProto.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Google.Protobuf.ServiceDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var method:Array<Google.Protobuf.MethodDescriptorProto> {
           get {
               return builderResult.method
           }
           set (value) {
               builderResult.method = value
           }
      }
      public func setMethod(_ value:Array<Google.Protobuf.MethodDescriptorProto>) -> Google.Protobuf.ServiceDescriptorProto.Builder {
        self.method = value
        return self
      }
      public func clearMethod() -> Google.Protobuf.ServiceDescriptorProto.Builder {
        builderResult.method.removeAll(keepingCapacity: false)
        return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.ServiceOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      private var optionsBuilder_:Google.Protobuf.ServiceOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.ServiceOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.ServiceOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(options)
           }
        }
        return optionsBuilder_
      }
      public func setOptions(_ value:Google.Protobuf.ServiceOptions!) -> Google.Protobuf.ServiceDescriptorProto.Builder {
        self.options = value
        return self
      }
      public func mergeOptions(_ value:Google.Protobuf.ServiceOptions) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.ServiceOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      public func clearOptions() -> Google.Protobuf.ServiceDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.ServiceDescriptorProto.Builder {
        builderResult = Google.Protobuf.ServiceDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        return try Google.Protobuf.ServiceDescriptorProto.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.ServiceDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.ServiceDescriptorProto {
        let returnMe:Google.Protobuf.ServiceDescriptorProto = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.ServiceDescriptorProto) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        if other == Google.Protobuf.ServiceDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if !other.method.isEmpty  {
           builderResult.method += other.method
        }
        if (other.hasOptions) {
            try mergeOptions(other.options)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try input.readString()

          case 18:
            let subBuilder = Google.Protobuf.MethodDescriptorProto.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            method += [subBuilder.buildPartial()]

          case 26:
            let subBuilder:Google.Protobuf.ServiceOptions.Builder = Google.Protobuf.ServiceOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(options)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.ServiceDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueMethod = jsonMap["method"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayMethod:Array<Google.Protobuf.MethodDescriptorProto> = []
          for oneValueMethod in jsonValueMethod {
            let messageFromStringMethod = try Google.Protobuf.MethodDescriptorProto.Builder.decodeToBuilder(oneValueMethod).build()

            jsonArrayMethod += [messageFromStringMethod]
          }
          resultDecodedBuilder.method = jsonArrayMethod
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.options = try Google.Protobuf.ServiceOptions.Builder.decodeToBuilder(jsonValueOptions).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.ServiceDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.ServiceDescriptorProto.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Describes a method of a service.
  final public class MethodDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    // Input and output type names.  These are resolved in the same way as
    // FieldDescriptorProto.type_name, but must refer to a message type.
    public private(set) var hasInputType:Bool = false
    public private(set) var inputType:String = ""

    public private(set) var hasOutputType:Bool = false
    public private(set) var outputType:String = ""

    public private(set) var hasOptions:Bool = false
    public private(set) var options:Google.Protobuf.MethodOptions!
    // Identifies if client streams multiple client messages
    public private(set) var hasClientStreaming:Bool = false
    public private(set) var clientStreaming:Bool = false

    // Identifies if server streams multiple server messages
    public private(set) var hasServerStreaming:Bool = false
    public private(set) var serverStreaming:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasName {
        try output.writeString(1, value:name)
      }
      if hasInputType {
        try output.writeString(2, value:inputType)
      }
      if hasOutputType {
        try output.writeString(3, value:outputType)
      }
      if hasOptions {
        try output.writeMessage(4, value:options)
      }
      if hasClientStreaming {
        try output.writeBool(5, value:clientStreaming)
      }
      if hasServerStreaming {
        try output.writeBool(6, value:serverStreaming)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      if hasInputType {
        serialize_size += inputType.computeStringSize(2)
      }
      if hasOutputType {
        serialize_size += outputType.computeStringSize(3)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(4) {
              serialize_size += varSizeoptions
          }
      }
      if hasClientStreaming {
        serialize_size += clientStreaming.computeBoolSize(5)
      }
      if hasServerStreaming {
        serialize_size += serverStreaming.computeBoolSize(6)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.MethodDescriptorProto> {
      var mergedArray = Array<Google.Protobuf.MethodDescriptorProto>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.MethodDescriptorProto? {
      return try Google.Protobuf.MethodDescriptorProto.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.MethodDescriptorProto.Builder {
      return Google.Protobuf.MethodDescriptorProto.classBuilder() as! Google.Protobuf.MethodDescriptorProto.Builder
    }
    public func getBuilder() -> Google.Protobuf.MethodDescriptorProto.Builder {
      return classBuilder() as! Google.Protobuf.MethodDescriptorProto.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.MethodDescriptorProto.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.MethodDescriptorProto.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.MethodDescriptorProto.Builder {
      return try Google.Protobuf.MethodDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.MethodDescriptorProto) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
      return try Google.Protobuf.MethodDescriptorProto.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasName {
        jsonMap["name"] = name
      }
      if hasInputType {
        jsonMap["inputType"] = inputType
      }
      if hasOutputType {
        jsonMap["outputType"] = outputType
      }
      if hasOptions {
        jsonMap["options"] = try options.encode()
      }
      if hasClientStreaming {
        jsonMap["clientStreaming"] = clientStreaming
      }
      if hasServerStreaming {
        jsonMap["serverStreaming"] = serverStreaming
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.MethodDescriptorProto {
      return try Google.Protobuf.MethodDescriptorProto.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasInputType {
        output += "\(indent) inputType: \(inputType) \n"
      }
      if hasOutputType {
        output += "\(indent) outputType: \(outputType) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        if let outDescOptions = options {
          output += try outDescOptions.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasClientStreaming {
        output += "\(indent) clientStreaming: \(clientStreaming) \n"
      }
      if hasServerStreaming {
        output += "\(indent) serverStreaming: \(serverStreaming) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasInputType {
               hashCode = (hashCode &* 31) &+ inputType.hashValue
            }
            if hasOutputType {
               hashCode = (hashCode &* 31) &+ outputType.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            if hasClientStreaming {
               hashCode = (hashCode &* 31) &+ clientStreaming.hashValue
            }
            if hasServerStreaming {
               hashCode = (hashCode &* 31) &+ serverStreaming.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.MethodDescriptorProto"
    }
    override public func className() -> String {
        return "Google.Protobuf.MethodDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.MethodDescriptorProto.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.MethodDescriptorProto = Google.Protobuf.MethodDescriptorProto()
      public func getMessage() -> Google.Protobuf.MethodDescriptorProto {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(_ value:String) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var hasInputType:Bool {
           get {
                return builderResult.hasInputType
           }
      }
      public var inputType:String {
           get {
                return builderResult.inputType
           }
           set (value) {
               builderResult.hasInputType = true
               builderResult.inputType = value
           }
      }
      public func setInputType(_ value:String) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.inputType = value
        return self
      }
      public func clearInputType() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasInputType = false
           builderResult.inputType = ""
           return self
      }
      public var hasOutputType:Bool {
           get {
                return builderResult.hasOutputType
           }
      }
      public var outputType:String {
           get {
                return builderResult.outputType
           }
           set (value) {
               builderResult.hasOutputType = true
               builderResult.outputType = value
           }
      }
      public func setOutputType(_ value:String) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.outputType = value
        return self
      }
      public func clearOutputType() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasOutputType = false
           builderResult.outputType = ""
           return self
      }
      public var hasOptions:Bool {
           get {
               return builderResult.hasOptions
           }
      }
      public var options:Google.Protobuf.MethodOptions! {
           get {
               if optionsBuilder_ != nil {
                  builderResult.options = optionsBuilder_.getMessage()
               }
               return builderResult.options
           }
           set (value) {
               builderResult.hasOptions = true
               builderResult.options = value
           }
      }
      private var optionsBuilder_:Google.Protobuf.MethodOptions.Builder! {
           didSet {
              builderResult.hasOptions = true
           }
      }
      public func getOptionsBuilder() -> Google.Protobuf.MethodOptions.Builder {
        if optionsBuilder_ == nil {
           optionsBuilder_ = Google.Protobuf.MethodOptions.Builder()
           builderResult.options = optionsBuilder_.getMessage()
           if options != nil {
              try! optionsBuilder_.mergeFrom(options)
           }
        }
        return optionsBuilder_
      }
      public func setOptions(_ value:Google.Protobuf.MethodOptions!) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.options = value
        return self
      }
      public func mergeOptions(_ value:Google.Protobuf.MethodOptions) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        if builderResult.hasOptions {
          builderResult.options = try Google.Protobuf.MethodOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
        } else {
          builderResult.options = value
        }
        builderResult.hasOptions = true
        return self
      }
      public func clearOptions() -> Google.Protobuf.MethodDescriptorProto.Builder {
        optionsBuilder_ = nil
        builderResult.hasOptions = false
        builderResult.options = nil
        return self
      }
      public var hasClientStreaming:Bool {
           get {
                return builderResult.hasClientStreaming
           }
      }
      public var clientStreaming:Bool {
           get {
                return builderResult.clientStreaming
           }
           set (value) {
               builderResult.hasClientStreaming = true
               builderResult.clientStreaming = value
           }
      }
      public func setClientStreaming(_ value:Bool) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.clientStreaming = value
        return self
      }
      public func clearClientStreaming() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasClientStreaming = false
           builderResult.clientStreaming = false
           return self
      }
      public var hasServerStreaming:Bool {
           get {
                return builderResult.hasServerStreaming
           }
      }
      public var serverStreaming:Bool {
           get {
                return builderResult.serverStreaming
           }
           set (value) {
               builderResult.hasServerStreaming = true
               builderResult.serverStreaming = value
           }
      }
      public func setServerStreaming(_ value:Bool) -> Google.Protobuf.MethodDescriptorProto.Builder {
        self.serverStreaming = value
        return self
      }
      public func clearServerStreaming() -> Google.Protobuf.MethodDescriptorProto.Builder{
           builderResult.hasServerStreaming = false
           builderResult.serverStreaming = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.MethodDescriptorProto.Builder {
        builderResult = Google.Protobuf.MethodDescriptorProto()
        return self
      }
      override public func clone() throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        return try Google.Protobuf.MethodDescriptorProto.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.MethodDescriptorProto {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.MethodDescriptorProto {
        let returnMe:Google.Protobuf.MethodDescriptorProto = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.MethodDescriptorProto) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        if other == Google.Protobuf.MethodDescriptorProto() {
         return self
        }
        if other.hasName {
             name = other.name
        }
        if other.hasInputType {
             inputType = other.inputType
        }
        if other.hasOutputType {
             outputType = other.outputType
        }
        if (other.hasOptions) {
            try mergeOptions(other.options)
        }
        if other.hasClientStreaming {
             clientStreaming = other.clientStreaming
        }
        if other.hasServerStreaming {
             serverStreaming = other.serverStreaming
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            name = try input.readString()

          case 18:
            inputType = try input.readString()

          case 26:
            outputType = try input.readString()

          case 34:
            let subBuilder:Google.Protobuf.MethodOptions.Builder = Google.Protobuf.MethodOptions.Builder()
            if hasOptions {
              try subBuilder.mergeFrom(options)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            options = subBuilder.buildPartial()

          case 40:
            clientStreaming = try input.readBool()

          case 48:
            serverStreaming = try input.readBool()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        let resultDecodedBuilder = Google.Protobuf.MethodDescriptorProto.Builder()
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueInputType = jsonMap["inputType"] as? String {
          resultDecodedBuilder.inputType = jsonValueInputType
        }
        if let jsonValueOutputType = jsonMap["outputType"] as? String {
          resultDecodedBuilder.outputType = jsonValueOutputType
        }
        if let jsonValueOptions = jsonMap["options"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.options = try Google.Protobuf.MethodOptions.Builder.decodeToBuilder(jsonValueOptions).build()

        }
        if let jsonValueClientStreaming = jsonMap["clientStreaming"] as? Bool {
          resultDecodedBuilder.clientStreaming = jsonValueClientStreaming
        }
        if let jsonValueServerStreaming = jsonMap["serverStreaming"] as? Bool {
          resultDecodedBuilder.serverStreaming = jsonValueServerStreaming
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.MethodDescriptorProto.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.MethodDescriptorProto.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class FileOptions : ExtendableMessage, GeneratedMessageProtocol{


      //Enum type declaration start 

      // Generated classes can be optimized for speed or code size.
      public enum OptimizeMode:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // Generate complete code for parsing, serialization,
        case speed = 1

        // etc.
        case codeSize = 2

        // Generate code using MessageLite and the lite runtime.
        case liteRuntime = 3
        public func toString() -> String {
          switch self {
          case .speed: return "SPEED"
          case .codeSize: return "CODE_SIZE"
          case .liteRuntime: return "LITE_RUNTIME"
          }
        }
        public static func fromString(_ str:String) throws -> Google.Protobuf.FileOptions.OptimizeMode {
          switch str {
          case "SPEED":  return .speed
          case "CODE_SIZE":  return .codeSize
          case "LITE_RUNTIME":  return .liteRuntime
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .speed: return ".Speed"
                case .codeSize: return ".CodeSize"
                case .liteRuntime: return ".LiteRuntime"
            }
        }
      }

      //Enum type declaration end 

    // Sets the Java package where classes generated from this .proto will be
    // placed.  By default, the proto package is used, but this is often
    // inappropriate because proto packages do not normally start with backwards
    // domain names.
    public private(set) var hasJavaPackage:Bool = false
    public private(set) var javaPackage:String = ""

    // If set, all the classes from the .proto file are wrapped in a single
    // outer class with the given name.  This applies to both Proto1
    // (equivalent to the old "--one_java_file" option) and Proto2 (where
    // a .proto always translates to a single class, but you may want to
    // explicitly choose the class name).
    public private(set) var hasJavaOuterClassname:Bool = false
    public private(set) var javaOuterClassname:String = ""

    // If set true, then the Java code generator will generate a separate .java
    // file for each top-level message, enum, and service defined in the .proto
    // file.  Thus, these types will *not* be nested inside the outer class
    // named by java_outer_classname.  However, the outer class will still be
    // generated to contain the file's getDescriptor() method as well as any
    // top-level extensions defined in the file.
    public private(set) var hasJavaMultipleFiles:Bool = false
    public private(set) var javaMultipleFiles:Bool = false

    // If set true, then the Java code generator will generate equals() and
    // hashCode() methods for all messages defined in the .proto file.
    // - In the full runtime, this is purely a speed optimization, as the
    // AbstractMessage base class includes reflection-based implementations of
    // these methods.
    //- In the lite runtime, setting this option changes the semantics of
    // equals() and hashCode() to more closely match those of the full runtime;
    // the generated methods compute their results based on field values rather
    // than object identity. (Implementations should not assume that hashcodes
    // will be consistent across runtimes or versions of the protocol compiler.)
    public private(set) var hasJavaGenerateEqualsAndHash:Bool = false
    public private(set) var javaGenerateEqualsAndHash:Bool = false

    // If set true, then the Java2 code generator will generate code that
    // throws an exception whenever an attempt is made to assign a non-UTF-8
    // byte sequence to a string field.
    // Message reflection will do the same.
    // However, an extension field still accepts non-UTF-8 byte sequences.
    // This option has no effect on when used with the lite runtime.
    public private(set) var hasJavaStringCheckUtf8:Bool = false
    public private(set) var javaStringCheckUtf8:Bool = false

    public private(set) var optimizeFor:OptimizeMode = Google.Protobuf.FileOptions.OptimizeMode.speed
    public private(set) var hasOptimizeFor:Bool = false
    // Sets the Go package where structs generated from this .proto will be
    // placed. If omitted, the Go package will be derived from the following:
    //   - The basename of the package import path, if provided.
    //   - Otherwise, the package statement in the .proto file, if present.
    //   - Otherwise, the basename of the .proto file, without extension.
    public private(set) var hasGoPackage:Bool = false
    public private(set) var goPackage:String = ""

    // Should generic services be generated in each language?  "Generic" services
    // are not specific to any particular RPC system.  They are generated by the
    // main code generators in each language (without additional plugins).
    // Generic services were the only kind of service generation supported by
    // early versions of google.protobuf.
    // Generic services are now considered deprecated in favor of using plugins
    // that generate code specific to your particular RPC system.  Therefore,
    // these default to false.  Old code which depends on generic services should
    // explicitly set them to true.
    public private(set) var hasCcGenericServices:Bool = false
    public private(set) var ccGenericServices:Bool = false

    public private(set) var hasJavaGenericServices:Bool = false
    public private(set) var javaGenericServices:Bool = false

    public private(set) var hasPyGenericServices:Bool = false
    public private(set) var pyGenericServices:Bool = false

    // Is this file deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for everything in the file, or it will be completely ignored; in the very
    // least, this is a formalization for deprecating files.
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    // Enables the use of arenas for the proto messages in this file. This applies
    // only to generated classes for C++.
    public private(set) var hasCcEnableArenas:Bool = false
    public private(set) var ccEnableArenas:Bool = false

    // Sets the objective c class prefix which is prepended to all objective c
    // generated classes from this .proto. There is no default.
    public private(set) var hasObjcClassPrefix:Bool = false
    public private(set) var objcClassPrefix:String = ""

    // Namespace for generated classes; defaults to the package.
    public private(set) var hasCsharpNamespace:Bool = false
    public private(set) var csharpNamespace:String = ""

    public private(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasJavaPackage {
        try output.writeString(1, value:javaPackage)
      }
      if hasJavaOuterClassname {
        try output.writeString(8, value:javaOuterClassname)
      }
      if hasOptimizeFor {
        try output.writeEnum(9, value:optimizeFor.rawValue)
      }
      if hasJavaMultipleFiles {
        try output.writeBool(10, value:javaMultipleFiles)
      }
      if hasGoPackage {
        try output.writeString(11, value:goPackage)
      }
      if hasCcGenericServices {
        try output.writeBool(16, value:ccGenericServices)
      }
      if hasJavaGenericServices {
        try output.writeBool(17, value:javaGenericServices)
      }
      if hasPyGenericServices {
        try output.writeBool(18, value:pyGenericServices)
      }
      if hasJavaGenerateEqualsAndHash {
        try output.writeBool(20, value:javaGenerateEqualsAndHash)
      }
      if hasDeprecated {
        try output.writeBool(23, value:deprecated)
      }
      if hasJavaStringCheckUtf8 {
        try output.writeBool(27, value:javaStringCheckUtf8)
      }
      if hasCcEnableArenas {
        try output.writeBool(31, value:ccEnableArenas)
      }
      if hasObjcClassPrefix {
        try output.writeString(36, value:objcClassPrefix)
      }
      if hasCsharpNamespace {
        try output.writeString(37, value:csharpNamespace)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try output.writeMessage(999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasJavaPackage {
        serialize_size += javaPackage.computeStringSize(1)
      }
      if hasJavaOuterClassname {
        serialize_size += javaOuterClassname.computeStringSize(8)
      }
      if (hasOptimizeFor) {
        serialize_size += optimizeFor.rawValue.computeEnumSize(9)
      }
      if hasJavaMultipleFiles {
        serialize_size += javaMultipleFiles.computeBoolSize(10)
      }
      if hasGoPackage {
        serialize_size += goPackage.computeStringSize(11)
      }
      if hasCcGenericServices {
        serialize_size += ccGenericServices.computeBoolSize(16)
      }
      if hasJavaGenericServices {
        serialize_size += javaGenericServices.computeBoolSize(17)
      }
      if hasPyGenericServices {
        serialize_size += pyGenericServices.computeBoolSize(18)
      }
      if hasJavaGenerateEqualsAndHash {
        serialize_size += javaGenerateEqualsAndHash.computeBoolSize(20)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(23)
      }
      if hasJavaStringCheckUtf8 {
        serialize_size += javaStringCheckUtf8.computeBoolSize(27)
      }
      if hasCcEnableArenas {
        serialize_size += ccEnableArenas.computeBoolSize(31)
      }
      if hasObjcClassPrefix {
        serialize_size += objcClassPrefix.computeStringSize(36)
      }
      if hasCsharpNamespace {
        serialize_size += csharpNamespace.computeStringSize(37)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.FileOptions> {
      var mergedArray = Array<Google.Protobuf.FileOptions>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FileOptions? {
      return try Google.Protobuf.FileOptions.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.FileOptions.Builder {
      return Google.Protobuf.FileOptions.classBuilder() as! Google.Protobuf.FileOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.FileOptions.Builder {
      return classBuilder() as! Google.Protobuf.FileOptions.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FileOptions.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FileOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FileOptions.Builder {
      return try Google.Protobuf.FileOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.FileOptions) throws -> Google.Protobuf.FileOptions.Builder {
      return try Google.Protobuf.FileOptions.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasJavaPackage {
        jsonMap["javaPackage"] = javaPackage
      }
      if hasJavaOuterClassname {
        jsonMap["javaOuterClassname"] = javaOuterClassname
      }
      if hasJavaMultipleFiles {
        jsonMap["javaMultipleFiles"] = javaMultipleFiles
      }
      if hasJavaGenerateEqualsAndHash {
        jsonMap["javaGenerateEqualsAndHash"] = javaGenerateEqualsAndHash
      }
      if hasJavaStringCheckUtf8 {
        jsonMap["javaStringCheckUtf8"] = javaStringCheckUtf8
      }
      if hasOptimizeFor {
        jsonMap["optimizeFor"] = optimizeFor.toString()
      }
      if hasGoPackage {
        jsonMap["goPackage"] = goPackage
      }
      if hasCcGenericServices {
        jsonMap["ccGenericServices"] = ccGenericServices
      }
      if hasJavaGenericServices {
        jsonMap["javaGenericServices"] = javaGenericServices
      }
      if hasPyGenericServices {
        jsonMap["pyGenericServices"] = pyGenericServices
      }
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if hasCcEnableArenas {
        jsonMap["ccEnableArenas"] = ccEnableArenas
      }
      if hasObjcClassPrefix {
        jsonMap["objcClassPrefix"] = objcClassPrefix
      }
      if hasCsharpNamespace {
        jsonMap["csharpNamespace"] = csharpNamespace
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,AnyObject>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption += [ecodedMessageUninterpretedOption]
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.FileOptions {
      return try Google.Protobuf.FileOptions.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasJavaPackage {
        output += "\(indent) javaPackage: \(javaPackage) \n"
      }
      if hasJavaOuterClassname {
        output += "\(indent) javaOuterClassname: \(javaOuterClassname) \n"
      }
      if (hasOptimizeFor) {
        output += "\(indent) optimizeFor: \(optimizeFor.description)\n"
      }
      if hasJavaMultipleFiles {
        output += "\(indent) javaMultipleFiles: \(javaMultipleFiles) \n"
      }
      if hasGoPackage {
        output += "\(indent) goPackage: \(goPackage) \n"
      }
      if hasCcGenericServices {
        output += "\(indent) ccGenericServices: \(ccGenericServices) \n"
      }
      if hasJavaGenericServices {
        output += "\(indent) javaGenericServices: \(javaGenericServices) \n"
      }
      if hasPyGenericServices {
        output += "\(indent) pyGenericServices: \(pyGenericServices) \n"
      }
      if hasJavaGenerateEqualsAndHash {
        output += "\(indent) javaGenerateEqualsAndHash: \(javaGenerateEqualsAndHash) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      if hasJavaStringCheckUtf8 {
        output += "\(indent) javaStringCheckUtf8: \(javaStringCheckUtf8) \n"
      }
      if hasCcEnableArenas {
        output += "\(indent) ccEnableArenas: \(ccEnableArenas) \n"
      }
      if hasObjcClassPrefix {
        output += "\(indent) objcClassPrefix: \(objcClassPrefix) \n"
      }
      if hasCsharpNamespace {
        output += "\(indent) csharpNamespace: \(csharpNamespace) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(536870912), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasJavaPackage {
               hashCode = (hashCode &* 31) &+ javaPackage.hashValue
            }
            if hasJavaOuterClassname {
               hashCode = (hashCode &* 31) &+ javaOuterClassname.hashValue
            }
            if hasOptimizeFor {
               hashCode = (hashCode &* 31) &+ Int(optimizeFor.rawValue)
            }
            if hasJavaMultipleFiles {
               hashCode = (hashCode &* 31) &+ javaMultipleFiles.hashValue
            }
            if hasGoPackage {
               hashCode = (hashCode &* 31) &+ goPackage.hashValue
            }
            if hasCcGenericServices {
               hashCode = (hashCode &* 31) &+ ccGenericServices.hashValue
            }
            if hasJavaGenericServices {
               hashCode = (hashCode &* 31) &+ javaGenericServices.hashValue
            }
            if hasPyGenericServices {
               hashCode = (hashCode &* 31) &+ pyGenericServices.hashValue
            }
            if hasJavaGenerateEqualsAndHash {
               hashCode = (hashCode &* 31) &+ javaGenerateEqualsAndHash.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            if hasJavaStringCheckUtf8 {
               hashCode = (hashCode &* 31) &+ javaStringCheckUtf8.hashValue
            }
            if hasCcEnableArenas {
               hashCode = (hashCode &* 31) &+ ccEnableArenas.hashValue
            }
            if hasObjcClassPrefix {
               hashCode = (hashCode &* 31) &+ objcClassPrefix.hashValue
            }
            if hasCsharpNamespace {
               hashCode = (hashCode &* 31) &+ csharpNamespace.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FileOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.FileOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.FileOptions.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Google.Protobuf.FileOptions = Google.Protobuf.FileOptions()
      public func getMessage() -> Google.Protobuf.FileOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasJavaPackage:Bool {
           get {
                return builderResult.hasJavaPackage
           }
      }
      public var javaPackage:String {
           get {
                return builderResult.javaPackage
           }
           set (value) {
               builderResult.hasJavaPackage = true
               builderResult.javaPackage = value
           }
      }
      public func setJavaPackage(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.javaPackage = value
        return self
      }
      public func clearJavaPackage() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaPackage = false
           builderResult.javaPackage = ""
           return self
      }
      public var hasJavaOuterClassname:Bool {
           get {
                return builderResult.hasJavaOuterClassname
           }
      }
      public var javaOuterClassname:String {
           get {
                return builderResult.javaOuterClassname
           }
           set (value) {
               builderResult.hasJavaOuterClassname = true
               builderResult.javaOuterClassname = value
           }
      }
      public func setJavaOuterClassname(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.javaOuterClassname = value
        return self
      }
      public func clearJavaOuterClassname() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaOuterClassname = false
           builderResult.javaOuterClassname = ""
           return self
      }
      public var hasJavaMultipleFiles:Bool {
           get {
                return builderResult.hasJavaMultipleFiles
           }
      }
      public var javaMultipleFiles:Bool {
           get {
                return builderResult.javaMultipleFiles
           }
           set (value) {
               builderResult.hasJavaMultipleFiles = true
               builderResult.javaMultipleFiles = value
           }
      }
      public func setJavaMultipleFiles(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.javaMultipleFiles = value
        return self
      }
      public func clearJavaMultipleFiles() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaMultipleFiles = false
           builderResult.javaMultipleFiles = false
           return self
      }
      public var hasJavaGenerateEqualsAndHash:Bool {
           get {
                return builderResult.hasJavaGenerateEqualsAndHash
           }
      }
      public var javaGenerateEqualsAndHash:Bool {
           get {
                return builderResult.javaGenerateEqualsAndHash
           }
           set (value) {
               builderResult.hasJavaGenerateEqualsAndHash = true
               builderResult.javaGenerateEqualsAndHash = value
           }
      }
      public func setJavaGenerateEqualsAndHash(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.javaGenerateEqualsAndHash = value
        return self
      }
      public func clearJavaGenerateEqualsAndHash() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaGenerateEqualsAndHash = false
           builderResult.javaGenerateEqualsAndHash = false
           return self
      }
      public var hasJavaStringCheckUtf8:Bool {
           get {
                return builderResult.hasJavaStringCheckUtf8
           }
      }
      public var javaStringCheckUtf8:Bool {
           get {
                return builderResult.javaStringCheckUtf8
           }
           set (value) {
               builderResult.hasJavaStringCheckUtf8 = true
               builderResult.javaStringCheckUtf8 = value
           }
      }
      public func setJavaStringCheckUtf8(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.javaStringCheckUtf8 = value
        return self
      }
      public func clearJavaStringCheckUtf8() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaStringCheckUtf8 = false
           builderResult.javaStringCheckUtf8 = false
           return self
      }
        public var hasOptimizeFor:Bool{
            get {
                return builderResult.hasOptimizeFor
            }
        }
        public var optimizeFor:Google.Protobuf.FileOptions.OptimizeMode {
            get {
                return builderResult.optimizeFor
            }
            set (value) {
                builderResult.hasOptimizeFor = true
                builderResult.optimizeFor = value
            }
        }
        public func setOptimizeFor(_ value:Google.Protobuf.FileOptions.OptimizeMode) -> Google.Protobuf.FileOptions.Builder {
          self.optimizeFor = value
          return self
        }
        public func clearOptimizeFor() -> Google.Protobuf.FileOptions.Builder {
           builderResult.hasOptimizeFor = false
           builderResult.optimizeFor = .speed
           return self
        }
      public var hasGoPackage:Bool {
           get {
                return builderResult.hasGoPackage
           }
      }
      public var goPackage:String {
           get {
                return builderResult.goPackage
           }
           set (value) {
               builderResult.hasGoPackage = true
               builderResult.goPackage = value
           }
      }
      public func setGoPackage(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.goPackage = value
        return self
      }
      public func clearGoPackage() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasGoPackage = false
           builderResult.goPackage = ""
           return self
      }
      public var hasCcGenericServices:Bool {
           get {
                return builderResult.hasCcGenericServices
           }
      }
      public var ccGenericServices:Bool {
           get {
                return builderResult.ccGenericServices
           }
           set (value) {
               builderResult.hasCcGenericServices = true
               builderResult.ccGenericServices = value
           }
      }
      public func setCcGenericServices(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.ccGenericServices = value
        return self
      }
      public func clearCcGenericServices() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasCcGenericServices = false
           builderResult.ccGenericServices = false
           return self
      }
      public var hasJavaGenericServices:Bool {
           get {
                return builderResult.hasJavaGenericServices
           }
      }
      public var javaGenericServices:Bool {
           get {
                return builderResult.javaGenericServices
           }
           set (value) {
               builderResult.hasJavaGenericServices = true
               builderResult.javaGenericServices = value
           }
      }
      public func setJavaGenericServices(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.javaGenericServices = value
        return self
      }
      public func clearJavaGenericServices() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasJavaGenericServices = false
           builderResult.javaGenericServices = false
           return self
      }
      public var hasPyGenericServices:Bool {
           get {
                return builderResult.hasPyGenericServices
           }
      }
      public var pyGenericServices:Bool {
           get {
                return builderResult.pyGenericServices
           }
           set (value) {
               builderResult.hasPyGenericServices = true
               builderResult.pyGenericServices = value
           }
      }
      public func setPyGenericServices(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.pyGenericServices = value
        return self
      }
      public func clearPyGenericServices() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasPyGenericServices = false
           builderResult.pyGenericServices = false
           return self
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.deprecated = value
        return self
      }
      public func clearDeprecated() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var hasCcEnableArenas:Bool {
           get {
                return builderResult.hasCcEnableArenas
           }
      }
      public var ccEnableArenas:Bool {
           get {
                return builderResult.ccEnableArenas
           }
           set (value) {
               builderResult.hasCcEnableArenas = true
               builderResult.ccEnableArenas = value
           }
      }
      public func setCcEnableArenas(_ value:Bool) -> Google.Protobuf.FileOptions.Builder {
        self.ccEnableArenas = value
        return self
      }
      public func clearCcEnableArenas() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasCcEnableArenas = false
           builderResult.ccEnableArenas = false
           return self
      }
      public var hasObjcClassPrefix:Bool {
           get {
                return builderResult.hasObjcClassPrefix
           }
      }
      public var objcClassPrefix:String {
           get {
                return builderResult.objcClassPrefix
           }
           set (value) {
               builderResult.hasObjcClassPrefix = true
               builderResult.objcClassPrefix = value
           }
      }
      public func setObjcClassPrefix(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.objcClassPrefix = value
        return self
      }
      public func clearObjcClassPrefix() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasObjcClassPrefix = false
           builderResult.objcClassPrefix = ""
           return self
      }
      public var hasCsharpNamespace:Bool {
           get {
                return builderResult.hasCsharpNamespace
           }
      }
      public var csharpNamespace:String {
           get {
                return builderResult.csharpNamespace
           }
           set (value) {
               builderResult.hasCsharpNamespace = true
               builderResult.csharpNamespace = value
           }
      }
      public func setCsharpNamespace(_ value:String) -> Google.Protobuf.FileOptions.Builder {
        self.csharpNamespace = value
        return self
      }
      public func clearCsharpNamespace() -> Google.Protobuf.FileOptions.Builder{
           builderResult.hasCsharpNamespace = false
           builderResult.csharpNamespace = ""
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.FileOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      public func clearUninterpretedOption() -> Google.Protobuf.FileOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.FileOptions.Builder {
        builderResult = Google.Protobuf.FileOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FileOptions.Builder {
        return try Google.Protobuf.FileOptions.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.FileOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FileOptions {
        let returnMe:Google.Protobuf.FileOptions = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.FileOptions) throws -> Google.Protobuf.FileOptions.Builder {
        if other == Google.Protobuf.FileOptions() {
         return self
        }
        if other.hasJavaPackage {
             javaPackage = other.javaPackage
        }
        if other.hasJavaOuterClassname {
             javaOuterClassname = other.javaOuterClassname
        }
        if other.hasJavaMultipleFiles {
             javaMultipleFiles = other.javaMultipleFiles
        }
        if other.hasJavaGenerateEqualsAndHash {
             javaGenerateEqualsAndHash = other.javaGenerateEqualsAndHash
        }
        if other.hasJavaStringCheckUtf8 {
             javaStringCheckUtf8 = other.javaStringCheckUtf8
        }
        if other.hasOptimizeFor {
             optimizeFor = other.optimizeFor
        }
        if other.hasGoPackage {
             goPackage = other.goPackage
        }
        if other.hasCcGenericServices {
             ccGenericServices = other.ccGenericServices
        }
        if other.hasJavaGenericServices {
             javaGenericServices = other.javaGenericServices
        }
        if other.hasPyGenericServices {
             pyGenericServices = other.pyGenericServices
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if other.hasCcEnableArenas {
             ccEnableArenas = other.ccEnableArenas
        }
        if other.hasObjcClassPrefix {
             objcClassPrefix = other.objcClassPrefix
        }
        if other.hasCsharpNamespace {
             csharpNamespace = other.csharpNamespace
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FileOptions.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FileOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            javaPackage = try input.readString()

          case 66:
            javaOuterClassname = try input.readString()

          case 72:
            let valueIntoptimizeFor = try input.readEnum()
            if let enumsoptimizeFor = Google.Protobuf.FileOptions.OptimizeMode(rawValue:valueIntoptimizeFor){
                 optimizeFor = enumsoptimizeFor
            } else {
                 try unknownFieldsBuilder.mergeVarintField(9, value:Int64(valueIntoptimizeFor))
            }

          case 80:
            javaMultipleFiles = try input.readBool()

          case 90:
            goPackage = try input.readString()

          case 128:
            ccGenericServices = try input.readBool()

          case 136:
            javaGenericServices = try input.readBool()

          case 144:
            pyGenericServices = try input.readBool()

          case 160:
            javaGenerateEqualsAndHash = try input.readBool()

          case 184:
            deprecated = try input.readBool()

          case 216:
            javaStringCheckUtf8 = try input.readBool()

          case 248:
            ccEnableArenas = try input.readBool()

          case 290:
            objcClassPrefix = try input.readString()

          case 298:
            csharpNamespace = try input.readString()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FileOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.FileOptions.Builder()
        if let jsonValueJavaPackage = jsonMap["javaPackage"] as? String {
          resultDecodedBuilder.javaPackage = jsonValueJavaPackage
        }
        if let jsonValueJavaOuterClassname = jsonMap["javaOuterClassname"] as? String {
          resultDecodedBuilder.javaOuterClassname = jsonValueJavaOuterClassname
        }
        if let jsonValueJavaMultipleFiles = jsonMap["javaMultipleFiles"] as? Bool {
          resultDecodedBuilder.javaMultipleFiles = jsonValueJavaMultipleFiles
        }
        if let jsonValueJavaGenerateEqualsAndHash = jsonMap["javaGenerateEqualsAndHash"] as? Bool {
          resultDecodedBuilder.javaGenerateEqualsAndHash = jsonValueJavaGenerateEqualsAndHash
        }
        if let jsonValueJavaStringCheckUtf8 = jsonMap["javaStringCheckUtf8"] as? Bool {
          resultDecodedBuilder.javaStringCheckUtf8 = jsonValueJavaStringCheckUtf8
        }
        if let jsonValueOptimizeFor = jsonMap["optimizeFor"] as? String {
          resultDecodedBuilder.optimizeFor = try Google.Protobuf.FileOptions.OptimizeMode.fromString(jsonValueOptimizeFor)
        }
        if let jsonValueGoPackage = jsonMap["goPackage"] as? String {
          resultDecodedBuilder.goPackage = jsonValueGoPackage
        }
        if let jsonValueCcGenericServices = jsonMap["ccGenericServices"] as? Bool {
          resultDecodedBuilder.ccGenericServices = jsonValueCcGenericServices
        }
        if let jsonValueJavaGenericServices = jsonMap["javaGenericServices"] as? Bool {
          resultDecodedBuilder.javaGenericServices = jsonValueJavaGenericServices
        }
        if let jsonValuePyGenericServices = jsonMap["pyGenericServices"] as? Bool {
          resultDecodedBuilder.pyGenericServices = jsonValuePyGenericServices
        }
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueCcEnableArenas = jsonMap["ccEnableArenas"] as? Bool {
          resultDecodedBuilder.ccEnableArenas = jsonValueCcEnableArenas
        }
        if let jsonValueObjcClassPrefix = jsonMap["objcClassPrefix"] as? String {
          resultDecodedBuilder.objcClassPrefix = jsonValueObjcClassPrefix
        }
        if let jsonValueCsharpNamespace = jsonMap["csharpNamespace"] as? String {
          resultDecodedBuilder.csharpNamespace = jsonValueCsharpNamespace
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption += [messageFromStringUninterpretedOption]
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.FileOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FileOptions.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class MessageOptions : ExtendableMessage, GeneratedMessageProtocol{
    // Set true to use the old proto1 MessageSet wire format for extensions.
    // This is provided for backwards-compatibility with the MessageSet wire
    // format.  You should not use this for any other reason:  It's less
    // efficient, has fewer features, and is more complicated.
    // The message must be defined exactly as follows:
    //   message Foo {
    //     option message_set_wire_format = true;
    //     extensions 4 to max;
    //   }
    // Note that the message cannot have any defined fields; MessageSets only
    // have extensions.
    // All extensions of your type must be singular messages; e.g. they cannot
    // be int32s, enums, or repeated messages.
    // Because this is an option, the above two restrictions are not enforced by
    // the protocol compiler.
    public private(set) var hasMessageSetWireFormat:Bool = false
    public private(set) var messageSetWireFormat:Bool = false

    // Disables the generation of the standard "descriptor()" accessor, which can
    // conflict with a field of the same name.  This is meant to make migration
    // from proto1 easier; new code should avoid fields named "descriptor".
    public private(set) var hasNoStandardDescriptorAccessor:Bool = false
    public private(set) var noStandardDescriptorAccessor:Bool = false

    // Is this message deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the message, or it will be completely ignored; in the very least,
    // this is a formalization for deprecating messages.
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    // Whether the message is an automatically generated map entry type for the
    // maps field.
    // For maps fields:
    //     map<KeyType, ValueType> map_field = 1;
    // The parsed descriptor looks like:
    //     message MapFieldEntry {
    //         option map_entry = true;
    //         optional KeyType key = 1;
    //         optional ValueType value = 2;
    //     }
    //     repeated MapFieldEntry map_field = 1;
    // Implementations may choose not to generate the map_entry=true message, but
    // use a native map in the target language to hold the keys and values.
    // The reflection APIs in such implementions still need to work as
    // if the field is a repeated message field.
    // NOTE: Do not set the option in .proto files. Always use the maps syntax
    // instead. The option should only be implicitly set by the proto compiler
    // parser.
    public private(set) var hasMapEntry:Bool = false
    public private(set) var mapEntry:Bool = false

    public private(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasMessageSetWireFormat {
        try output.writeBool(1, value:messageSetWireFormat)
      }
      if hasNoStandardDescriptorAccessor {
        try output.writeBool(2, value:noStandardDescriptorAccessor)
      }
      if hasDeprecated {
        try output.writeBool(3, value:deprecated)
      }
      if hasMapEntry {
        try output.writeBool(7, value:mapEntry)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try output.writeMessage(999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasMessageSetWireFormat {
        serialize_size += messageSetWireFormat.computeBoolSize(1)
      }
      if hasNoStandardDescriptorAccessor {
        serialize_size += noStandardDescriptorAccessor.computeBoolSize(2)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(3)
      }
      if hasMapEntry {
        serialize_size += mapEntry.computeBoolSize(7)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.MessageOptions> {
      var mergedArray = Array<Google.Protobuf.MessageOptions>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.MessageOptions? {
      return try Google.Protobuf.MessageOptions.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.MessageOptions.Builder {
      return Google.Protobuf.MessageOptions.classBuilder() as! Google.Protobuf.MessageOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.MessageOptions.Builder {
      return classBuilder() as! Google.Protobuf.MessageOptions.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.MessageOptions.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.MessageOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.MessageOptions.Builder {
      return try Google.Protobuf.MessageOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.MessageOptions) throws -> Google.Protobuf.MessageOptions.Builder {
      return try Google.Protobuf.MessageOptions.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasMessageSetWireFormat {
        jsonMap["messageSetWireFormat"] = messageSetWireFormat
      }
      if hasNoStandardDescriptorAccessor {
        jsonMap["noStandardDescriptorAccessor"] = noStandardDescriptorAccessor
      }
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if hasMapEntry {
        jsonMap["mapEntry"] = mapEntry
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,AnyObject>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption += [ecodedMessageUninterpretedOption]
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.MessageOptions {
      return try Google.Protobuf.MessageOptions.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasMessageSetWireFormat {
        output += "\(indent) messageSetWireFormat: \(messageSetWireFormat) \n"
      }
      if hasNoStandardDescriptorAccessor {
        output += "\(indent) noStandardDescriptorAccessor: \(noStandardDescriptorAccessor) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      if hasMapEntry {
        output += "\(indent) mapEntry: \(mapEntry) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(536870912), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMessageSetWireFormat {
               hashCode = (hashCode &* 31) &+ messageSetWireFormat.hashValue
            }
            if hasNoStandardDescriptorAccessor {
               hashCode = (hashCode &* 31) &+ noStandardDescriptorAccessor.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            if hasMapEntry {
               hashCode = (hashCode &* 31) &+ mapEntry.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.MessageOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.MessageOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.MessageOptions.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Google.Protobuf.MessageOptions = Google.Protobuf.MessageOptions()
      public func getMessage() -> Google.Protobuf.MessageOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasMessageSetWireFormat:Bool {
           get {
                return builderResult.hasMessageSetWireFormat
           }
      }
      public var messageSetWireFormat:Bool {
           get {
                return builderResult.messageSetWireFormat
           }
           set (value) {
               builderResult.hasMessageSetWireFormat = true
               builderResult.messageSetWireFormat = value
           }
      }
      public func setMessageSetWireFormat(_ value:Bool) -> Google.Protobuf.MessageOptions.Builder {
        self.messageSetWireFormat = value
        return self
      }
      public func clearMessageSetWireFormat() -> Google.Protobuf.MessageOptions.Builder{
           builderResult.hasMessageSetWireFormat = false
           builderResult.messageSetWireFormat = false
           return self
      }
      public var hasNoStandardDescriptorAccessor:Bool {
           get {
                return builderResult.hasNoStandardDescriptorAccessor
           }
      }
      public var noStandardDescriptorAccessor:Bool {
           get {
                return builderResult.noStandardDescriptorAccessor
           }
           set (value) {
               builderResult.hasNoStandardDescriptorAccessor = true
               builderResult.noStandardDescriptorAccessor = value
           }
      }
      public func setNoStandardDescriptorAccessor(_ value:Bool) -> Google.Protobuf.MessageOptions.Builder {
        self.noStandardDescriptorAccessor = value
        return self
      }
      public func clearNoStandardDescriptorAccessor() -> Google.Protobuf.MessageOptions.Builder{
           builderResult.hasNoStandardDescriptorAccessor = false
           builderResult.noStandardDescriptorAccessor = false
           return self
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.MessageOptions.Builder {
        self.deprecated = value
        return self
      }
      public func clearDeprecated() -> Google.Protobuf.MessageOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var hasMapEntry:Bool {
           get {
                return builderResult.hasMapEntry
           }
      }
      public var mapEntry:Bool {
           get {
                return builderResult.mapEntry
           }
           set (value) {
               builderResult.hasMapEntry = true
               builderResult.mapEntry = value
           }
      }
      public func setMapEntry(_ value:Bool) -> Google.Protobuf.MessageOptions.Builder {
        self.mapEntry = value
        return self
      }
      public func clearMapEntry() -> Google.Protobuf.MessageOptions.Builder{
           builderResult.hasMapEntry = false
           builderResult.mapEntry = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.MessageOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      public func clearUninterpretedOption() -> Google.Protobuf.MessageOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.MessageOptions.Builder {
        builderResult = Google.Protobuf.MessageOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.MessageOptions.Builder {
        return try Google.Protobuf.MessageOptions.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.MessageOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.MessageOptions {
        let returnMe:Google.Protobuf.MessageOptions = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.MessageOptions) throws -> Google.Protobuf.MessageOptions.Builder {
        if other == Google.Protobuf.MessageOptions() {
         return self
        }
        if other.hasMessageSetWireFormat {
             messageSetWireFormat = other.messageSetWireFormat
        }
        if other.hasNoStandardDescriptorAccessor {
             noStandardDescriptorAccessor = other.noStandardDescriptorAccessor
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if other.hasMapEntry {
             mapEntry = other.mapEntry
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.MessageOptions.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MessageOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            messageSetWireFormat = try input.readBool()

          case 16:
            noStandardDescriptorAccessor = try input.readBool()

          case 24:
            deprecated = try input.readBool()

          case 56:
            mapEntry = try input.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.MessageOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.MessageOptions.Builder()
        if let jsonValueMessageSetWireFormat = jsonMap["messageSetWireFormat"] as? Bool {
          resultDecodedBuilder.messageSetWireFormat = jsonValueMessageSetWireFormat
        }
        if let jsonValueNoStandardDescriptorAccessor = jsonMap["noStandardDescriptorAccessor"] as? Bool {
          resultDecodedBuilder.noStandardDescriptorAccessor = jsonValueNoStandardDescriptorAccessor
        }
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueMapEntry = jsonMap["mapEntry"] as? Bool {
          resultDecodedBuilder.mapEntry = jsonValueMapEntry
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption += [messageFromStringUninterpretedOption]
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.MessageOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.MessageOptions.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class FieldOptions : ExtendableMessage, GeneratedMessageProtocol{


      //Enum type declaration start 

      public enum Ctype:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // Default mode.
        case string_ = 0
        case cord = 1
        case stringPiece = 2
        public func toString() -> String {
          switch self {
          case .string_: return "STRING"
          case .cord: return "CORD"
          case .stringPiece: return "STRING_PIECE"
          }
        }
        public static func fromString(_ str:String) throws -> Google.Protobuf.FieldOptions.Ctype {
          switch str {
          case "STRING":  return .string_
          case "CORD":  return .cord
          case "STRING_PIECE":  return .stringPiece
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .string_: return ".String_"
                case .cord: return ".Cord"
                case .stringPiece: return ".StringPiece"
            }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      public enum Jstype:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // Use the default type.
        case jsNormal = 0

        // Use JavaScript strings.
        case jsString = 1

        // Use JavaScript numbers.
        case jsNumber = 2
        public func toString() -> String {
          switch self {
          case .jsNormal: return "JS_NORMAL"
          case .jsString: return "JS_STRING"
          case .jsNumber: return "JS_NUMBER"
          }
        }
        public static func fromString(_ str:String) throws -> Google.Protobuf.FieldOptions.Jstype {
          switch str {
          case "JS_NORMAL":  return .jsNormal
          case "JS_STRING":  return .jsString
          case "JS_NUMBER":  return .jsNumber
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .jsNormal: return ".JsNormal"
                case .jsString: return ".JsString"
                case .jsNumber: return ".JsNumber"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var ctype:Ctype = Google.Protobuf.FieldOptions.Ctype.string_
    public private(set) var hasCtype:Bool = false
    // The packed option can be enabled for repeated primitive fields to enable
    // a more efficient representation on the wire. Rather than repeatedly
    // writing the tag and type for each element, the entire array is encoded as
    // a single length-delimited blob. In proto3, only explicit setting it to
    // false will avoid using packed encoding.
    public private(set) var hasPacked:Bool = false
    public private(set) var packed:Bool = false

    public private(set) var jstype:Jstype = Google.Protobuf.FieldOptions.Jstype.jsNormal
    public private(set) var hasJstype:Bool = false
    // Should this field be parsed lazily?  Lazy applies only to message-type
    // fields.  It means that when the outer message is initially parsed, the
    // inner message's contents will not be parsed but instead stored in encoded
    // form.  The inner message will actually be parsed when it is first accessed.
    // This is only a hint.  Implementations are free to choose whether to use
    // eager or lazy parsing regardless of the value of this option.  However,
    // setting this option true suggests that the protocol author believes that
    // using lazy parsing on this field is worth the additional bookkeeping
    // overhead typically needed to implement it.
    // This option does not affect the public interface of any generated code;
    // all method signatures remain the same.  Furthermore, thread-safety of the
    // interface is not affected by this option; const methods remain safe to
    // call from multiple threads concurrently, while non-const methods continue
    // to require exclusive access.
    // Note that implementations may choose not to check required fields within
    // a lazy sub-message.  That is, calling IsInitialized() on the outher message
    // may return true even if the inner message has missing required fields.
    // This is necessary because otherwise the inner message would have to be
    // parsed in order to perform the check, defeating the purpose of lazy
    // parsing.  An implementation which chooses not to check required fields
    // must be consistent about it.  That is, for any particular sub-message, the
    // implementation must either *always* check its required fields, or *never*
    // check its required fields, regardless of whether or not the message has
    // been parsed.
    public private(set) var hasLazy:Bool = false
    public private(set) var lazy:Bool = false

    // Is this field deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for accessors, or it will be completely ignored; in the very least, this
    // is a formalization for deprecating fields.
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    // For Google-internal migration only. Do not use.
    public private(set) var hasWeak:Bool = false
    public private(set) var weak:Bool = false

    public private(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasCtype {
        try output.writeEnum(1, value:ctype.rawValue)
      }
      if hasPacked {
        try output.writeBool(2, value:packed)
      }
      if hasDeprecated {
        try output.writeBool(3, value:deprecated)
      }
      if hasLazy {
        try output.writeBool(5, value:lazy)
      }
      if hasJstype {
        try output.writeEnum(6, value:jstype.rawValue)
      }
      if hasWeak {
        try output.writeBool(10, value:weak)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try output.writeMessage(999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasCtype) {
        serialize_size += ctype.rawValue.computeEnumSize(1)
      }
      if hasPacked {
        serialize_size += packed.computeBoolSize(2)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(3)
      }
      if hasLazy {
        serialize_size += lazy.computeBoolSize(5)
      }
      if (hasJstype) {
        serialize_size += jstype.rawValue.computeEnumSize(6)
      }
      if hasWeak {
        serialize_size += weak.computeBoolSize(10)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.FieldOptions> {
      var mergedArray = Array<Google.Protobuf.FieldOptions>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FieldOptions? {
      return try Google.Protobuf.FieldOptions.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.FieldOptions.Builder {
      return Google.Protobuf.FieldOptions.classBuilder() as! Google.Protobuf.FieldOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.FieldOptions.Builder {
      return classBuilder() as! Google.Protobuf.FieldOptions.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FieldOptions.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.FieldOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.FieldOptions.Builder {
      return try Google.Protobuf.FieldOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.FieldOptions) throws -> Google.Protobuf.FieldOptions.Builder {
      return try Google.Protobuf.FieldOptions.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasCtype {
        jsonMap["ctype"] = ctype.toString()
      }
      if hasPacked {
        jsonMap["packed"] = packed
      }
      if hasJstype {
        jsonMap["jstype"] = jstype.toString()
      }
      if hasLazy {
        jsonMap["lazy"] = lazy
      }
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if hasWeak {
        jsonMap["weak"] = weak
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,AnyObject>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption += [ecodedMessageUninterpretedOption]
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.FieldOptions {
      return try Google.Protobuf.FieldOptions.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if (hasCtype) {
        output += "\(indent) ctype: \(ctype.description)\n"
      }
      if hasPacked {
        output += "\(indent) packed: \(packed) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      if hasLazy {
        output += "\(indent) lazy: \(lazy) \n"
      }
      if (hasJstype) {
        output += "\(indent) jstype: \(jstype.description)\n"
      }
      if hasWeak {
        output += "\(indent) weak: \(weak) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(536870912), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCtype {
               hashCode = (hashCode &* 31) &+ Int(ctype.rawValue)
            }
            if hasPacked {
               hashCode = (hashCode &* 31) &+ packed.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            if hasLazy {
               hashCode = (hashCode &* 31) &+ lazy.hashValue
            }
            if hasJstype {
               hashCode = (hashCode &* 31) &+ Int(jstype.rawValue)
            }
            if hasWeak {
               hashCode = (hashCode &* 31) &+ weak.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.FieldOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.FieldOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.FieldOptions.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Google.Protobuf.FieldOptions = Google.Protobuf.FieldOptions()
      public func getMessage() -> Google.Protobuf.FieldOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasCtype:Bool{
            get {
                return builderResult.hasCtype
            }
        }
        public var ctype:Google.Protobuf.FieldOptions.Ctype {
            get {
                return builderResult.ctype
            }
            set (value) {
                builderResult.hasCtype = true
                builderResult.ctype = value
            }
        }
        public func setCtype(_ value:Google.Protobuf.FieldOptions.Ctype) -> Google.Protobuf.FieldOptions.Builder {
          self.ctype = value
          return self
        }
        public func clearCtype() -> Google.Protobuf.FieldOptions.Builder {
           builderResult.hasCtype = false
           builderResult.ctype = .string_
           return self
        }
      public var hasPacked:Bool {
           get {
                return builderResult.hasPacked
           }
      }
      public var packed:Bool {
           get {
                return builderResult.packed
           }
           set (value) {
               builderResult.hasPacked = true
               builderResult.packed = value
           }
      }
      public func setPacked(_ value:Bool) -> Google.Protobuf.FieldOptions.Builder {
        self.packed = value
        return self
      }
      public func clearPacked() -> Google.Protobuf.FieldOptions.Builder{
           builderResult.hasPacked = false
           builderResult.packed = false
           return self
      }
        public var hasJstype:Bool{
            get {
                return builderResult.hasJstype
            }
        }
        public var jstype:Google.Protobuf.FieldOptions.Jstype {
            get {
                return builderResult.jstype
            }
            set (value) {
                builderResult.hasJstype = true
                builderResult.jstype = value
            }
        }
        public func setJstype(_ value:Google.Protobuf.FieldOptions.Jstype) -> Google.Protobuf.FieldOptions.Builder {
          self.jstype = value
          return self
        }
        public func clearJstype() -> Google.Protobuf.FieldOptions.Builder {
           builderResult.hasJstype = false
           builderResult.jstype = .jsNormal
           return self
        }
      public var hasLazy:Bool {
           get {
                return builderResult.hasLazy
           }
      }
      public var lazy:Bool {
           get {
                return builderResult.lazy
           }
           set (value) {
               builderResult.hasLazy = true
               builderResult.lazy = value
           }
      }
      public func setLazy(_ value:Bool) -> Google.Protobuf.FieldOptions.Builder {
        self.lazy = value
        return self
      }
      public func clearLazy() -> Google.Protobuf.FieldOptions.Builder{
           builderResult.hasLazy = false
           builderResult.lazy = false
           return self
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.FieldOptions.Builder {
        self.deprecated = value
        return self
      }
      public func clearDeprecated() -> Google.Protobuf.FieldOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var hasWeak:Bool {
           get {
                return builderResult.hasWeak
           }
      }
      public var weak:Bool {
           get {
                return builderResult.weak
           }
           set (value) {
               builderResult.hasWeak = true
               builderResult.weak = value
           }
      }
      public func setWeak(_ value:Bool) -> Google.Protobuf.FieldOptions.Builder {
        self.weak = value
        return self
      }
      public func clearWeak() -> Google.Protobuf.FieldOptions.Builder{
           builderResult.hasWeak = false
           builderResult.weak = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.FieldOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      public func clearUninterpretedOption() -> Google.Protobuf.FieldOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.FieldOptions.Builder {
        builderResult = Google.Protobuf.FieldOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.FieldOptions.Builder {
        return try Google.Protobuf.FieldOptions.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.FieldOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.FieldOptions {
        let returnMe:Google.Protobuf.FieldOptions = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.FieldOptions) throws -> Google.Protobuf.FieldOptions.Builder {
        if other == Google.Protobuf.FieldOptions() {
         return self
        }
        if other.hasCtype {
             ctype = other.ctype
        }
        if other.hasPacked {
             packed = other.packed
        }
        if other.hasJstype {
             jstype = other.jstype
        }
        if other.hasLazy {
             lazy = other.lazy
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if other.hasWeak {
             weak = other.weak
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.FieldOptions.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.FieldOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntctype = try input.readEnum()
            if let enumsctype = Google.Protobuf.FieldOptions.Ctype(rawValue:valueIntctype){
                 ctype = enumsctype
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntctype))
            }

          case 16:
            packed = try input.readBool()

          case 24:
            deprecated = try input.readBool()

          case 40:
            lazy = try input.readBool()

          case 48:
            let valueIntjstype = try input.readEnum()
            if let enumsjstype = Google.Protobuf.FieldOptions.Jstype(rawValue:valueIntjstype){
                 jstype = enumsjstype
            } else {
                 try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntjstype))
            }

          case 80:
            weak = try input.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.FieldOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.FieldOptions.Builder()
        if let jsonValueCtype = jsonMap["ctype"] as? String {
          resultDecodedBuilder.ctype = try Google.Protobuf.FieldOptions.Ctype.fromString(jsonValueCtype)
        }
        if let jsonValuePacked = jsonMap["packed"] as? Bool {
          resultDecodedBuilder.packed = jsonValuePacked
        }
        if let jsonValueJstype = jsonMap["jstype"] as? String {
          resultDecodedBuilder.jstype = try Google.Protobuf.FieldOptions.Jstype.fromString(jsonValueJstype)
        }
        if let jsonValueLazy = jsonMap["lazy"] as? Bool {
          resultDecodedBuilder.lazy = jsonValueLazy
        }
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueWeak = jsonMap["weak"] as? Bool {
          resultDecodedBuilder.weak = jsonValueWeak
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption += [messageFromStringUninterpretedOption]
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.FieldOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.FieldOptions.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class EnumOptions : ExtendableMessage, GeneratedMessageProtocol{
    // Set this option to true to allow mapping different tag names to the same
    // value.
    public private(set) var hasAllowAlias:Bool = false
    public private(set) var allowAlias:Bool = false

    // Is this enum deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the enum, or it will be completely ignored; in the very least, this
    // is a formalization for deprecating enums.
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasAllowAlias {
        try output.writeBool(2, value:allowAlias)
      }
      if hasDeprecated {
        try output.writeBool(3, value:deprecated)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try output.writeMessage(999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasAllowAlias {
        serialize_size += allowAlias.computeBoolSize(2)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(3)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.EnumOptions> {
      var mergedArray = Array<Google.Protobuf.EnumOptions>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.EnumOptions? {
      return try Google.Protobuf.EnumOptions.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.EnumOptions.Builder {
      return Google.Protobuf.EnumOptions.classBuilder() as! Google.Protobuf.EnumOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.EnumOptions.Builder {
      return classBuilder() as! Google.Protobuf.EnumOptions.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.EnumOptions.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.EnumOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.EnumOptions.Builder {
      return try Google.Protobuf.EnumOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.EnumOptions) throws -> Google.Protobuf.EnumOptions.Builder {
      return try Google.Protobuf.EnumOptions.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasAllowAlias {
        jsonMap["allowAlias"] = allowAlias
      }
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,AnyObject>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption += [ecodedMessageUninterpretedOption]
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.EnumOptions {
      return try Google.Protobuf.EnumOptions.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasAllowAlias {
        output += "\(indent) allowAlias: \(allowAlias) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(536870912), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasAllowAlias {
               hashCode = (hashCode &* 31) &+ allowAlias.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.EnumOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.EnumOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.EnumOptions.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Google.Protobuf.EnumOptions = Google.Protobuf.EnumOptions()
      public func getMessage() -> Google.Protobuf.EnumOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasAllowAlias:Bool {
           get {
                return builderResult.hasAllowAlias
           }
      }
      public var allowAlias:Bool {
           get {
                return builderResult.allowAlias
           }
           set (value) {
               builderResult.hasAllowAlias = true
               builderResult.allowAlias = value
           }
      }
      public func setAllowAlias(_ value:Bool) -> Google.Protobuf.EnumOptions.Builder {
        self.allowAlias = value
        return self
      }
      public func clearAllowAlias() -> Google.Protobuf.EnumOptions.Builder{
           builderResult.hasAllowAlias = false
           builderResult.allowAlias = false
           return self
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.EnumOptions.Builder {
        self.deprecated = value
        return self
      }
      public func clearDeprecated() -> Google.Protobuf.EnumOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.EnumOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      public func clearUninterpretedOption() -> Google.Protobuf.EnumOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.EnumOptions.Builder {
        builderResult = Google.Protobuf.EnumOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.EnumOptions.Builder {
        return try Google.Protobuf.EnumOptions.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.EnumOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.EnumOptions {
        let returnMe:Google.Protobuf.EnumOptions = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.EnumOptions) throws -> Google.Protobuf.EnumOptions.Builder {
        if other == Google.Protobuf.EnumOptions() {
         return self
        }
        if other.hasAllowAlias {
             allowAlias = other.allowAlias
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.EnumOptions.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 16:
            allowAlias = try input.readBool()

          case 24:
            deprecated = try input.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.EnumOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.EnumOptions.Builder()
        if let jsonValueAllowAlias = jsonMap["allowAlias"] as? Bool {
          resultDecodedBuilder.allowAlias = jsonValueAllowAlias
        }
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption += [messageFromStringUninterpretedOption]
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.EnumOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.EnumOptions.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class EnumValueOptions : ExtendableMessage, GeneratedMessageProtocol{
    // Is this enum value deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the enum value, or it will be completely ignored; in the very least,
    // this is a formalization for deprecating enum values.
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasDeprecated {
        try output.writeBool(1, value:deprecated)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try output.writeMessage(999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(1)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.EnumValueOptions> {
      var mergedArray = Array<Google.Protobuf.EnumValueOptions>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.EnumValueOptions? {
      return try Google.Protobuf.EnumValueOptions.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.EnumValueOptions.Builder {
      return Google.Protobuf.EnumValueOptions.classBuilder() as! Google.Protobuf.EnumValueOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.EnumValueOptions.Builder {
      return classBuilder() as! Google.Protobuf.EnumValueOptions.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.EnumValueOptions.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.EnumValueOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.EnumValueOptions.Builder {
      return try Google.Protobuf.EnumValueOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.EnumValueOptions) throws -> Google.Protobuf.EnumValueOptions.Builder {
      return try Google.Protobuf.EnumValueOptions.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,AnyObject>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption += [ecodedMessageUninterpretedOption]
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.EnumValueOptions {
      return try Google.Protobuf.EnumValueOptions.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(536870912), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.EnumValueOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.EnumValueOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.EnumValueOptions.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Google.Protobuf.EnumValueOptions = Google.Protobuf.EnumValueOptions()
      public func getMessage() -> Google.Protobuf.EnumValueOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.EnumValueOptions.Builder {
        self.deprecated = value
        return self
      }
      public func clearDeprecated() -> Google.Protobuf.EnumValueOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.EnumValueOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      public func clearUninterpretedOption() -> Google.Protobuf.EnumValueOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.EnumValueOptions.Builder {
        builderResult = Google.Protobuf.EnumValueOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.EnumValueOptions.Builder {
        return try Google.Protobuf.EnumValueOptions.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.EnumValueOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.EnumValueOptions {
        let returnMe:Google.Protobuf.EnumValueOptions = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.EnumValueOptions) throws -> Google.Protobuf.EnumValueOptions.Builder {
        if other == Google.Protobuf.EnumValueOptions() {
         return self
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.EnumValueOptions.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.EnumValueOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            deprecated = try input.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.EnumValueOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.EnumValueOptions.Builder()
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption += [messageFromStringUninterpretedOption]
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.EnumValueOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.EnumValueOptions.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class ServiceOptions : ExtendableMessage, GeneratedMessageProtocol{
    // Is this service deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the service, or it will be completely ignored; in the very least,
    // this is a formalization for deprecating services.
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasDeprecated {
        try output.writeBool(33, value:deprecated)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try output.writeMessage(999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(33)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.ServiceOptions> {
      var mergedArray = Array<Google.Protobuf.ServiceOptions>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.ServiceOptions? {
      return try Google.Protobuf.ServiceOptions.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.ServiceOptions.Builder {
      return Google.Protobuf.ServiceOptions.classBuilder() as! Google.Protobuf.ServiceOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.ServiceOptions.Builder {
      return classBuilder() as! Google.Protobuf.ServiceOptions.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.ServiceOptions.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.ServiceOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.ServiceOptions.Builder {
      return try Google.Protobuf.ServiceOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.ServiceOptions) throws -> Google.Protobuf.ServiceOptions.Builder {
      return try Google.Protobuf.ServiceOptions.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,AnyObject>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption += [ecodedMessageUninterpretedOption]
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.ServiceOptions {
      return try Google.Protobuf.ServiceOptions.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(536870912), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.ServiceOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.ServiceOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.ServiceOptions.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Google.Protobuf.ServiceOptions = Google.Protobuf.ServiceOptions()
      public func getMessage() -> Google.Protobuf.ServiceOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.ServiceOptions.Builder {
        self.deprecated = value
        return self
      }
      public func clearDeprecated() -> Google.Protobuf.ServiceOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.ServiceOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      public func clearUninterpretedOption() -> Google.Protobuf.ServiceOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.ServiceOptions.Builder {
        builderResult = Google.Protobuf.ServiceOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.ServiceOptions.Builder {
        return try Google.Protobuf.ServiceOptions.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.ServiceOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.ServiceOptions {
        let returnMe:Google.Protobuf.ServiceOptions = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.ServiceOptions) throws -> Google.Protobuf.ServiceOptions.Builder {
        if other == Google.Protobuf.ServiceOptions() {
         return self
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.ServiceOptions.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.ServiceOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 264:
            deprecated = try input.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.ServiceOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.ServiceOptions.Builder()
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption += [messageFromStringUninterpretedOption]
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.ServiceOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.ServiceOptions.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class MethodOptions : ExtendableMessage, GeneratedMessageProtocol{
    // Is this method deprecated?
    // Depending on the target platform, this can emit Deprecated annotations
    // for the method, or it will be completely ignored; in the very least,
    // this is a formalization for deprecating methods.
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitUninterpretedOption:Bool = true
      for oneElementUninterpretedOption in uninterpretedOption {
        if !oneElementUninterpretedOption.isInitialized() {
          isInitUninterpretedOption = false
          break 
        }
      }
      if !isInitUninterpretedOption {
        return isInitUninterpretedOption
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      if hasDeprecated {
        try output.writeBool(33, value:deprecated)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          try output.writeMessage(999, value:oneElementUninterpretedOption)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(33)
      }
      for oneElementUninterpretedOption in uninterpretedOption {
          serialize_size += oneElementUninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.MethodOptions> {
      var mergedArray = Array<Google.Protobuf.MethodOptions>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.MethodOptions? {
      return try Google.Protobuf.MethodOptions.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.MethodOptions.Builder {
      return Google.Protobuf.MethodOptions.classBuilder() as! Google.Protobuf.MethodOptions.Builder
    }
    public func getBuilder() -> Google.Protobuf.MethodOptions.Builder {
      return classBuilder() as! Google.Protobuf.MethodOptions.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.MethodOptions.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.MethodOptions.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.MethodOptions.Builder {
      return try Google.Protobuf.MethodOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.MethodOptions) throws -> Google.Protobuf.MethodOptions.Builder {
      return try Google.Protobuf.MethodOptions.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasDeprecated {
        jsonMap["deprecated"] = deprecated
      }
      if !uninterpretedOption.isEmpty {
        var jsonArrayUninterpretedOption:Array<Dictionary<String,AnyObject>> = []
          for oneValueUninterpretedOption in uninterpretedOption {
            let ecodedMessageUninterpretedOption = try oneValueUninterpretedOption.encode()
            jsonArrayUninterpretedOption += [ecodedMessageUninterpretedOption]
          }
        jsonMap["uninterpretedOption"] = jsonArrayUninterpretedOption
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.MethodOptions {
      return try Google.Protobuf.MethodOptions.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementUninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          output += try oneElementUninterpretedOption.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex += 1
      }
      output += try getExtensionDescription(Int32(1000), endExclusive:Int32(536870912), indent:indent)
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementUninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementUninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.MethodOptions"
    }
    override public func className() -> String {
        return "Google.Protobuf.MethodOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.MethodOptions.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Google.Protobuf.MethodOptions = Google.Protobuf.MethodOptions()
      public func getMessage() -> Google.Protobuf.MethodOptions {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasDeprecated:Bool {
           get {
                return builderResult.hasDeprecated
           }
      }
      public var deprecated:Bool {
           get {
                return builderResult.deprecated
           }
           set (value) {
               builderResult.hasDeprecated = true
               builderResult.deprecated = value
           }
      }
      public func setDeprecated(_ value:Bool) -> Google.Protobuf.MethodOptions.Builder {
        self.deprecated = value
        return self
      }
      public func clearDeprecated() -> Google.Protobuf.MethodOptions.Builder{
           builderResult.hasDeprecated = false
           builderResult.deprecated = false
           return self
      }
      public var uninterpretedOption:Array<Google.Protobuf.UninterpretedOption> {
           get {
               return builderResult.uninterpretedOption
           }
           set (value) {
               builderResult.uninterpretedOption = value
           }
      }
      public func setUninterpretedOption(_ value:Array<Google.Protobuf.UninterpretedOption>) -> Google.Protobuf.MethodOptions.Builder {
        self.uninterpretedOption = value
        return self
      }
      public func clearUninterpretedOption() -> Google.Protobuf.MethodOptions.Builder {
        builderResult.uninterpretedOption.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.MethodOptions.Builder {
        builderResult = Google.Protobuf.MethodOptions()
        return self
      }
      override public func clone() throws -> Google.Protobuf.MethodOptions.Builder {
        return try Google.Protobuf.MethodOptions.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.MethodOptions {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.MethodOptions {
        let returnMe:Google.Protobuf.MethodOptions = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.MethodOptions) throws -> Google.Protobuf.MethodOptions.Builder {
        if other == Google.Protobuf.MethodOptions() {
         return self
        }
        if other.hasDeprecated {
             deprecated = other.deprecated
        }
        if !other.uninterpretedOption.isEmpty  {
           builderResult.uninterpretedOption += other.uninterpretedOption
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.MethodOptions.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.MethodOptions.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 264:
            deprecated = try input.readBool()

          case 7994:
            let subBuilder = Google.Protobuf.UninterpretedOption.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            uninterpretedOption += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.MethodOptions.Builder {
        let resultDecodedBuilder = Google.Protobuf.MethodOptions.Builder()
        if let jsonValueDeprecated = jsonMap["deprecated"] as? Bool {
          resultDecodedBuilder.deprecated = jsonValueDeprecated
        }
        if let jsonValueUninterpretedOption = jsonMap["uninterpretedOption"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayUninterpretedOption:Array<Google.Protobuf.UninterpretedOption> = []
          for oneValueUninterpretedOption in jsonValueUninterpretedOption {
            let messageFromStringUninterpretedOption = try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(oneValueUninterpretedOption).build()

            jsonArrayUninterpretedOption += [messageFromStringUninterpretedOption]
          }
          resultDecodedBuilder.uninterpretedOption = jsonArrayUninterpretedOption
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.MethodOptions.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.MethodOptions.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // A message representing a option the parser does not recognize. This only
  // appears in options protos created by the compiler::Parser class.
  // DescriptorPool resolves these when building Descriptor objects. Therefore,
  // options protos in descriptor objects (e.g. returned by Descriptor::options(),
  // or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
  // in them.
  final public class UninterpretedOption : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      // The name of the uninterpreted option.  Each string represents a segment in
      // a dot-separated name.  is_extension is true iff a segment represents an
      // extension (denoted with parentheses in options specs in .proto files).
      // E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
      // "foo.(bar.baz).qux".
      final public class NamePart : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasNamePart:Bool = false
        public private(set) var namePart:String = ""

        public private(set) var hasIsExtension:Bool = false
        public private(set) var isExtension:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
          if !hasNamePart {
            return false
          }
          if !hasIsExtension {
            return false
          }
         return true
        }
        override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
          if hasNamePart {
            try output.writeString(1, value:namePart)
          }
          if hasIsExtension {
            try output.writeBool(2, value:isExtension)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasNamePart {
            serialize_size += namePart.computeStringSize(1)
          }
          if hasIsExtension {
            serialize_size += isExtension.computeBoolSize(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.UninterpretedOption.NamePart> {
          var mergedArray = Array<Google.Protobuf.UninterpretedOption.NamePart>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.UninterpretedOption.NamePart? {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(_ data:Data) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
          return Google.Protobuf.UninterpretedOption.NamePart.classBuilder() as! Google.Protobuf.UninterpretedOption.NamePart.Builder
        }
        public func getBuilder() -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
          return classBuilder() as! Google.Protobuf.UninterpretedOption.NamePart.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return Google.Protobuf.UninterpretedOption.NamePart.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return Google.Protobuf.UninterpretedOption.NamePart.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
          return try Google.Protobuf.UninterpretedOption.NamePart.builderWithPrototype(self)
        }
        public class func builderWithPrototype(_ prototype:Google.Protobuf.UninterpretedOption.NamePart) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasNamePart {
            jsonMap["namePart"] = namePart
          }
          if hasIsExtension {
            jsonMap["isExtension"] = isExtension
          }
          return jsonMap
        }
        override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.UninterpretedOption.NamePart {
          return try Google.Protobuf.UninterpretedOption.NamePart.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(_ indent:String) throws -> String {
          var output = ""
          if hasNamePart {
            output += "\(indent) namePart: \(namePart) \n"
          }
          if hasIsExtension {
            output += "\(indent) isExtension: \(isExtension) \n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNamePart {
                   hashCode = (hashCode &* 31) &+ namePart.hashValue
                }
                if hasIsExtension {
                   hashCode = (hashCode &* 31) &+ isExtension.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.UninterpretedOption.NamePart"
        }
        override public func className() -> String {
            return "Google.Protobuf.UninterpretedOption.NamePart"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Google.Protobuf.UninterpretedOption.NamePart.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:Google.Protobuf.UninterpretedOption.NamePart = Google.Protobuf.UninterpretedOption.NamePart()
          public func getMessage() -> Google.Protobuf.UninterpretedOption.NamePart {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasNamePart:Bool {
               get {
                    return builderResult.hasNamePart
               }
          }
          public var namePart:String {
               get {
                    return builderResult.namePart
               }
               set (value) {
                   builderResult.hasNamePart = true
                   builderResult.namePart = value
               }
          }
          public func setNamePart(_ value:String) -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            self.namePart = value
            return self
          }
          public func clearNamePart() -> Google.Protobuf.UninterpretedOption.NamePart.Builder{
               builderResult.hasNamePart = false
               builderResult.namePart = ""
               return self
          }
          public var hasIsExtension:Bool {
               get {
                    return builderResult.hasIsExtension
               }
          }
          public var isExtension:Bool {
               get {
                    return builderResult.isExtension
               }
               set (value) {
                   builderResult.hasIsExtension = true
                   builderResult.isExtension = value
               }
          }
          public func setIsExtension(_ value:Bool) -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            self.isExtension = value
            return self
          }
          public func clearIsExtension() -> Google.Protobuf.UninterpretedOption.NamePart.Builder{
               builderResult.hasIsExtension = false
               builderResult.isExtension = false
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            builderResult = Google.Protobuf.UninterpretedOption.NamePart()
            return self
          }
          override public func clone() throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            return try Google.Protobuf.UninterpretedOption.NamePart.builderWithPrototype(builderResult)
          }
          override public func build() throws -> Google.Protobuf.UninterpretedOption.NamePart {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Google.Protobuf.UninterpretedOption.NamePart {
            let returnMe:Google.Protobuf.UninterpretedOption.NamePart = builderResult
            return returnMe
          }
          public func mergeFrom(_ other:Google.Protobuf.UninterpretedOption.NamePart) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            if other == Google.Protobuf.UninterpretedOption.NamePart() {
             return self
            }
            if other.hasNamePart {
                 namePart = other.namePart
            }
            if other.hasIsExtension {
                 isExtension = other.isExtension
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                namePart = try input.readString()

              case 16:
                isExtension = try input.readBool()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            let resultDecodedBuilder = Google.Protobuf.UninterpretedOption.NamePart.Builder()
            if let jsonValueNamePart = jsonMap["namePart"] as? String {
              resultDecodedBuilder.namePart = jsonValueNamePart
            }
            if let jsonValueIsExtension = jsonMap["isExtension"] as? Bool {
              resultDecodedBuilder.isExtension = jsonValueIsExtension
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.UninterpretedOption.NamePart.Builder {
            let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Google.Protobuf.UninterpretedOption.NamePart.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public private(set) var name:Array<NamePart>  = Array<Google.Protobuf.UninterpretedOption.NamePart>()
    // The value of the uninterpreted option, in whatever type the tokenizer
    // identified it as during parsing. Exactly one of these should be set.
    public private(set) var hasIdentifierValue:Bool = false
    public private(set) var identifierValue:String = ""

    public private(set) var hasPositiveIntValue:Bool = false
    public private(set) var positiveIntValue:UInt64 = UInt64(0)

    public private(set) var hasNegativeIntValue:Bool = false
    public private(set) var negativeIntValue:Int64 = Int64(0)

    public private(set) var hasDoubleValue:Bool = false
    public private(set) var doubleValue:Double = Double(0)

    public private(set) var hasStringValue:Bool = false
    public private(set) var stringValue:Data = Data()

    public private(set) var hasAggregateValue:Bool = false
    public private(set) var aggregateValue:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitName:Bool = true
      for oneElementName in name {
        if !oneElementName.isInitialized() {
          isInitName = false
          break 
        }
      }
      if !isInitName {
        return isInitName
      }
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      for oneElementName in name {
          try output.writeMessage(2, value:oneElementName)
      }
      if hasIdentifierValue {
        try output.writeString(3, value:identifierValue)
      }
      if hasPositiveIntValue {
        try output.writeUInt64(4, value:positiveIntValue)
      }
      if hasNegativeIntValue {
        try output.writeInt64(5, value:negativeIntValue)
      }
      if hasDoubleValue {
        try output.writeDouble(6, value:doubleValue)
      }
      if hasStringValue {
        try output.writeData(7, value:stringValue)
      }
      if hasAggregateValue {
        try output.writeString(8, value:aggregateValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementName in name {
          serialize_size += oneElementName.computeMessageSize(2)
      }
      if hasIdentifierValue {
        serialize_size += identifierValue.computeStringSize(3)
      }
      if hasPositiveIntValue {
        serialize_size += positiveIntValue.computeUInt64Size(4)
      }
      if hasNegativeIntValue {
        serialize_size += negativeIntValue.computeInt64Size(5)
      }
      if hasDoubleValue {
        serialize_size += doubleValue.computeDoubleSize(6)
      }
      if hasStringValue {
        serialize_size += stringValue.computeDataSize(7)
      }
      if hasAggregateValue {
        serialize_size += aggregateValue.computeStringSize(8)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.UninterpretedOption> {
      var mergedArray = Array<Google.Protobuf.UninterpretedOption>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.UninterpretedOption? {
      return try Google.Protobuf.UninterpretedOption.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.UninterpretedOption.Builder {
      return Google.Protobuf.UninterpretedOption.classBuilder() as! Google.Protobuf.UninterpretedOption.Builder
    }
    public func getBuilder() -> Google.Protobuf.UninterpretedOption.Builder {
      return classBuilder() as! Google.Protobuf.UninterpretedOption.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.UninterpretedOption.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.UninterpretedOption.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.UninterpretedOption.Builder {
      return try Google.Protobuf.UninterpretedOption.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.UninterpretedOption) throws -> Google.Protobuf.UninterpretedOption.Builder {
      return try Google.Protobuf.UninterpretedOption.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !name.isEmpty {
        var jsonArrayName:Array<Dictionary<String,AnyObject>> = []
          for oneValueName in name {
            let ecodedMessageName = try oneValueName.encode()
            jsonArrayName += [ecodedMessageName]
          }
        jsonMap["name"] = jsonArrayName
      }
      if hasIdentifierValue {
        jsonMap["identifierValue"] = identifierValue
      }
      if hasPositiveIntValue {
        jsonMap["positiveIntValue"] = "\(positiveIntValue)"
      }
      if hasNegativeIntValue {
        jsonMap["negativeIntValue"] = "\(negativeIntValue)"
      }
      if hasDoubleValue {
        jsonMap["doubleValue"] = NSNumber(value:doubleValue)
      }
      if hasStringValue {
        jsonMap["stringValue"] = stringValue.base64EncodedString(NSData.Base64EncodingOptions(rawValue: 0))
      }
      if hasAggregateValue {
        jsonMap["aggregateValue"] = aggregateValue
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.UninterpretedOption {
      return try Google.Protobuf.UninterpretedOption.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      var nameElementIndex:Int = 0
      for oneElementName in name {
          output += "\(indent) name[\(nameElementIndex)] {\n"
          output += try oneElementName.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          nameElementIndex += 1
      }
      if hasIdentifierValue {
        output += "\(indent) identifierValue: \(identifierValue) \n"
      }
      if hasPositiveIntValue {
        output += "\(indent) positiveIntValue: \(positiveIntValue) \n"
      }
      if hasNegativeIntValue {
        output += "\(indent) negativeIntValue: \(negativeIntValue) \n"
      }
      if hasDoubleValue {
        output += "\(indent) doubleValue: \(doubleValue) \n"
      }
      if hasStringValue {
        output += "\(indent) stringValue: \(stringValue) \n"
      }
      if hasAggregateValue {
        output += "\(indent) aggregateValue: \(aggregateValue) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementName in name {
                hashCode = (hashCode &* 31) &+ oneElementName.hashValue
            }
            if hasIdentifierValue {
               hashCode = (hashCode &* 31) &+ identifierValue.hashValue
            }
            if hasPositiveIntValue {
               hashCode = (hashCode &* 31) &+ positiveIntValue.hashValue
            }
            if hasNegativeIntValue {
               hashCode = (hashCode &* 31) &+ negativeIntValue.hashValue
            }
            if hasDoubleValue {
               hashCode = (hashCode &* 31) &+ doubleValue.hashValue
            }
            if hasStringValue {
               hashCode = (hashCode &* 31) &+ stringValue.hashValue
            }
            if hasAggregateValue {
               hashCode = (hashCode &* 31) &+ aggregateValue.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.UninterpretedOption"
    }
    override public func className() -> String {
        return "Google.Protobuf.UninterpretedOption"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.UninterpretedOption.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.UninterpretedOption = Google.Protobuf.UninterpretedOption()
      public func getMessage() -> Google.Protobuf.UninterpretedOption {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var name:Array<Google.Protobuf.UninterpretedOption.NamePart> {
           get {
               return builderResult.name
           }
           set (value) {
               builderResult.name = value
           }
      }
      public func setName(_ value:Array<Google.Protobuf.UninterpretedOption.NamePart>) -> Google.Protobuf.UninterpretedOption.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Google.Protobuf.UninterpretedOption.Builder {
        builderResult.name.removeAll(keepingCapacity: false)
        return self
      }
      public var hasIdentifierValue:Bool {
           get {
                return builderResult.hasIdentifierValue
           }
      }
      public var identifierValue:String {
           get {
                return builderResult.identifierValue
           }
           set (value) {
               builderResult.hasIdentifierValue = true
               builderResult.identifierValue = value
           }
      }
      public func setIdentifierValue(_ value:String) -> Google.Protobuf.UninterpretedOption.Builder {
        self.identifierValue = value
        return self
      }
      public func clearIdentifierValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasIdentifierValue = false
           builderResult.identifierValue = ""
           return self
      }
      public var hasPositiveIntValue:Bool {
           get {
                return builderResult.hasPositiveIntValue
           }
      }
      public var positiveIntValue:UInt64 {
           get {
                return builderResult.positiveIntValue
           }
           set (value) {
               builderResult.hasPositiveIntValue = true
               builderResult.positiveIntValue = value
           }
      }
      public func setPositiveIntValue(_ value:UInt64) -> Google.Protobuf.UninterpretedOption.Builder {
        self.positiveIntValue = value
        return self
      }
      public func clearPositiveIntValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasPositiveIntValue = false
           builderResult.positiveIntValue = UInt64(0)
           return self
      }
      public var hasNegativeIntValue:Bool {
           get {
                return builderResult.hasNegativeIntValue
           }
      }
      public var negativeIntValue:Int64 {
           get {
                return builderResult.negativeIntValue
           }
           set (value) {
               builderResult.hasNegativeIntValue = true
               builderResult.negativeIntValue = value
           }
      }
      public func setNegativeIntValue(_ value:Int64) -> Google.Protobuf.UninterpretedOption.Builder {
        self.negativeIntValue = value
        return self
      }
      public func clearNegativeIntValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasNegativeIntValue = false
           builderResult.negativeIntValue = Int64(0)
           return self
      }
      public var hasDoubleValue:Bool {
           get {
                return builderResult.hasDoubleValue
           }
      }
      public var doubleValue:Double {
           get {
                return builderResult.doubleValue
           }
           set (value) {
               builderResult.hasDoubleValue = true
               builderResult.doubleValue = value
           }
      }
      public func setDoubleValue(_ value:Double) -> Google.Protobuf.UninterpretedOption.Builder {
        self.doubleValue = value
        return self
      }
      public func clearDoubleValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasDoubleValue = false
           builderResult.doubleValue = Double(0)
           return self
      }
      public var hasStringValue:Bool {
           get {
                return builderResult.hasStringValue
           }
      }
      public var stringValue:Data {
           get {
                return builderResult.stringValue
           }
           set (value) {
               builderResult.hasStringValue = true
               builderResult.stringValue = value
           }
      }
      public func setStringValue(_ value:Data) -> Google.Protobuf.UninterpretedOption.Builder {
        self.stringValue = value
        return self
      }
      public func clearStringValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasStringValue = false
           builderResult.stringValue = Data()
           return self
      }
      public var hasAggregateValue:Bool {
           get {
                return builderResult.hasAggregateValue
           }
      }
      public var aggregateValue:String {
           get {
                return builderResult.aggregateValue
           }
           set (value) {
               builderResult.hasAggregateValue = true
               builderResult.aggregateValue = value
           }
      }
      public func setAggregateValue(_ value:String) -> Google.Protobuf.UninterpretedOption.Builder {
        self.aggregateValue = value
        return self
      }
      public func clearAggregateValue() -> Google.Protobuf.UninterpretedOption.Builder{
           builderResult.hasAggregateValue = false
           builderResult.aggregateValue = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.UninterpretedOption.Builder {
        builderResult = Google.Protobuf.UninterpretedOption()
        return self
      }
      override public func clone() throws -> Google.Protobuf.UninterpretedOption.Builder {
        return try Google.Protobuf.UninterpretedOption.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.UninterpretedOption {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.UninterpretedOption {
        let returnMe:Google.Protobuf.UninterpretedOption = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.UninterpretedOption) throws -> Google.Protobuf.UninterpretedOption.Builder {
        if other == Google.Protobuf.UninterpretedOption() {
         return self
        }
        if !other.name.isEmpty  {
           builderResult.name += other.name
        }
        if other.hasIdentifierValue {
             identifierValue = other.identifierValue
        }
        if other.hasPositiveIntValue {
             positiveIntValue = other.positiveIntValue
        }
        if other.hasNegativeIntValue {
             negativeIntValue = other.negativeIntValue
        }
        if other.hasDoubleValue {
             doubleValue = other.doubleValue
        }
        if other.hasStringValue {
             stringValue = other.stringValue
        }
        if other.hasAggregateValue {
             aggregateValue = other.aggregateValue
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.UninterpretedOption.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.UninterpretedOption.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 18:
            let subBuilder = Google.Protobuf.UninterpretedOption.NamePart.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            name += [subBuilder.buildPartial()]

          case 26:
            identifierValue = try input.readString()

          case 32:
            positiveIntValue = try input.readUInt64()

          case 40:
            negativeIntValue = try input.readInt64()

          case 49:
            doubleValue = try input.readDouble()

          case 58:
            stringValue = try input.readData()

          case 66:
            aggregateValue = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.UninterpretedOption.Builder {
        let resultDecodedBuilder = Google.Protobuf.UninterpretedOption.Builder()
        if let jsonValueName = jsonMap["name"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayName:Array<Google.Protobuf.UninterpretedOption.NamePart> = []
          for oneValueName in jsonValueName {
            let messageFromStringName = try Google.Protobuf.UninterpretedOption.NamePart.Builder.decodeToBuilder(oneValueName).build()

            jsonArrayName += [messageFromStringName]
          }
          resultDecodedBuilder.name = jsonArrayName
        }
        if let jsonValueIdentifierValue = jsonMap["identifierValue"] as? String {
          resultDecodedBuilder.identifierValue = jsonValueIdentifierValue
        }
        if let jsonValuePositiveIntValue = jsonMap["positiveIntValue"] as? String {
          resultDecodedBuilder.positiveIntValue = UInt64(jsonValuePositiveIntValue)!
        }
        if let jsonValueNegativeIntValue = jsonMap["negativeIntValue"] as? String {
          resultDecodedBuilder.negativeIntValue = Int64(jsonValueNegativeIntValue)!
        }
        if let jsonValueDoubleValue = jsonMap["doubleValue"] as? NSNumber {
          resultDecodedBuilder.doubleValue = jsonValueDoubleValue.doubleValue
        }
        if let jsonValueStringValue = jsonMap["stringValue"] as? String {
          resultDecodedBuilder.stringValue = Data(base64Encoded:jsonValueStringValue, options: Data.Base64EncodingOptions(rawValue:0))!
        }
        if let jsonValueAggregateValue = jsonMap["aggregateValue"] as? String {
          resultDecodedBuilder.aggregateValue = jsonValueAggregateValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.UninterpretedOption.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.UninterpretedOption.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Encapsulates information about the original source file from which a
  // FileDescriptorProto was generated.
  final public class SourceCodeInfo : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class Location : GeneratedMessage, GeneratedMessageProtocol {
        // Identifies which part of the FileDescriptorProto was defined at this
        // location.
        // Each element is a field number or an index.  They form a path from
        // the root FileDescriptorProto to the place where the definition.  For
        // example, this path:
        //   [ 4, 3, 2, 7, 1 ]
        // refers to:
        //   file.message_type(3)  // 4, 3
        //       .field(7)         // 2, 7
        //       .name()           // 1
        // This is because FileDescriptorProto.message_type has field number 4:
        //   repeated DescriptorProto message_type = 4;
        // and DescriptorProto.field has field number 2:
        //   repeated FieldDescriptorProto field = 2;
        // and FieldDescriptorProto.name has field number 1:
        //   optional string name = 1;
        // Thus, the above path gives the location of a field name.  If we removed
        // the last element:
        //   [ 4, 3, 2, 7 ]
        // this path refers to the whole field declaration (from the beginning
        // of the label to the terminating semicolon).
        public private(set) var path:Array<Int32> = Array<Int32>()
        private var pathMemoizedSerializedSize:Int32 = -1
        // Always has exactly three or four elements: start line, start column,
        // end line (optional, otherwise assumed same as start line), end column.
        // These are packed into a single field for efficiency.  Note that line
        // and column numbers are zero-based -- typically you will want to add
        // 1 to each before displaying to a user.
        public private(set) var span:Array<Int32> = Array<Int32>()
        private var spanMemoizedSerializedSize:Int32 = -1
        // If this SourceCodeInfo represents a complete declaration, these are any
        // comments appearing before and after the declaration which appear to be
        // attached to the declaration.
        // A series of line comments appearing on consecutive lines, with no other
        // tokens appearing on those lines, will be treated as a single comment.
        // leading_detached_comments will keep paragraphs of comments that appear
        // before (but not connected to) the current element. Each paragraph,
        // separated by empty lines, will be one comment element in the repeated
        // field.
        // Only the comment content is provided; comment markers (e.g. //) are
        // stripped out.  For block comments, leading whitespace and an asterisk
        // will be stripped from the beginning of each line other than the first.
        // Newlines are included in the output.
        // Examples:
        //   optional int32 foo = 1;  // Comment attached to foo.
        //   // Comment attached to bar.
        //   optional int32 bar = 2;
        //   optional string baz = 3;
        //   // Comment attached to baz.
        //   // Another line attached to baz.
        //   // Comment attached to qux.
        //   //
        //   // Another line attached to qux.
        //   optional double qux = 4;
        //   // Detached comment for corge. This is not leading or trailing comments
        //   // to qux or corge because there are blank lines separating it from
        //   // both.
        //   // Detached comment for corge paragraph 2.
        //   optional string corge = 5;
        //   /* Block comment attached
        //    * to corge.  Leading asterisks
        //    * will be removed. */
        //   /* Block comment attached to
        //    * grault. */
        //   optional int32 grault = 6;
        //   // ignored detached comments.
        public private(set) var hasLeadingComments:Bool = false
        public private(set) var leadingComments:String = ""

        public private(set) var hasTrailingComments:Bool = false
        public private(set) var trailingComments:String = ""

        public private(set) var leadingDetachedComments:Array<String> = Array<String>()
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
          if !path.isEmpty {
            try output.writeRawVarint32(10)
            try output.writeRawVarint32(pathMemoizedSerializedSize)
            for oneValuepath in path {
              try output.writeInt32NoTag(oneValuepath)
            }
          }
          if !span.isEmpty {
            try output.writeRawVarint32(18)
            try output.writeRawVarint32(spanMemoizedSerializedSize)
            for oneValuespan in span {
              try output.writeInt32NoTag(oneValuespan)
            }
          }
          if hasLeadingComments {
            try output.writeString(3, value:leadingComments)
          }
          if hasTrailingComments {
            try output.writeString(4, value:trailingComments)
          }
          if !leadingDetachedComments.isEmpty {
            for oneValueleadingDetachedComments in leadingDetachedComments {
              try output.writeString(6, value:oneValueleadingDetachedComments)
            }
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          var dataSizePath:Int32 = 0
          for oneValuepath in path {
              dataSizePath += oneValuepath.computeInt32SizeNoTag()
          }
          serialize_size += dataSizePath
          if !path.isEmpty {
            serialize_size += 1
            serialize_size += dataSizePath.computeInt32SizeNoTag()
          }
          pathMemoizedSerializedSize = dataSizePath
          var dataSizeSpan:Int32 = 0
          for oneValuespan in span {
              dataSizeSpan += oneValuespan.computeInt32SizeNoTag()
          }
          serialize_size += dataSizeSpan
          if !span.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeSpan.computeInt32SizeNoTag()
          }
          spanMemoizedSerializedSize = dataSizeSpan
          if hasLeadingComments {
            serialize_size += leadingComments.computeStringSize(3)
          }
          if hasTrailingComments {
            serialize_size += trailingComments.computeStringSize(4)
          }
          var dataSizeLeadingDetachedComments:Int32 = 0
          for oneValueleadingDetachedComments in leadingDetachedComments {
              dataSizeLeadingDetachedComments += oneValueleadingDetachedComments.computeStringSizeNoTag()
          }
          serialize_size += dataSizeLeadingDetachedComments
          serialize_size += 1 * Int32(leadingDetachedComments.count)
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.SourceCodeInfo.Location> {
          var mergedArray = Array<Google.Protobuf.SourceCodeInfo.Location>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.SourceCodeInfo.Location? {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(_ data:Data) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
          return Google.Protobuf.SourceCodeInfo.Location.classBuilder() as! Google.Protobuf.SourceCodeInfo.Location.Builder
        }
        public func getBuilder() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
          return classBuilder() as! Google.Protobuf.SourceCodeInfo.Location.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return Google.Protobuf.SourceCodeInfo.Location.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return Google.Protobuf.SourceCodeInfo.Location.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
          return try Google.Protobuf.SourceCodeInfo.Location.builderWithPrototype(self)
        }
        public class func builderWithPrototype(_ prototype:Google.Protobuf.SourceCodeInfo.Location) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if !path.isEmpty {
            var jsonArrayPath:Array<NSNumber> = []
              for oneValuePath in path {
                jsonArrayPath += [NSNumber(value:oneValuePath)]
              }
            jsonMap["path"] = jsonArrayPath
          }
          if !span.isEmpty {
            var jsonArraySpan:Array<NSNumber> = []
              for oneValueSpan in span {
                jsonArraySpan += [NSNumber(value:oneValueSpan)]
              }
            jsonMap["span"] = jsonArraySpan
          }
          if hasLeadingComments {
            jsonMap["leadingComments"] = leadingComments
          }
          if hasTrailingComments {
            jsonMap["trailingComments"] = trailingComments
          }
          if !leadingDetachedComments.isEmpty {
            jsonMap["leadingDetachedComments"] = leadingDetachedComments
          }
          return jsonMap
        }
        override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.SourceCodeInfo.Location {
          return try Google.Protobuf.SourceCodeInfo.Location.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(_ indent:String) throws -> String {
          var output = ""
          var pathElementIndex:Int = 0
          for oneValuePath in path  {
              output += "\(indent) path[\(pathElementIndex)]: \(oneValuePath)\n"
              pathElementIndex += 1
          }
          var spanElementIndex:Int = 0
          for oneValueSpan in span  {
              output += "\(indent) span[\(spanElementIndex)]: \(oneValueSpan)\n"
              spanElementIndex += 1
          }
          if hasLeadingComments {
            output += "\(indent) leadingComments: \(leadingComments) \n"
          }
          if hasTrailingComments {
            output += "\(indent) trailingComments: \(trailingComments) \n"
          }
          var leadingDetachedCommentsElementIndex:Int = 0
          for oneValueLeadingDetachedComments in leadingDetachedComments  {
              output += "\(indent) leadingDetachedComments[\(leadingDetachedCommentsElementIndex)]: \(oneValueLeadingDetachedComments)\n"
              leadingDetachedCommentsElementIndex += 1
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValuePath in path {
                    hashCode = (hashCode &* 31) &+ oneValuePath.hashValue
                }
                for oneValueSpan in span {
                    hashCode = (hashCode &* 31) &+ oneValueSpan.hashValue
                }
                if hasLeadingComments {
                   hashCode = (hashCode &* 31) &+ leadingComments.hashValue
                }
                if hasTrailingComments {
                   hashCode = (hashCode &* 31) &+ trailingComments.hashValue
                }
                for oneValueLeadingDetachedComments in leadingDetachedComments {
                    hashCode = (hashCode &* 31) &+ oneValueLeadingDetachedComments.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.SourceCodeInfo.Location"
        }
        override public func className() -> String {
            return "Google.Protobuf.SourceCodeInfo.Location"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Google.Protobuf.SourceCodeInfo.Location.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:Google.Protobuf.SourceCodeInfo.Location = Google.Protobuf.SourceCodeInfo.Location()
          public func getMessage() -> Google.Protobuf.SourceCodeInfo.Location {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var path:Array<Int32> {
               get {
                   return builderResult.path
               }
               set (array) {
                   builderResult.path = array
               }
          }
          public func setPath(_ value:Array<Int32>) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.path = value
            return self
          }
          public func clearPath() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
             builderResult.path.removeAll(keepingCapacity: false)
             return self
          }
          public var span:Array<Int32> {
               get {
                   return builderResult.span
               }
               set (array) {
                   builderResult.span = array
               }
          }
          public func setSpan(_ value:Array<Int32>) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.span = value
            return self
          }
          public func clearSpan() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
             builderResult.span.removeAll(keepingCapacity: false)
             return self
          }
          public var hasLeadingComments:Bool {
               get {
                    return builderResult.hasLeadingComments
               }
          }
          public var leadingComments:String {
               get {
                    return builderResult.leadingComments
               }
               set (value) {
                   builderResult.hasLeadingComments = true
                   builderResult.leadingComments = value
               }
          }
          public func setLeadingComments(_ value:String) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.leadingComments = value
            return self
          }
          public func clearLeadingComments() -> Google.Protobuf.SourceCodeInfo.Location.Builder{
               builderResult.hasLeadingComments = false
               builderResult.leadingComments = ""
               return self
          }
          public var hasTrailingComments:Bool {
               get {
                    return builderResult.hasTrailingComments
               }
          }
          public var trailingComments:String {
               get {
                    return builderResult.trailingComments
               }
               set (value) {
                   builderResult.hasTrailingComments = true
                   builderResult.trailingComments = value
               }
          }
          public func setTrailingComments(_ value:String) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.trailingComments = value
            return self
          }
          public func clearTrailingComments() -> Google.Protobuf.SourceCodeInfo.Location.Builder{
               builderResult.hasTrailingComments = false
               builderResult.trailingComments = ""
               return self
          }
          public var leadingDetachedComments:Array<String> {
               get {
                   return builderResult.leadingDetachedComments
               }
               set (array) {
                   builderResult.leadingDetachedComments = array
               }
          }
          public func setLeadingDetachedComments(_ value:Array<String>) -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            self.leadingDetachedComments = value
            return self
          }
          public func clearLeadingDetachedComments() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
             builderResult.leadingDetachedComments.removeAll(keepingCapacity: false)
             return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            builderResult = Google.Protobuf.SourceCodeInfo.Location()
            return self
          }
          override public func clone() throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            return try Google.Protobuf.SourceCodeInfo.Location.builderWithPrototype(builderResult)
          }
          override public func build() throws -> Google.Protobuf.SourceCodeInfo.Location {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Google.Protobuf.SourceCodeInfo.Location {
            let returnMe:Google.Protobuf.SourceCodeInfo.Location = builderResult
            return returnMe
          }
          public func mergeFrom(_ other:Google.Protobuf.SourceCodeInfo.Location) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            if other == Google.Protobuf.SourceCodeInfo.Location() {
             return self
            }
            if !other.path.isEmpty {
                builderResult.path += other.path
            }
            if !other.span.isEmpty {
                builderResult.span += other.span
            }
            if other.hasLeadingComments {
                 leadingComments = other.leadingComments
            }
            if other.hasTrailingComments {
                 trailingComments = other.trailingComments
            }
            if !other.leadingDetachedComments.isEmpty {
                builderResult.leadingDetachedComments += other.leadingDetachedComments
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                let length:Int32 = try input.readRawVarint32()
                let limit:Int32 = try input.pushLimit(length)
                while (input.bytesUntilLimit() > 0) {
                  builderResult.path += [try input.readInt32()]
                }
                input.popLimit(limit)

              case 18:
                let length:Int32 = try input.readRawVarint32()
                let limit:Int32 = try input.pushLimit(length)
                while (input.bytesUntilLimit() > 0) {
                  builderResult.span += [try input.readInt32()]
                }
                input.popLimit(limit)

              case 26:
                leadingComments = try input.readString()

              case 34:
                trailingComments = try input.readString()

              case 50:
                leadingDetachedComments += [try input.readString()]

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            let resultDecodedBuilder = Google.Protobuf.SourceCodeInfo.Location.Builder()
            if let jsonValuePath = jsonMap["path"] as? Array<NSNumber> {
              var jsonArrayPath:Array<Int32> = []
              for oneValuePath in jsonValuePath {
                jsonArrayPath += [oneValuePath.int32Value]
              }
              resultDecodedBuilder.path = jsonArrayPath
            }
            if let jsonValueSpan = jsonMap["span"] as? Array<NSNumber> {
              var jsonArraySpan:Array<Int32> = []
              for oneValueSpan in jsonValueSpan {
                jsonArraySpan += [oneValueSpan.int32Value]
              }
              resultDecodedBuilder.span = jsonArraySpan
            }
            if let jsonValueLeadingComments = jsonMap["leadingComments"] as? String {
              resultDecodedBuilder.leadingComments = jsonValueLeadingComments
            }
            if let jsonValueTrailingComments = jsonMap["trailingComments"] as? String {
              resultDecodedBuilder.trailingComments = jsonValueTrailingComments
            }
            if let jsonValueLeadingDetachedComments = jsonMap["leadingDetachedComments"] as? Array<String> {
              resultDecodedBuilder.leadingDetachedComments = jsonValueLeadingDetachedComments
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.SourceCodeInfo.Location.Builder {
            let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Google.Protobuf.SourceCodeInfo.Location.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public private(set) var location:Array<Location>  = Array<Google.Protobuf.SourceCodeInfo.Location>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(_ output:CodedOutputStream) throws {
      for oneElementLocation in location {
          try output.writeMessage(1, value:oneElementLocation)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementLocation in location {
          serialize_size += oneElementLocation.computeMessageSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(_ input:InputStream) throws -> Array<Google.Protobuf.SourceCodeInfo> {
      var mergedArray = Array<Google.Protobuf.SourceCodeInfo>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(_ input:InputStream) throws -> Google.Protobuf.SourceCodeInfo? {
      return try Google.Protobuf.SourceCodeInfo.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(_ data:Data) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(_ data:Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(_ input:InputStream) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(_ input:InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Google.Protobuf.SourceCodeInfo.Builder {
      return Google.Protobuf.SourceCodeInfo.classBuilder() as! Google.Protobuf.SourceCodeInfo.Builder
    }
    public func getBuilder() -> Google.Protobuf.SourceCodeInfo.Builder {
      return classBuilder() as! Google.Protobuf.SourceCodeInfo.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Google.Protobuf.SourceCodeInfo.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Google.Protobuf.SourceCodeInfo.Builder()
    }
    public func toBuilder() throws -> Google.Protobuf.SourceCodeInfo.Builder {
      return try Google.Protobuf.SourceCodeInfo.builderWithPrototype(self)
    }
    public class func builderWithPrototype(_ prototype:Google.Protobuf.SourceCodeInfo) throws -> Google.Protobuf.SourceCodeInfo.Builder {
      return try Google.Protobuf.SourceCodeInfo.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !location.isEmpty {
        var jsonArrayLocation:Array<Dictionary<String,AnyObject>> = []
          for oneValueLocation in location {
            let ecodedMessageLocation = try oneValueLocation.encode()
            jsonArrayLocation += [ecodedMessageLocation]
          }
        jsonMap["location"] = jsonArrayLocation
      }
      return jsonMap
    }
    override class public func decode(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(_ data:Data) throws -> Google.Protobuf.SourceCodeInfo {
      return try Google.Protobuf.SourceCodeInfo.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(_ indent:String) throws -> String {
      var output = ""
      var locationElementIndex:Int = 0
      for oneElementLocation in location {
          output += "\(indent) location[\(locationElementIndex)] {\n"
          output += try oneElementLocation.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          locationElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementLocation in location {
                hashCode = (hashCode &* 31) &+ oneElementLocation.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Google.Protobuf.SourceCodeInfo"
    }
    override public func className() -> String {
        return "Google.Protobuf.SourceCodeInfo"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Google.Protobuf.SourceCodeInfo.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Google.Protobuf.SourceCodeInfo = Google.Protobuf.SourceCodeInfo()
      public func getMessage() -> Google.Protobuf.SourceCodeInfo {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var location:Array<Google.Protobuf.SourceCodeInfo.Location> {
           get {
               return builderResult.location
           }
           set (value) {
               builderResult.location = value
           }
      }
      public func setLocation(_ value:Array<Google.Protobuf.SourceCodeInfo.Location>) -> Google.Protobuf.SourceCodeInfo.Builder {
        self.location = value
        return self
      }
      public func clearLocation() -> Google.Protobuf.SourceCodeInfo.Builder {
        builderResult.location.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Google.Protobuf.SourceCodeInfo.Builder {
        builderResult = Google.Protobuf.SourceCodeInfo()
        return self
      }
      override public func clone() throws -> Google.Protobuf.SourceCodeInfo.Builder {
        return try Google.Protobuf.SourceCodeInfo.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Google.Protobuf.SourceCodeInfo {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Google.Protobuf.SourceCodeInfo {
        let returnMe:Google.Protobuf.SourceCodeInfo = builderResult
        return returnMe
      }
      public func mergeFrom(_ other:Google.Protobuf.SourceCodeInfo) throws -> Google.Protobuf.SourceCodeInfo.Builder {
        if other == Google.Protobuf.SourceCodeInfo() {
         return self
        }
        if !other.location.isEmpty  {
           builderResult.location += other.location
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream) throws -> Google.Protobuf.SourceCodeInfo.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(_ input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.SourceCodeInfo.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Google.Protobuf.SourceCodeInfo.Location.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            location += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(_ jsonMap:Dictionary<String,AnyObject>) throws -> Google.Protobuf.SourceCodeInfo.Builder {
        let resultDecodedBuilder = Google.Protobuf.SourceCodeInfo.Builder()
        if let jsonValueLocation = jsonMap["location"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayLocation:Array<Google.Protobuf.SourceCodeInfo.Location> = []
          for oneValueLocation in jsonValueLocation {
            let messageFromStringLocation = try Google.Protobuf.SourceCodeInfo.Location.Builder.decodeToBuilder(oneValueLocation).build()

            jsonArrayLocation += [messageFromStringLocation]
          }
          resultDecodedBuilder.location = jsonArrayLocation
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(_ data:Data) throws -> Google.Protobuf.SourceCodeInfo.Builder {
        let jsonData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Google.Protobuf.SourceCodeInfo.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
