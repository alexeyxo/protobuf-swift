/// Generated by the Protocol Buffers 3.4.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "api.proto"
/// Syntax "Proto3"

import Foundation

public extension Google.Protobuf{}

public extension Google.Protobuf {
    public struct ApiRoot {
        public static let `default` = ApiRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Google.Protobuf.SwiftDescriptorRoot.default.registerAllExtensions(registry: extensionRegistry)
            Google.Protobuf.SourceContextRoot.default.registerAllExtensions(registry: extensionRegistry)
            Google.Protobuf.TypeRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Api is a light-weight descriptor for a protocol buffer service.
    final public class Api : GeneratedMessage {
        public typealias BuilderType = Google.Protobuf.Api.Builder

        public static func == (lhs: Google.Protobuf.Api, rhs: Google.Protobuf.Api) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.methods == rhs.methods)
            fieldCheck = fieldCheck && (lhs.options == rhs.options)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = fieldCheck && (lhs.hasSourceContext == rhs.hasSourceContext) && (!lhs.hasSourceContext || lhs.sourceContext == rhs.sourceContext)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The fully qualified name of this api, including package name
        /// followed by the api's simple name.
        public fileprivate(set) var name:String! = nil
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var methods:Array<Google.Protobuf.Method>  = Array<Google.Protobuf.Method>()
        public fileprivate(set) var options:Array<Google.Protobuf.Option>  = Array<Google.Protobuf.Option>()
        /// A version string for this api. If specified, must have the form
        /// `major-version.minor-version`, as in `1.10`. If the minor version
        /// is omitted, it defaults to zero. If the entire version field is
        /// empty, the major version is derived from the package name, as
        /// outlined below. If the field is not empty, the version in the
        /// package name will be verified to be consistent with what is
        /// provided here.
        /// The versioning schema uses [semantic
        /// versioning](http://semver.org) where the major version number
        /// indicates a breaking change and the minor version an additive,
        /// non-breaking change. Both version numbers are signals to users
        /// what to expect from different versions, and should be carefully
        /// chosen based on the product plan.
        /// The major version is also reflected in the package name of the
        /// API, which must end in `v<major-version>`, as in
        /// `google.feature.v1`. For major versions 0 and 1, the suffix can
        /// be omitted. Zero major versions must only be used for
        /// experimental, none-GA apis.
        /// See also: [design doc](http://go/api-versioning).
        public fileprivate(set) var version:String! = nil
        public fileprivate(set) var hasVersion:Bool = false

        public fileprivate(set) var sourceContext:Google.Protobuf.SourceContext!
        public fileprivate(set) var hasSourceContext:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            for oneElementMethods in methods {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementMethods)
            }
            for oneElementOptions in options {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementOptions)
            }
            if hasVersion {
                try codedOutputStream.writeString(fieldNumber: 4, value:version)
            }
            if hasSourceContext {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:sourceContext)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            for oneElementMethods in methods {
                serialize_size += oneElementMethods.computeMessageSize(fieldNumber: 2)
            }
            for oneElementOptions in options {
                serialize_size += oneElementOptions.computeMessageSize(fieldNumber: 3)
            }
            if hasVersion {
                serialize_size += version.computeStringSize(fieldNumber: 4)
            }
            if hasSourceContext {
                if let varSizesourceContext = sourceContext?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizesourceContext
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.Api.Builder {
            return Google.Protobuf.Api.classBuilder() as! Google.Protobuf.Api.Builder
        }
        public func getBuilder() -> Google.Protobuf.Api.Builder {
            return classBuilder() as! Google.Protobuf.Api.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Api.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Api.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.Api.Builder {
            return try Google.Protobuf.Api.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.Api) throws -> Google.Protobuf.Api.Builder {
            return try Google.Protobuf.Api.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if !methods.isEmpty {
                var jsonArrayMethods:Array<Dictionary<String,Any>> = []
                for oneValueMethods in methods {
                    let ecodedMessageMethods = try oneValueMethods.encode()
                    jsonArrayMethods.append(ecodedMessageMethods)
                }
                jsonMap["methods"] = jsonArrayMethods
            }
            if !options.isEmpty {
                var jsonArrayOptions:Array<Dictionary<String,Any>> = []
                for oneValueOptions in options {
                    let ecodedMessageOptions = try oneValueOptions.encode()
                    jsonArrayOptions.append(ecodedMessageOptions)
                }
                jsonMap["options"] = jsonArrayOptions
            }
            if hasVersion {
                jsonMap["version"] = version
            }
            if hasSourceContext {
                jsonMap["sourceContext"] = try sourceContext.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Api {
            return try Google.Protobuf.Api.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.Api {
            return try Google.Protobuf.Api.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            var methodsElementIndex:Int = 0
            for oneElementMethods in methods {
                output += "\(indent) methods[\(methodsElementIndex)] {\n"
                output += try oneElementMethods.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                methodsElementIndex += 1
            }
            var optionsElementIndex:Int = 0
            for oneElementOptions in options {
                output += "\(indent) options[\(optionsElementIndex)] {\n"
                output += try oneElementOptions.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                optionsElementIndex += 1
            }
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            if hasSourceContext {
                output += "\(indent) sourceContext {\n"
                if let outDescSourceContext = sourceContext {
                    output += try outDescSourceContext.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                for oneElementMethods in methods {
                    hashCode = (hashCode &* 31) &+ oneElementMethods.hashValue
                }
                for oneElementOptions in options {
                    hashCode = (hashCode &* 31) &+ oneElementOptions.hashValue
                }
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                if hasSourceContext {
                    if let hashValuesourceContext = sourceContext?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesourceContext
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.Api"
        }
        override public func className() -> String {
            return "Google.Protobuf.Api"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Google.Protobuf.Api = Google.Protobuf.Api()
            public func getMessage() -> Google.Protobuf.Api {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The fully qualified name of this api, including package name
            /// followed by the api's simple name.
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Google.Protobuf.Api.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Google.Protobuf.Api.Builder{
                builderResult.hasName = false
                builderResult.name = nil
                return self
            }
            /// The methods of this api, in unspecified order.
            public var methods:Array<Google.Protobuf.Method> {
                get {
                    return builderResult.methods
                }
                set (value) {
                    builderResult.methods = value
                }
            }
            @discardableResult
            public func setMethods(_ value:Array<Google.Protobuf.Method>) -> Google.Protobuf.Api.Builder {
                self.methods = value
                return self
            }
            @discardableResult
            public func clearMethods() -> Google.Protobuf.Api.Builder {
                builderResult.methods.removeAll(keepingCapacity: false)
                return self
            }
            /// Any metadata attached to the API.
            public var options:Array<Google.Protobuf.Option> {
                get {
                    return builderResult.options
                }
                set (value) {
                    builderResult.options = value
                }
            }
            @discardableResult
            public func setOptions(_ value:Array<Google.Protobuf.Option>) -> Google.Protobuf.Api.Builder {
                self.options = value
                return self
            }
            @discardableResult
            public func clearOptions() -> Google.Protobuf.Api.Builder {
                builderResult.options.removeAll(keepingCapacity: false)
                return self
            }
            /// A version string for this api. If specified, must have the form
            /// `major-version.minor-version`, as in `1.10`. If the minor version
            /// is omitted, it defaults to zero. If the entire version field is
            /// empty, the major version is derived from the package name, as
            /// outlined below. If the field is not empty, the version in the
            /// package name will be verified to be consistent with what is
            /// provided here.
            /// The versioning schema uses [semantic
            /// versioning](http://semver.org) where the major version number
            /// indicates a breaking change and the minor version an additive,
            /// non-breaking change. Both version numbers are signals to users
            /// what to expect from different versions, and should be carefully
            /// chosen based on the product plan.
            /// The major version is also reflected in the package name of the
            /// API, which must end in `v<major-version>`, as in
            /// `google.feature.v1`. For major versions 0 and 1, the suffix can
            /// be omitted. Zero major versions must only be used for
            /// experimental, none-GA apis.
            /// See also: [design doc](http://go/api-versioning).
            public var version:String {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:String) -> Google.Protobuf.Api.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Google.Protobuf.Api.Builder{
                builderResult.hasVersion = false
                builderResult.version = nil
                return self
            }
            /// Source context for the protocol buffer service represented by this
            /// message.
            public var sourceContext:Google.Protobuf.SourceContext! {
                get {
                    if sourceContextBuilder_ != nil {
                        builderResult.sourceContext = sourceContextBuilder_.getMessage()
                    }
                    return builderResult.sourceContext
                }
                set (value) {
                    builderResult.hasSourceContext = true
                    builderResult.sourceContext = value
                }
            }
            public var hasSourceContext:Bool {
                get {
                    return builderResult.hasSourceContext
                }
            }
            fileprivate var sourceContextBuilder_:Google.Protobuf.SourceContext.Builder! {
                didSet {
                    builderResult.hasSourceContext = true
                }
            }
            public func getSourceContextBuilder() -> Google.Protobuf.SourceContext.Builder {
                if sourceContextBuilder_ == nil {
                    sourceContextBuilder_ = Google.Protobuf.SourceContext.Builder()
                    builderResult.sourceContext = sourceContextBuilder_.getMessage()
                    if sourceContext != nil {
                        try! sourceContextBuilder_.mergeFrom(other: sourceContext)
                    }
                }
                return sourceContextBuilder_
            }
            @discardableResult
            public func setSourceContext(_ value:Google.Protobuf.SourceContext!) -> Google.Protobuf.Api.Builder {
                self.sourceContext = value
                return self
            }
            @discardableResult
            public func mergeSourceContext(value:Google.Protobuf.SourceContext) throws -> Google.Protobuf.Api.Builder {
                if builderResult.hasSourceContext {
                    builderResult.sourceContext = try Google.Protobuf.SourceContext.builderWithPrototype(prototype:builderResult.sourceContext).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.sourceContext = value
                }
                builderResult.hasSourceContext = true
                return self
            }
            @discardableResult
            public func clearSourceContext() -> Google.Protobuf.Api.Builder {
                sourceContextBuilder_ = nil
                builderResult.hasSourceContext = false
                builderResult.sourceContext = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Google.Protobuf.Api.Builder {
                builderResult = Google.Protobuf.Api()
                return self
            }
            override public func clone() throws -> Google.Protobuf.Api.Builder {
                return try Google.Protobuf.Api.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Google.Protobuf.Api {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Google.Protobuf.Api {
                let returnMe:Google.Protobuf.Api = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Google.Protobuf.Api) throws -> Google.Protobuf.Api.Builder {
                if other == Google.Protobuf.Api() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if !other.methods.isEmpty  {
                     builderResult.methods += other.methods
                }
                if !other.options.isEmpty  {
                     builderResult.options += other.options
                }
                if other.hasVersion {
                    version = other.version
                }
                if (other.hasSourceContext) {
                    try mergeSourceContext(value: other.sourceContext)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Api.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Api.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        let subBuilder = Google.Protobuf.Method.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        methods.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder = Google.Protobuf.Option.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        options.append(subBuilder.buildPartial())

                    case 34:
                        version = try codedInputStream.readString()

                    case 42:
                        let subBuilder:Google.Protobuf.SourceContext.Builder = Google.Protobuf.SourceContext.Builder()
                        if hasSourceContext {
                            try subBuilder.mergeFrom(other: sourceContext)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        sourceContext = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Api.Builder {
                let resultDecodedBuilder = Google.Protobuf.Api.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueMethods = jsonMap["methods"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayMethods:Array<Google.Protobuf.Method> = []
                    for oneValueMethods in jsonValueMethods {
                        let messageFromStringMethods = try Google.Protobuf.Method.Builder.decodeToBuilder(jsonMap:oneValueMethods).build()

                        jsonArrayMethods.append(messageFromStringMethods)
                    }
                    resultDecodedBuilder.methods = jsonArrayMethods
                }
                if let jsonValueOptions = jsonMap["options"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOptions:Array<Google.Protobuf.Option> = []
                    for oneValueOptions in jsonValueOptions {
                        let messageFromStringOptions = try Google.Protobuf.Option.Builder.decodeToBuilder(jsonMap:oneValueOptions).build()

                        jsonArrayOptions.append(messageFromStringOptions)
                    }
                    resultDecodedBuilder.options = jsonArrayOptions
                }
                if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = jsonValueVersion
                }
                if let jsonValueSourceContext = jsonMap["sourceContext"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.sourceContext = try Google.Protobuf.SourceContext.Builder.decodeToBuilder(jsonMap:jsonValueSourceContext).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.Api.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Google.Protobuf.Api.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Method represents a method of an api.
    final public class Method : GeneratedMessage {
        public typealias BuilderType = Google.Protobuf.Method.Builder

        public static func == (lhs: Google.Protobuf.Method, rhs: Google.Protobuf.Method) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasRequestTypeUrl == rhs.hasRequestTypeUrl) && (!lhs.hasRequestTypeUrl || lhs.requestTypeUrl == rhs.requestTypeUrl)
            fieldCheck = fieldCheck && (lhs.hasRequestStreaming == rhs.hasRequestStreaming) && (!lhs.hasRequestStreaming || lhs.requestStreaming == rhs.requestStreaming)
            fieldCheck = fieldCheck && (lhs.hasResponseTypeUrl == rhs.hasResponseTypeUrl) && (!lhs.hasResponseTypeUrl || lhs.responseTypeUrl == rhs.responseTypeUrl)
            fieldCheck = fieldCheck && (lhs.hasResponseStreaming == rhs.hasResponseStreaming) && (!lhs.hasResponseStreaming || lhs.responseStreaming == rhs.responseStreaming)
            fieldCheck = fieldCheck && (lhs.options == rhs.options)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The simple name of this method.
        public fileprivate(set) var name:String! = nil
        public fileprivate(set) var hasName:Bool = false

        /// A URL of the input message type.
        public fileprivate(set) var requestTypeUrl:String! = nil
        public fileprivate(set) var hasRequestTypeUrl:Bool = false

        /// If true, the request is streamed.
        public fileprivate(set) var requestStreaming:Bool! = nil
        public fileprivate(set) var hasRequestStreaming:Bool = false

        /// The URL of the output message type.
        public fileprivate(set) var responseTypeUrl:String! = nil
        public fileprivate(set) var hasResponseTypeUrl:Bool = false

        /// If true, the response is streamed.
        public fileprivate(set) var responseStreaming:Bool! = nil
        public fileprivate(set) var hasResponseStreaming:Bool = false

        public fileprivate(set) var options:Array<Google.Protobuf.Option>  = Array<Google.Protobuf.Option>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            if hasRequestTypeUrl {
                try codedOutputStream.writeString(fieldNumber: 2, value:requestTypeUrl)
            }
            if hasRequestStreaming {
                try codedOutputStream.writeBool(fieldNumber: 3, value:requestStreaming)
            }
            if hasResponseTypeUrl {
                try codedOutputStream.writeString(fieldNumber: 4, value:responseTypeUrl)
            }
            if hasResponseStreaming {
                try codedOutputStream.writeBool(fieldNumber: 5, value:responseStreaming)
            }
            for oneElementOptions in options {
                  try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementOptions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            if hasRequestTypeUrl {
                serialize_size += requestTypeUrl.computeStringSize(fieldNumber: 2)
            }
            if hasRequestStreaming {
                serialize_size += requestStreaming.computeBoolSize(fieldNumber: 3)
            }
            if hasResponseTypeUrl {
                serialize_size += responseTypeUrl.computeStringSize(fieldNumber: 4)
            }
            if hasResponseStreaming {
                serialize_size += responseStreaming.computeBoolSize(fieldNumber: 5)
            }
            for oneElementOptions in options {
                serialize_size += oneElementOptions.computeMessageSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.Method.Builder {
            return Google.Protobuf.Method.classBuilder() as! Google.Protobuf.Method.Builder
        }
        public func getBuilder() -> Google.Protobuf.Method.Builder {
            return classBuilder() as! Google.Protobuf.Method.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Method.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Method.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.Method.Builder {
            return try Google.Protobuf.Method.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.Method) throws -> Google.Protobuf.Method.Builder {
            return try Google.Protobuf.Method.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            if hasRequestTypeUrl {
                jsonMap["requestTypeUrl"] = requestTypeUrl
            }
            if hasRequestStreaming {
                jsonMap["requestStreaming"] = requestStreaming
            }
            if hasResponseTypeUrl {
                jsonMap["responseTypeUrl"] = responseTypeUrl
            }
            if hasResponseStreaming {
                jsonMap["responseStreaming"] = responseStreaming
            }
            if !options.isEmpty {
                var jsonArrayOptions:Array<Dictionary<String,Any>> = []
                for oneValueOptions in options {
                    let ecodedMessageOptions = try oneValueOptions.encode()
                    jsonArrayOptions.append(ecodedMessageOptions)
                }
                jsonMap["options"] = jsonArrayOptions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Method {
            return try Google.Protobuf.Method.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.Method {
            return try Google.Protobuf.Method.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasRequestTypeUrl {
                output += "\(indent) requestTypeUrl: \(requestTypeUrl) \n"
            }
            if hasRequestStreaming {
                output += "\(indent) requestStreaming: \(requestStreaming) \n"
            }
            if hasResponseTypeUrl {
                output += "\(indent) responseTypeUrl: \(responseTypeUrl) \n"
            }
            if hasResponseStreaming {
                output += "\(indent) responseStreaming: \(responseStreaming) \n"
            }
            var optionsElementIndex:Int = 0
            for oneElementOptions in options {
                output += "\(indent) options[\(optionsElementIndex)] {\n"
                output += try oneElementOptions.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                optionsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasRequestTypeUrl {
                    hashCode = (hashCode &* 31) &+ requestTypeUrl.hashValue
                }
                if hasRequestStreaming {
                    hashCode = (hashCode &* 31) &+ requestStreaming.hashValue
                }
                if hasResponseTypeUrl {
                    hashCode = (hashCode &* 31) &+ responseTypeUrl.hashValue
                }
                if hasResponseStreaming {
                    hashCode = (hashCode &* 31) &+ responseStreaming.hashValue
                }
                for oneElementOptions in options {
                    hashCode = (hashCode &* 31) &+ oneElementOptions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.Method"
        }
        override public func className() -> String {
            return "Google.Protobuf.Method"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Google.Protobuf.Method = Google.Protobuf.Method()
            public func getMessage() -> Google.Protobuf.Method {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The simple name of this method.
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Google.Protobuf.Method.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Google.Protobuf.Method.Builder{
                builderResult.hasName = false
                builderResult.name = nil
                return self
            }
            /// A URL of the input message type.
            public var requestTypeUrl:String {
                get {
                    return builderResult.requestTypeUrl
                }
                set (value) {
                    builderResult.hasRequestTypeUrl = true
                    builderResult.requestTypeUrl = value
                }
            }
            public var hasRequestTypeUrl:Bool {
                get {
                    return builderResult.hasRequestTypeUrl
                }
            }
            @discardableResult
            public func setRequestTypeUrl(_ value:String) -> Google.Protobuf.Method.Builder {
                self.requestTypeUrl = value
                return self
            }
            @discardableResult
            public func clearRequestTypeUrl() -> Google.Protobuf.Method.Builder{
                builderResult.hasRequestTypeUrl = false
                builderResult.requestTypeUrl = nil
                return self
            }
            /// If true, the request is streamed.
            public var requestStreaming:Bool {
                get {
                    return builderResult.requestStreaming
                }
                set (value) {
                    builderResult.hasRequestStreaming = true
                    builderResult.requestStreaming = value
                }
            }
            public var hasRequestStreaming:Bool {
                get {
                    return builderResult.hasRequestStreaming
                }
            }
            @discardableResult
            public func setRequestStreaming(_ value:Bool) -> Google.Protobuf.Method.Builder {
                self.requestStreaming = value
                return self
            }
            @discardableResult
            public func clearRequestStreaming() -> Google.Protobuf.Method.Builder{
                builderResult.hasRequestStreaming = false
                builderResult.requestStreaming = nil
                return self
            }
            /// The URL of the output message type.
            public var responseTypeUrl:String {
                get {
                    return builderResult.responseTypeUrl
                }
                set (value) {
                    builderResult.hasResponseTypeUrl = true
                    builderResult.responseTypeUrl = value
                }
            }
            public var hasResponseTypeUrl:Bool {
                get {
                    return builderResult.hasResponseTypeUrl
                }
            }
            @discardableResult
            public func setResponseTypeUrl(_ value:String) -> Google.Protobuf.Method.Builder {
                self.responseTypeUrl = value
                return self
            }
            @discardableResult
            public func clearResponseTypeUrl() -> Google.Protobuf.Method.Builder{
                builderResult.hasResponseTypeUrl = false
                builderResult.responseTypeUrl = nil
                return self
            }
            /// If true, the response is streamed.
            public var responseStreaming:Bool {
                get {
                    return builderResult.responseStreaming
                }
                set (value) {
                    builderResult.hasResponseStreaming = true
                    builderResult.responseStreaming = value
                }
            }
            public var hasResponseStreaming:Bool {
                get {
                    return builderResult.hasResponseStreaming
                }
            }
            @discardableResult
            public func setResponseStreaming(_ value:Bool) -> Google.Protobuf.Method.Builder {
                self.responseStreaming = value
                return self
            }
            @discardableResult
            public func clearResponseStreaming() -> Google.Protobuf.Method.Builder{
                builderResult.hasResponseStreaming = false
                builderResult.responseStreaming = nil
                return self
            }
            /// Any metadata attached to the method.
            public var options:Array<Google.Protobuf.Option> {
                get {
                    return builderResult.options
                }
                set (value) {
                    builderResult.options = value
                }
            }
            @discardableResult
            public func setOptions(_ value:Array<Google.Protobuf.Option>) -> Google.Protobuf.Method.Builder {
                self.options = value
                return self
            }
            @discardableResult
            public func clearOptions() -> Google.Protobuf.Method.Builder {
                builderResult.options.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Google.Protobuf.Method.Builder {
                builderResult = Google.Protobuf.Method()
                return self
            }
            override public func clone() throws -> Google.Protobuf.Method.Builder {
                return try Google.Protobuf.Method.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Google.Protobuf.Method {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Google.Protobuf.Method {
                let returnMe:Google.Protobuf.Method = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Google.Protobuf.Method) throws -> Google.Protobuf.Method.Builder {
                if other == Google.Protobuf.Method() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasRequestTypeUrl {
                    requestTypeUrl = other.requestTypeUrl
                }
                if other.hasRequestStreaming {
                    requestStreaming = other.requestStreaming
                }
                if other.hasResponseTypeUrl {
                    responseTypeUrl = other.responseTypeUrl
                }
                if other.hasResponseStreaming {
                    responseStreaming = other.responseStreaming
                }
                if !other.options.isEmpty  {
                     builderResult.options += other.options
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Method.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Method.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    case 18:
                        requestTypeUrl = try codedInputStream.readString()

                    case 24:
                        requestStreaming = try codedInputStream.readBool()

                    case 34:
                        responseTypeUrl = try codedInputStream.readString()

                    case 40:
                        responseStreaming = try codedInputStream.readBool()

                    case 50:
                        let subBuilder = Google.Protobuf.Option.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        options.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Method.Builder {
                let resultDecodedBuilder = Google.Protobuf.Method.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueRequestTypeUrl = jsonMap["requestTypeUrl"] as? String {
                    resultDecodedBuilder.requestTypeUrl = jsonValueRequestTypeUrl
                }
                if let jsonValueRequestStreaming = jsonMap["requestStreaming"] as? Bool {
                    resultDecodedBuilder.requestStreaming = jsonValueRequestStreaming
                }
                if let jsonValueResponseTypeUrl = jsonMap["responseTypeUrl"] as? String {
                    resultDecodedBuilder.responseTypeUrl = jsonValueResponseTypeUrl
                }
                if let jsonValueResponseStreaming = jsonMap["responseStreaming"] as? Bool {
                    resultDecodedBuilder.responseStreaming = jsonValueResponseStreaming
                }
                if let jsonValueOptions = jsonMap["options"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOptions:Array<Google.Protobuf.Option> = []
                    for oneValueOptions in jsonValueOptions {
                        let messageFromStringOptions = try Google.Protobuf.Option.Builder.decodeToBuilder(jsonMap:oneValueOptions).build()

                        jsonArrayOptions.append(messageFromStringOptions)
                    }
                    resultDecodedBuilder.options = jsonArrayOptions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.Method.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Google.Protobuf.Method.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Google.Protobuf.Api: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.Api> {
        var mergedArray = Array<Google.Protobuf.Api>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.Api? {
        return try Google.Protobuf.Api.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Google.Protobuf.Api {
        return try Google.Protobuf.Api.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.ApiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Api {
        return try Google.Protobuf.Api.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.Api {
        return try Google.Protobuf.Api.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Api {
        return try Google.Protobuf.Api.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Api {
        return try Google.Protobuf.Api.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Api {
        return try Google.Protobuf.Api.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "methods": return self.methods
        case "options": return self.options
        case "version": return self.version
        case "sourceContext": return self.sourceContext
        default: return nil
        }
    }
}
extension Google.Protobuf.Api.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Google.Protobuf.Api
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "methods": return self.methods
            case "options": return self.options
            case "version": return self.version
            case "sourceContext": return self.sourceContext
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "methods":
                guard let newSubscriptValue = newSubscriptValue as? Array<Google.Protobuf.Method> else {
                    return
                }
                self.methods = newSubscriptValue
            case "options":
                guard let newSubscriptValue = newSubscriptValue as? Array<Google.Protobuf.Option> else {
                    return
                }
                self.options = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            case "sourceContext":
                guard let newSubscriptValue = newSubscriptValue as? Google.Protobuf.SourceContext else {
                    return
                }
                self.sourceContext = newSubscriptValue
            default: return
            }
        }
    }
}
extension Google.Protobuf.Method: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.Method> {
        var mergedArray = Array<Google.Protobuf.Method>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.Method? {
        return try Google.Protobuf.Method.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Google.Protobuf.Method {
        return try Google.Protobuf.Method.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.ApiRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Method {
        return try Google.Protobuf.Method.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.Method {
        return try Google.Protobuf.Method.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Method {
        return try Google.Protobuf.Method.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Method {
        return try Google.Protobuf.Method.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Method {
        return try Google.Protobuf.Method.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "requestTypeUrl": return self.requestTypeUrl
        case "requestStreaming": return self.requestStreaming
        case "responseTypeUrl": return self.responseTypeUrl
        case "responseStreaming": return self.responseStreaming
        case "options": return self.options
        default: return nil
        }
    }
}
extension Google.Protobuf.Method.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Google.Protobuf.Method
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "requestTypeUrl": return self.requestTypeUrl
            case "requestStreaming": return self.requestStreaming
            case "responseTypeUrl": return self.responseTypeUrl
            case "responseStreaming": return self.responseStreaming
            case "options": return self.options
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "requestTypeUrl":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.requestTypeUrl = newSubscriptValue
            case "requestStreaming":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.requestStreaming = newSubscriptValue
            case "responseTypeUrl":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.responseTypeUrl = newSubscriptValue
            case "responseStreaming":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.responseStreaming = newSubscriptValue
            case "options":
                guard let newSubscriptValue = newSubscriptValue as? Array<Google.Protobuf.Option> else {
                    return
                }
                self.options = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
