/// Generated by the Protocol Buffers 3.4.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "plugin.proto"
/// Syntax "Proto2"

import Foundation

public extension Google.Protobuf{ public struct Compiler { }}

public extension Google.Protobuf.Compiler {
    public struct PluginRoot {
        public static let `default` = PluginRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Google.Protobuf.DescriptorRoot.default.registerAllExtensions(registry: extensionRegistry)
            Google.Protobuf.SwiftDescriptorRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// The version number of protocol compiler.
    final public class Version : GeneratedMessage {
        public typealias BuilderType = Google.Protobuf.Compiler.Version.Builder

        public static func == (lhs: Google.Protobuf.Compiler.Version, rhs: Google.Protobuf.Compiler.Version) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMajor == rhs.hasMajor) && (!lhs.hasMajor || lhs.major == rhs.major)
            fieldCheck = fieldCheck && (lhs.hasMinor == rhs.hasMinor) && (!lhs.hasMinor || lhs.minor == rhs.minor)
            fieldCheck = fieldCheck && (lhs.hasPatch == rhs.hasPatch) && (!lhs.hasPatch || lhs.patch == rhs.patch)
            fieldCheck = fieldCheck && (lhs.hasSuffix == rhs.hasSuffix) && (!lhs.hasSuffix || lhs.suffix == rhs.suffix)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var major:Int32! = nil
        public fileprivate(set) var hasMajor:Bool = false

        public fileprivate(set) var minor:Int32! = nil
        public fileprivate(set) var hasMinor:Bool = false

        public fileprivate(set) var patch:Int32! = nil
        public fileprivate(set) var hasPatch:Bool = false

        /// A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
        /// be empty for mainline stable releases.
        public fileprivate(set) var suffix:String! = nil
        public fileprivate(set) var hasSuffix:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMajor {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:major)
            }
            if hasMinor {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:minor)
            }
            if hasPatch {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:patch)
            }
            if hasSuffix {
                try codedOutputStream.writeString(fieldNumber: 4, value:suffix)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMajor {
                serialize_size += major.computeInt32Size(fieldNumber: 1)
            }
            if hasMinor {
                serialize_size += minor.computeInt32Size(fieldNumber: 2)
            }
            if hasPatch {
                serialize_size += patch.computeInt32Size(fieldNumber: 3)
            }
            if hasSuffix {
                serialize_size += suffix.computeStringSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.Compiler.Version.Builder {
            return Google.Protobuf.Compiler.Version.classBuilder() as! Google.Protobuf.Compiler.Version.Builder
        }
        public func getBuilder() -> Google.Protobuf.Compiler.Version.Builder {
            return classBuilder() as! Google.Protobuf.Compiler.Version.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Compiler.Version.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Compiler.Version.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.Compiler.Version.Builder {
            return try Google.Protobuf.Compiler.Version.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.Compiler.Version) throws -> Google.Protobuf.Compiler.Version.Builder {
            return try Google.Protobuf.Compiler.Version.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMajor {
                jsonMap["major"] = Int(major)
            }
            if hasMinor {
                jsonMap["minor"] = Int(minor)
            }
            if hasPatch {
                jsonMap["patch"] = Int(patch)
            }
            if hasSuffix {
                jsonMap["suffix"] = suffix
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Compiler.Version {
            return try Google.Protobuf.Compiler.Version.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.Compiler.Version {
            return try Google.Protobuf.Compiler.Version.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMajor {
                output += "\(indent) major: \(major) \n"
            }
            if hasMinor {
                output += "\(indent) minor: \(minor) \n"
            }
            if hasPatch {
                output += "\(indent) patch: \(patch) \n"
            }
            if hasSuffix {
                output += "\(indent) suffix: \(suffix) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMajor {
                    hashCode = (hashCode &* 31) &+ major.hashValue
                }
                if hasMinor {
                    hashCode = (hashCode &* 31) &+ minor.hashValue
                }
                if hasPatch {
                    hashCode = (hashCode &* 31) &+ patch.hashValue
                }
                if hasSuffix {
                    hashCode = (hashCode &* 31) &+ suffix.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.Compiler.Version"
        }
        override public func className() -> String {
            return "Google.Protobuf.Compiler.Version"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Google.Protobuf.Compiler.Version = Google.Protobuf.Compiler.Version()
            public func getMessage() -> Google.Protobuf.Compiler.Version {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var major:Int32 {
                get {
                    return builderResult.major
                }
                set (value) {
                    builderResult.hasMajor = true
                    builderResult.major = value
                }
            }
            public var hasMajor:Bool {
                get {
                    return builderResult.hasMajor
                }
            }
            @discardableResult
            public func setMajor(_ value:Int32) -> Google.Protobuf.Compiler.Version.Builder {
                self.major = value
                return self
            }
            @discardableResult
            public func clearMajor() -> Google.Protobuf.Compiler.Version.Builder{
                builderResult.hasMajor = false
                builderResult.major = nil
                return self
            }
            public var minor:Int32 {
                get {
                    return builderResult.minor
                }
                set (value) {
                    builderResult.hasMinor = true
                    builderResult.minor = value
                }
            }
            public var hasMinor:Bool {
                get {
                    return builderResult.hasMinor
                }
            }
            @discardableResult
            public func setMinor(_ value:Int32) -> Google.Protobuf.Compiler.Version.Builder {
                self.minor = value
                return self
            }
            @discardableResult
            public func clearMinor() -> Google.Protobuf.Compiler.Version.Builder{
                builderResult.hasMinor = false
                builderResult.minor = nil
                return self
            }
            public var patch:Int32 {
                get {
                    return builderResult.patch
                }
                set (value) {
                    builderResult.hasPatch = true
                    builderResult.patch = value
                }
            }
            public var hasPatch:Bool {
                get {
                    return builderResult.hasPatch
                }
            }
            @discardableResult
            public func setPatch(_ value:Int32) -> Google.Protobuf.Compiler.Version.Builder {
                self.patch = value
                return self
            }
            @discardableResult
            public func clearPatch() -> Google.Protobuf.Compiler.Version.Builder{
                builderResult.hasPatch = false
                builderResult.patch = nil
                return self
            }
            /// A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
            /// be empty for mainline stable releases.
            public var suffix:String {
                get {
                    return builderResult.suffix
                }
                set (value) {
                    builderResult.hasSuffix = true
                    builderResult.suffix = value
                }
            }
            public var hasSuffix:Bool {
                get {
                    return builderResult.hasSuffix
                }
            }
            @discardableResult
            public func setSuffix(_ value:String) -> Google.Protobuf.Compiler.Version.Builder {
                self.suffix = value
                return self
            }
            @discardableResult
            public func clearSuffix() -> Google.Protobuf.Compiler.Version.Builder{
                builderResult.hasSuffix = false
                builderResult.suffix = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Google.Protobuf.Compiler.Version.Builder {
                builderResult = Google.Protobuf.Compiler.Version()
                return self
            }
            override public func clone() throws -> Google.Protobuf.Compiler.Version.Builder {
                return try Google.Protobuf.Compiler.Version.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Google.Protobuf.Compiler.Version {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Google.Protobuf.Compiler.Version {
                let returnMe:Google.Protobuf.Compiler.Version = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Google.Protobuf.Compiler.Version) throws -> Google.Protobuf.Compiler.Version.Builder {
                if other == Google.Protobuf.Compiler.Version() {
                    return self
                }
                if other.hasMajor {
                    major = other.major
                }
                if other.hasMinor {
                    minor = other.minor
                }
                if other.hasPatch {
                    patch = other.patch
                }
                if other.hasSuffix {
                    suffix = other.suffix
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Compiler.Version.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.Version.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        major = try codedInputStream.readInt32()

                    case 16:
                        minor = try codedInputStream.readInt32()

                    case 24:
                        patch = try codedInputStream.readInt32()

                    case 34:
                        suffix = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Compiler.Version.Builder {
                let resultDecodedBuilder = Google.Protobuf.Compiler.Version.Builder()
                if let jsonValueMajor = jsonMap["major"] as? Int {
                    resultDecodedBuilder.major = Int32(jsonValueMajor)
                } else if let jsonValueMajor = jsonMap["major"] as? String {
                    resultDecodedBuilder.major = Int32(jsonValueMajor)!
                }
                if let jsonValueMinor = jsonMap["minor"] as? Int {
                    resultDecodedBuilder.minor = Int32(jsonValueMinor)
                } else if let jsonValueMinor = jsonMap["minor"] as? String {
                    resultDecodedBuilder.minor = Int32(jsonValueMinor)!
                }
                if let jsonValuePatch = jsonMap["patch"] as? Int {
                    resultDecodedBuilder.patch = Int32(jsonValuePatch)
                } else if let jsonValuePatch = jsonMap["patch"] as? String {
                    resultDecodedBuilder.patch = Int32(jsonValuePatch)!
                }
                if let jsonValueSuffix = jsonMap["suffix"] as? String {
                    resultDecodedBuilder.suffix = jsonValueSuffix
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.Compiler.Version.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Google.Protobuf.Compiler.Version.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// An encoded CodeGeneratorRequest is written to the plugin's stdin.
    final public class CodeGeneratorRequest : GeneratedMessage {
        public typealias BuilderType = Google.Protobuf.Compiler.CodeGeneratorRequest.Builder

        public static func == (lhs: Google.Protobuf.Compiler.CodeGeneratorRequest, rhs: Google.Protobuf.Compiler.CodeGeneratorRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.fileToGenerate == rhs.fileToGenerate)
            fieldCheck = fieldCheck && (lhs.hasParameter == rhs.hasParameter) && (!lhs.hasParameter || lhs.parameter == rhs.parameter)
            fieldCheck = fieldCheck && (lhs.hasCompilerVersion == rhs.hasCompilerVersion) && (!lhs.hasCompilerVersion || lhs.compilerVersion == rhs.compilerVersion)
            fieldCheck = fieldCheck && (lhs.protoFile == rhs.protoFile)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The .proto files that were explicitly listed on the command-line.  The
        /// code generator should generate code only for these files.  Each file's
        /// descriptor will be included in proto_file, below.
        public fileprivate(set) var fileToGenerate:Array<String> = Array<String>()
        /// The generator parameter passed on the command-line.
        public fileprivate(set) var parameter:String! = nil
        public fileprivate(set) var hasParameter:Bool = false

        public fileprivate(set) var protoFile:Array<Google.Protobuf.FileDescriptorProto>  = Array<Google.Protobuf.FileDescriptorProto>()
        public fileprivate(set) var compilerVersion:Google.Protobuf.Compiler.Version!
        public fileprivate(set) var hasCompilerVersion:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitProtoFile:Bool = true
            for oneElementProtoFile in protoFile {
                if !oneElementProtoFile.isInitialized() {
                    isInitProtoFile = false
                    break 
                }
            }
            if !isInitProtoFile {
                return isInitProtoFile
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !fileToGenerate.isEmpty {
                for oneValuefileToGenerate in fileToGenerate {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuefileToGenerate)
                }
            }
            if hasParameter {
                try codedOutputStream.writeString(fieldNumber: 2, value:parameter)
            }
            if hasCompilerVersion {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:compilerVersion)
            }
            for oneElementProtoFile in protoFile {
                  try codedOutputStream.writeMessage(fieldNumber: 15, value:oneElementProtoFile)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeFileToGenerate:Int32 = 0
            for oneValuefileToGenerate in fileToGenerate {
                dataSizeFileToGenerate += oneValuefileToGenerate.computeStringSizeNoTag()
            }
            serialize_size += dataSizeFileToGenerate
            serialize_size += 1 * Int32(fileToGenerate.count)
            if hasParameter {
                serialize_size += parameter.computeStringSize(fieldNumber: 2)
            }
            if hasCompilerVersion {
                if let varSizecompilerVersion = compilerVersion?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizecompilerVersion
                }
            }
            for oneElementProtoFile in protoFile {
                serialize_size += oneElementProtoFile.computeMessageSize(fieldNumber: 15)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
            return Google.Protobuf.Compiler.CodeGeneratorRequest.classBuilder() as! Google.Protobuf.Compiler.CodeGeneratorRequest.Builder
        }
        public func getBuilder() -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
            return classBuilder() as! Google.Protobuf.Compiler.CodeGeneratorRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Compiler.CodeGeneratorRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Compiler.CodeGeneratorRequest.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
            return try Google.Protobuf.Compiler.CodeGeneratorRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.Compiler.CodeGeneratorRequest) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
            return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !fileToGenerate.isEmpty {
                var jsonArrayFileToGenerate:Array<String> = []
                for oneValueFileToGenerate in fileToGenerate {
                    jsonArrayFileToGenerate.append(oneValueFileToGenerate)
                }
                jsonMap["fileToGenerate"] = jsonArrayFileToGenerate
            }
            if hasParameter {
                jsonMap["parameter"] = parameter
            }
            if !protoFile.isEmpty {
                var jsonArrayProtoFile:Array<Dictionary<String,Any>> = []
                for oneValueProtoFile in protoFile {
                    let ecodedMessageProtoFile = try oneValueProtoFile.encode()
                    jsonArrayProtoFile.append(ecodedMessageProtoFile)
                }
                jsonMap["protoFile"] = jsonArrayProtoFile
            }
            if hasCompilerVersion {
                jsonMap["compilerVersion"] = try compilerVersion.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest {
            return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest {
            return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var fileToGenerateElementIndex:Int = 0
            for oneValueFileToGenerate in fileToGenerate  {
                output += "\(indent) fileToGenerate[\(fileToGenerateElementIndex)]: \(oneValueFileToGenerate)\n"
                fileToGenerateElementIndex += 1
            }
            if hasParameter {
                output += "\(indent) parameter: \(parameter) \n"
            }
            if hasCompilerVersion {
                output += "\(indent) compilerVersion {\n"
                if let outDescCompilerVersion = compilerVersion {
                    output += try outDescCompilerVersion.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var protoFileElementIndex:Int = 0
            for oneElementProtoFile in protoFile {
                output += "\(indent) protoFile[\(protoFileElementIndex)] {\n"
                output += try oneElementProtoFile.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                protoFileElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueFileToGenerate in fileToGenerate {
                    hashCode = (hashCode &* 31) &+ oneValueFileToGenerate.hashValue
                }
                if hasParameter {
                    hashCode = (hashCode &* 31) &+ parameter.hashValue
                }
                if hasCompilerVersion {
                    if let hashValuecompilerVersion = compilerVersion?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecompilerVersion
                    }
                }
                for oneElementProtoFile in protoFile {
                    hashCode = (hashCode &* 31) &+ oneElementProtoFile.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.Compiler.CodeGeneratorRequest"
        }
        override public func className() -> String {
            return "Google.Protobuf.Compiler.CodeGeneratorRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Google.Protobuf.Compiler.CodeGeneratorRequest = Google.Protobuf.Compiler.CodeGeneratorRequest()
            public func getMessage() -> Google.Protobuf.Compiler.CodeGeneratorRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The .proto files that were explicitly listed on the command-line.  The
            /// code generator should generate code only for these files.  Each file's
            /// descriptor will be included in proto_file, below.
            public var fileToGenerate:Array<String> {
                get {
                    return builderResult.fileToGenerate
                }
                set (array) {
                    builderResult.fileToGenerate = array
                }
            }
            @discardableResult
            public func setFileToGenerate(_ value:Array<String>) -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                self.fileToGenerate = value
                return self
            }
            @discardableResult
            public func clearFileToGenerate() -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                builderResult.fileToGenerate.removeAll(keepingCapacity: false)
                return self
            }
            /// The generator parameter passed on the command-line.
            public var parameter:String {
                get {
                    return builderResult.parameter
                }
                set (value) {
                    builderResult.hasParameter = true
                    builderResult.parameter = value
                }
            }
            public var hasParameter:Bool {
                get {
                    return builderResult.hasParameter
                }
            }
            @discardableResult
            public func setParameter(_ value:String) -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                self.parameter = value
                return self
            }
            @discardableResult
            public func clearParameter() -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder{
                builderResult.hasParameter = false
                builderResult.parameter = nil
                return self
            }
            /// FileDescriptorProtos for all files in files_to_generate and everything
            /// they import.  The files will appear in topological order, so each file
            /// appears before any file that imports it.
            /// protoc guarantees that all proto_files will be written after
            /// the fields above, even though this is not technically guaranteed by the
            /// protobuf wire format.  This theoretically could allow a plugin to stream
            /// in the FileDescriptorProtos and handle them one by one rather than read
            /// the entire set into memory at once.  However, as of this writing, this
            /// is not similarly optimized on protoc's end -- it will store all fields in
            /// memory at once before sending them to the plugin.
            /// Type names of fields and extensions in the FileDescriptorProto are always
            /// fully qualified.
            public var protoFile:Array<Google.Protobuf.FileDescriptorProto> {
                get {
                    return builderResult.protoFile
                }
                set (value) {
                    builderResult.protoFile = value
                }
            }
            @discardableResult
            public func setProtoFile(_ value:Array<Google.Protobuf.FileDescriptorProto>) -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                self.protoFile = value
                return self
            }
            @discardableResult
            public func clearProtoFile() -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                builderResult.protoFile.removeAll(keepingCapacity: false)
                return self
            }
            /// The version number of protocol compiler.
            public var compilerVersion:Google.Protobuf.Compiler.Version! {
                get {
                    if compilerVersionBuilder_ != nil {
                        builderResult.compilerVersion = compilerVersionBuilder_.getMessage()
                    }
                    return builderResult.compilerVersion
                }
                set (value) {
                    builderResult.hasCompilerVersion = true
                    builderResult.compilerVersion = value
                }
            }
            public var hasCompilerVersion:Bool {
                get {
                    return builderResult.hasCompilerVersion
                }
            }
            fileprivate var compilerVersionBuilder_:Google.Protobuf.Compiler.Version.Builder! {
                didSet {
                    builderResult.hasCompilerVersion = true
                }
            }
            public func getCompilerVersionBuilder() -> Google.Protobuf.Compiler.Version.Builder {
                if compilerVersionBuilder_ == nil {
                    compilerVersionBuilder_ = Google.Protobuf.Compiler.Version.Builder()
                    builderResult.compilerVersion = compilerVersionBuilder_.getMessage()
                    if compilerVersion != nil {
                        try! compilerVersionBuilder_.mergeFrom(other: compilerVersion)
                    }
                }
                return compilerVersionBuilder_
            }
            @discardableResult
            public func setCompilerVersion(_ value:Google.Protobuf.Compiler.Version!) -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                self.compilerVersion = value
                return self
            }
            @discardableResult
            public func mergeCompilerVersion(value:Google.Protobuf.Compiler.Version) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                if builderResult.hasCompilerVersion {
                    builderResult.compilerVersion = try Google.Protobuf.Compiler.Version.builderWithPrototype(prototype:builderResult.compilerVersion).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.compilerVersion = value
                }
                builderResult.hasCompilerVersion = true
                return self
            }
            @discardableResult
            public func clearCompilerVersion() -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                compilerVersionBuilder_ = nil
                builderResult.hasCompilerVersion = false
                builderResult.compilerVersion = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                builderResult = Google.Protobuf.Compiler.CodeGeneratorRequest()
                return self
            }
            override public func clone() throws -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                return try Google.Protobuf.Compiler.CodeGeneratorRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Google.Protobuf.Compiler.CodeGeneratorRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Google.Protobuf.Compiler.CodeGeneratorRequest {
                let returnMe:Google.Protobuf.Compiler.CodeGeneratorRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Google.Protobuf.Compiler.CodeGeneratorRequest) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                if other == Google.Protobuf.Compiler.CodeGeneratorRequest() {
                    return self
                }
                if !other.fileToGenerate.isEmpty {
                    builderResult.fileToGenerate += other.fileToGenerate
                }
                if other.hasParameter {
                    parameter = other.parameter
                }
                if !other.protoFile.isEmpty  {
                     builderResult.protoFile += other.protoFile
                }
                if (other.hasCompilerVersion) {
                    try mergeCompilerVersion(value: other.compilerVersion)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        fileToGenerate += [try codedInputStream.readString()]

                    case 18:
                        parameter = try codedInputStream.readString()

                    case 26:
                        let subBuilder:Google.Protobuf.Compiler.Version.Builder = Google.Protobuf.Compiler.Version.Builder()
                        if hasCompilerVersion {
                            try subBuilder.mergeFrom(other: compilerVersion)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        compilerVersion = subBuilder.buildPartial()

                    case 122:
                        let subBuilder = Google.Protobuf.FileDescriptorProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        protoFile.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                let resultDecodedBuilder = Google.Protobuf.Compiler.CodeGeneratorRequest.Builder()
                if let jsonValueFileToGenerate = jsonMap["fileToGenerate"] as? Array<String> {
                    var jsonArrayFileToGenerate:Array<String> = []
                    for oneValueFileToGenerate in jsonValueFileToGenerate {
                        jsonArrayFileToGenerate.append(oneValueFileToGenerate)
                    }
                    resultDecodedBuilder.fileToGenerate = jsonArrayFileToGenerate
                }
                if let jsonValueParameter = jsonMap["parameter"] as? String {
                    resultDecodedBuilder.parameter = jsonValueParameter
                }
                if let jsonValueProtoFile = jsonMap["protoFile"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayProtoFile:Array<Google.Protobuf.FileDescriptorProto> = []
                    for oneValueProtoFile in jsonValueProtoFile {
                        let messageFromStringProtoFile = try Google.Protobuf.FileDescriptorProto.Builder.decodeToBuilder(jsonMap:oneValueProtoFile).build()

                        jsonArrayProtoFile.append(messageFromStringProtoFile)
                    }
                    resultDecodedBuilder.protoFile = jsonArrayProtoFile
                }
                if let jsonValueCompilerVersion = jsonMap["compilerVersion"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.compilerVersion = try Google.Protobuf.Compiler.Version.Builder.decodeToBuilder(jsonMap:jsonValueCompilerVersion).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// The plugin writes an encoded CodeGeneratorResponse to stdout.
    final public class CodeGeneratorResponse : GeneratedMessage {
        public typealias BuilderType = Google.Protobuf.Compiler.CodeGeneratorResponse.Builder

        public static func == (lhs: Google.Protobuf.Compiler.CodeGeneratorResponse, rhs: Google.Protobuf.Compiler.CodeGeneratorResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
            fieldCheck = fieldCheck && (lhs.file == rhs.file)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// Represents a single generated file.
        final public class File : GeneratedMessage {
            public typealias BuilderType = Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder

            public static func == (lhs: Google.Protobuf.Compiler.CodeGeneratorResponse.File, rhs: Google.Protobuf.Compiler.CodeGeneratorResponse.File) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
                fieldCheck = fieldCheck && (lhs.hasInsertionPoint == rhs.hasInsertionPoint) && (!lhs.hasInsertionPoint || lhs.insertionPoint == rhs.insertionPoint)
                fieldCheck = fieldCheck && (lhs.hasContent == rhs.hasContent) && (!lhs.hasContent || lhs.content == rhs.content)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// The file name, relative to the output directory.  The name must not
            /// contain "." or ".." components and must be relative, not be absolute (so,
            /// the file cannot lie outside the output directory).  "/" must be used as
            /// the path separator, not "\".
            /// If the name is omitted, the content will be appended to the previous
            /// file.  This allows the generator to break large files into small chunks,
            /// and allows the generated text to be streamed back to protoc so that large
            /// files need not reside completely in memory at one time.  Note that as of
            /// this writing protoc does not optimize for this -- it will read the entire
            /// CodeGeneratorResponse before writing files to disk.
            public fileprivate(set) var name:String! = nil
            public fileprivate(set) var hasName:Bool = false

            /// If non-empty, indicates that the named file should already exist, and the
            /// content here is to be inserted into that file at a defined insertion
            /// point.  This feature allows a code generator to extend the output
            /// produced by another code generator.  The original generator may provide
            /// insertion points by placing special annotations in the file that look
            /// like:
            ///   @@protoc_insertion_point(NAME)
            /// The annotation can have arbitrary text before and after it on the line,
            /// which allows it to be placed in a comment.  NAME should be replaced with
            /// an identifier naming the point -- this is what other generators will use
            /// as the insertion_point.  Code inserted at this point will be placed
            /// immediately above the line containing the insertion point (thus multiple
            /// insertions to the same point will come out in the order they were added).
            /// The double-@ is intended to make it unlikely that the generated code
            /// could contain things that look like insertion points by accident.
            /// For example, the C++ code generator places the following line in the
            /// .pb.h files that it generates:
            ///   // @@protoc_insertion_point(namespace_scope)
            /// This line appears within the scope of the file's package namespace, but
            /// outside of any particular class.  Another plugin can then specify the
            /// insertion_point "namespace_scope" to generate additional classes or
            /// other declarations that should be placed in this scope.
            /// Note that if the line containing the insertion point begins with
            /// whitespace, the same whitespace will be added to every line of the
            /// inserted text.  This is useful for languages like Python, where
            /// indentation matters.  In these languages, the insertion point comment
            /// should be indented the same amount as any inserted code will need to be
            /// in order to work correctly in that context.
            /// The code generator that generates the initial file and the one which
            /// inserts into it must both run as part of a single invocation of protoc.
            /// Code generators are executed in the order in which they appear on the
            /// command line.
            /// If |insertion_point| is present, |name| must also be present.
            public fileprivate(set) var insertionPoint:String! = nil
            public fileprivate(set) var hasInsertionPoint:Bool = false

            /// The file contents.
            public fileprivate(set) var content:String! = nil
            public fileprivate(set) var hasContent:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasName {
                    try codedOutputStream.writeString(fieldNumber: 1, value:name)
                }
                if hasInsertionPoint {
                    try codedOutputStream.writeString(fieldNumber: 2, value:insertionPoint)
                }
                if hasContent {
                    try codedOutputStream.writeString(fieldNumber: 15, value:content)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasName {
                    serialize_size += name.computeStringSize(fieldNumber: 1)
                }
                if hasInsertionPoint {
                    serialize_size += insertionPoint.computeStringSize(fieldNumber: 2)
                }
                if hasContent {
                    serialize_size += content.computeStringSize(fieldNumber: 15)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                return Google.Protobuf.Compiler.CodeGeneratorResponse.File.classBuilder() as! Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder
            }
            public func getBuilder() -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                return classBuilder() as! Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder()
            }
            public func toBuilder() throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Google.Protobuf.Compiler.CodeGeneratorResponse.File) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasName {
                    jsonMap["name"] = name
                }
                if hasInsertionPoint {
                    jsonMap["insertionPoint"] = insertionPoint
                }
                if hasContent {
                    jsonMap["content"] = content
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
                return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
                return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasName {
                    output += "\(indent) name: \(name) \n"
                }
                if hasInsertionPoint {
                    output += "\(indent) insertionPoint: \(insertionPoint) \n"
                }
                if hasContent {
                    output += "\(indent) content: \(content) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasName {
                        hashCode = (hashCode &* 31) &+ name.hashValue
                    }
                    if hasInsertionPoint {
                        hashCode = (hashCode &* 31) &+ insertionPoint.hashValue
                    }
                    if hasContent {
                        hashCode = (hashCode &* 31) &+ content.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Google.Protobuf.Compiler.CodeGeneratorResponse.File"
            }
            override public func className() -> String {
                return "Google.Protobuf.Compiler.CodeGeneratorResponse.File"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Google.Protobuf.Compiler.CodeGeneratorResponse.File = Google.Protobuf.Compiler.CodeGeneratorResponse.File()
                public func getMessage() -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// The file name, relative to the output directory.  The name must not
                /// contain "." or ".." components and must be relative, not be absolute (so,
                /// the file cannot lie outside the output directory).  "/" must be used as
                /// the path separator, not "\".
                /// If the name is omitted, the content will be appended to the previous
                /// file.  This allows the generator to break large files into small chunks,
                /// and allows the generated text to be streamed back to protoc so that large
                /// files need not reside completely in memory at one time.  Note that as of
                /// this writing protoc does not optimize for this -- it will read the entire
                /// CodeGeneratorResponse before writing files to disk.
                public var name:String {
                    get {
                        return builderResult.name
                    }
                    set (value) {
                        builderResult.hasName = true
                        builderResult.name = value
                    }
                }
                public var hasName:Bool {
                    get {
                        return builderResult.hasName
                    }
                }
                @discardableResult
                public func setName(_ value:String) -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    self.name = value
                    return self
                }
                @discardableResult
                public func clearName() -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder{
                    builderResult.hasName = false
                    builderResult.name = nil
                    return self
                }
                /// If non-empty, indicates that the named file should already exist, and the
                /// content here is to be inserted into that file at a defined insertion
                /// point.  This feature allows a code generator to extend the output
                /// produced by another code generator.  The original generator may provide
                /// insertion points by placing special annotations in the file that look
                /// like:
                ///   @@protoc_insertion_point(NAME)
                /// The annotation can have arbitrary text before and after it on the line,
                /// which allows it to be placed in a comment.  NAME should be replaced with
                /// an identifier naming the point -- this is what other generators will use
                /// as the insertion_point.  Code inserted at this point will be placed
                /// immediately above the line containing the insertion point (thus multiple
                /// insertions to the same point will come out in the order they were added).
                /// The double-@ is intended to make it unlikely that the generated code
                /// could contain things that look like insertion points by accident.
                /// For example, the C++ code generator places the following line in the
                /// .pb.h files that it generates:
                ///   // @@protoc_insertion_point(namespace_scope)
                /// This line appears within the scope of the file's package namespace, but
                /// outside of any particular class.  Another plugin can then specify the
                /// insertion_point "namespace_scope" to generate additional classes or
                /// other declarations that should be placed in this scope.
                /// Note that if the line containing the insertion point begins with
                /// whitespace, the same whitespace will be added to every line of the
                /// inserted text.  This is useful for languages like Python, where
                /// indentation matters.  In these languages, the insertion point comment
                /// should be indented the same amount as any inserted code will need to be
                /// in order to work correctly in that context.
                /// The code generator that generates the initial file and the one which
                /// inserts into it must both run as part of a single invocation of protoc.
                /// Code generators are executed in the order in which they appear on the
                /// command line.
                /// If |insertion_point| is present, |name| must also be present.
                public var insertionPoint:String {
                    get {
                        return builderResult.insertionPoint
                    }
                    set (value) {
                        builderResult.hasInsertionPoint = true
                        builderResult.insertionPoint = value
                    }
                }
                public var hasInsertionPoint:Bool {
                    get {
                        return builderResult.hasInsertionPoint
                    }
                }
                @discardableResult
                public func setInsertionPoint(_ value:String) -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    self.insertionPoint = value
                    return self
                }
                @discardableResult
                public func clearInsertionPoint() -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder{
                    builderResult.hasInsertionPoint = false
                    builderResult.insertionPoint = nil
                    return self
                }
                /// The file contents.
                public var content:String {
                    get {
                        return builderResult.content
                    }
                    set (value) {
                        builderResult.hasContent = true
                        builderResult.content = value
                    }
                }
                public var hasContent:Bool {
                    get {
                        return builderResult.hasContent
                    }
                }
                @discardableResult
                public func setContent(_ value:String) -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    self.content = value
                    return self
                }
                @discardableResult
                public func clearContent() -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder{
                    builderResult.hasContent = false
                    builderResult.content = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    builderResult = Google.Protobuf.Compiler.CodeGeneratorResponse.File()
                    return self
                }
                override public func clone() throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
                    let returnMe:Google.Protobuf.Compiler.CodeGeneratorResponse.File = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Google.Protobuf.Compiler.CodeGeneratorResponse.File) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    if other == Google.Protobuf.Compiler.CodeGeneratorResponse.File() {
                        return self
                    }
                    if other.hasName {
                        name = other.name
                    }
                    if other.hasInsertionPoint {
                        insertionPoint = other.insertionPoint
                    }
                    if other.hasContent {
                        content = other.content
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            name = try codedInputStream.readString()

                        case 18:
                            insertionPoint = try codedInputStream.readString()

                        case 122:
                            content = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    let resultDecodedBuilder = Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder()
                    if let jsonValueName = jsonMap["name"] as? String {
                        resultDecodedBuilder.name = jsonValueName
                    }
                    if let jsonValueInsertionPoint = jsonMap["insertionPoint"] as? String {
                        resultDecodedBuilder.insertionPoint = jsonValueInsertionPoint
                    }
                    if let jsonValueContent = jsonMap["content"] as? String {
                        resultDecodedBuilder.content = jsonValueContent
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        /// Error message.  If non-empty, code generation failed.  The plugin process
        /// should exit with status code zero even if it reports an error in this way.
        /// This should be used to indicate errors in .proto files which prevent the
        /// code generator from generating correct code.  Errors which indicate a
        /// problem in protoc itself -- such as the input CodeGeneratorRequest being
        /// unparseable -- should be reported by writing a message to stderr and
        /// exiting with a non-zero status code.
        public fileprivate(set) var error:String! = nil
        public fileprivate(set) var hasError:Bool = false

        public fileprivate(set) var file:Array<Google.Protobuf.Compiler.CodeGeneratorResponse.File>  = Array<Google.Protobuf.Compiler.CodeGeneratorResponse.File>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasError {
                try codedOutputStream.writeString(fieldNumber: 1, value:error)
            }
            for oneElementFile in file {
                  try codedOutputStream.writeMessage(fieldNumber: 15, value:oneElementFile)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasError {
                serialize_size += error.computeStringSize(fieldNumber: 1)
            }
            for oneElementFile in file {
                serialize_size += oneElementFile.computeMessageSize(fieldNumber: 15)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
            return Google.Protobuf.Compiler.CodeGeneratorResponse.classBuilder() as! Google.Protobuf.Compiler.CodeGeneratorResponse.Builder
        }
        public func getBuilder() -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
            return classBuilder() as! Google.Protobuf.Compiler.CodeGeneratorResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Compiler.CodeGeneratorResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Google.Protobuf.Compiler.CodeGeneratorResponse.Builder()
        }
        public func toBuilder() throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
            return try Google.Protobuf.Compiler.CodeGeneratorResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.Compiler.CodeGeneratorResponse) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
            return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasError {
                jsonMap["error"] = error
            }
            if !file.isEmpty {
                var jsonArrayFile:Array<Dictionary<String,Any>> = []
                for oneValueFile in file {
                    let ecodedMessageFile = try oneValueFile.encode()
                    jsonArrayFile.append(ecodedMessageFile)
                }
                jsonMap["file"] = jsonArrayFile
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse {
            return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse {
            return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasError {
                output += "\(indent) error: \(error) \n"
            }
            var fileElementIndex:Int = 0
            for oneElementFile in file {
                output += "\(indent) file[\(fileElementIndex)] {\n"
                output += try oneElementFile.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                fileElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasError {
                    hashCode = (hashCode &* 31) &+ error.hashValue
                }
                for oneElementFile in file {
                    hashCode = (hashCode &* 31) &+ oneElementFile.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.Compiler.CodeGeneratorResponse"
        }
        override public func className() -> String {
            return "Google.Protobuf.Compiler.CodeGeneratorResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Google.Protobuf.Compiler.CodeGeneratorResponse = Google.Protobuf.Compiler.CodeGeneratorResponse()
            public func getMessage() -> Google.Protobuf.Compiler.CodeGeneratorResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Error message.  If non-empty, code generation failed.  The plugin process
            /// should exit with status code zero even if it reports an error in this way.
            /// This should be used to indicate errors in .proto files which prevent the
            /// code generator from generating correct code.  Errors which indicate a
            /// problem in protoc itself -- such as the input CodeGeneratorRequest being
            /// unparseable -- should be reported by writing a message to stderr and
            /// exiting with a non-zero status code.
            public var error:String {
                get {
                    return builderResult.error
                }
                set (value) {
                    builderResult.hasError = true
                    builderResult.error = value
                }
            }
            public var hasError:Bool {
                get {
                    return builderResult.hasError
                }
            }
            @discardableResult
            public func setError(_ value:String) -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                self.error = value
                return self
            }
            @discardableResult
            public func clearError() -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder{
                builderResult.hasError = false
                builderResult.error = nil
                return self
            }
            public var file:Array<Google.Protobuf.Compiler.CodeGeneratorResponse.File> {
                get {
                    return builderResult.file
                }
                set (value) {
                    builderResult.file = value
                }
            }
            @discardableResult
            public func setFile(_ value:Array<Google.Protobuf.Compiler.CodeGeneratorResponse.File>) -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                self.file = value
                return self
            }
            @discardableResult
            public func clearFile() -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                builderResult.file.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                builderResult = Google.Protobuf.Compiler.CodeGeneratorResponse()
                return self
            }
            override public func clone() throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                return try Google.Protobuf.Compiler.CodeGeneratorResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Google.Protobuf.Compiler.CodeGeneratorResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Google.Protobuf.Compiler.CodeGeneratorResponse {
                let returnMe:Google.Protobuf.Compiler.CodeGeneratorResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Google.Protobuf.Compiler.CodeGeneratorResponse) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                if other == Google.Protobuf.Compiler.CodeGeneratorResponse() {
                    return self
                }
                if other.hasError {
                    error = other.error
                }
                if !other.file.isEmpty  {
                     builderResult.file += other.file
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        error = try codedInputStream.readString()

                    case 122:
                        let subBuilder = Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        file.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                let resultDecodedBuilder = Google.Protobuf.Compiler.CodeGeneratorResponse.Builder()
                if let jsonValueError = jsonMap["error"] as? String {
                    resultDecodedBuilder.error = jsonValueError
                }
                if let jsonValueFile = jsonMap["file"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayFile:Array<Google.Protobuf.Compiler.CodeGeneratorResponse.File> = []
                    for oneValueFile in jsonValueFile {
                        let messageFromStringFile = try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder.decodeToBuilder(jsonMap:oneValueFile).build()

                        jsonArrayFile.append(messageFromStringFile)
                    }
                    resultDecodedBuilder.file = jsonArrayFile
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Google.Protobuf.Compiler.Version: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.Compiler.Version> {
        var mergedArray = Array<Google.Protobuf.Compiler.Version>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.Compiler.Version? {
        return try Google.Protobuf.Compiler.Version.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Google.Protobuf.Compiler.Version {
        return try Google.Protobuf.Compiler.Version.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.Compiler.PluginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.Version {
        return try Google.Protobuf.Compiler.Version.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.Compiler.Version {
        return try Google.Protobuf.Compiler.Version.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.Version {
        return try Google.Protobuf.Compiler.Version.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Compiler.Version {
        return try Google.Protobuf.Compiler.Version.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.Version {
        return try Google.Protobuf.Compiler.Version.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "major": return self.major
        case "minor": return self.minor
        case "patch": return self.patch
        case "suffix": return self.suffix
        default: return nil
        }
    }
}
extension Google.Protobuf.Compiler.Version.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Google.Protobuf.Compiler.Version
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "major": return self.major
            case "minor": return self.minor
            case "patch": return self.patch
            case "suffix": return self.suffix
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "major":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.major = newSubscriptValue
            case "minor":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.minor = newSubscriptValue
            case "patch":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.patch = newSubscriptValue
            case "suffix":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.suffix = newSubscriptValue
            default: return
            }
        }
    }
}
extension Google.Protobuf.Compiler.CodeGeneratorRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.Compiler.CodeGeneratorRequest> {
        var mergedArray = Array<Google.Protobuf.Compiler.CodeGeneratorRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest? {
        return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest {
        return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.Compiler.PluginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest {
        return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest {
        return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest {
        return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest {
        return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorRequest {
        return try Google.Protobuf.Compiler.CodeGeneratorRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fileToGenerate": return self.fileToGenerate
        case "parameter": return self.parameter
        case "protoFile": return self.protoFile
        case "compilerVersion": return self.compilerVersion
        default: return nil
        }
    }
}
extension Google.Protobuf.Compiler.CodeGeneratorRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Google.Protobuf.Compiler.CodeGeneratorRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fileToGenerate": return self.fileToGenerate
            case "parameter": return self.parameter
            case "protoFile": return self.protoFile
            case "compilerVersion": return self.compilerVersion
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fileToGenerate":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.fileToGenerate = newSubscriptValue
            case "parameter":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.parameter = newSubscriptValue
            case "protoFile":
                guard let newSubscriptValue = newSubscriptValue as? Array<Google.Protobuf.FileDescriptorProto> else {
                    return
                }
                self.protoFile = newSubscriptValue
            case "compilerVersion":
                guard let newSubscriptValue = newSubscriptValue as? Google.Protobuf.Compiler.Version else {
                    return
                }
                self.compilerVersion = newSubscriptValue
            default: return
            }
        }
    }
}
extension Google.Protobuf.Compiler.CodeGeneratorResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.Compiler.CodeGeneratorResponse> {
        var mergedArray = Array<Google.Protobuf.Compiler.CodeGeneratorResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse? {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.Compiler.PluginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "error": return self.error
        case "file": return self.file
        default: return nil
        }
    }
}
extension Google.Protobuf.Compiler.CodeGeneratorResponse.File: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Google.Protobuf.Compiler.CodeGeneratorResponse.File> {
        var mergedArray = Array<Google.Protobuf.Compiler.CodeGeneratorResponse.File>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File? {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder().mergeFrom(data: data, extensionRegistry:Google.Protobuf.Compiler.PluginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Google.Protobuf.Compiler.CodeGeneratorResponse.File {
        return try Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "insertionPoint": return self.insertionPoint
        case "content": return self.content
        default: return nil
        }
    }
}
extension Google.Protobuf.Compiler.CodeGeneratorResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Google.Protobuf.Compiler.CodeGeneratorResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "error": return self.error
            case "file": return self.file
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "error":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.error = newSubscriptValue
            case "file":
                guard let newSubscriptValue = newSubscriptValue as? Array<Google.Protobuf.Compiler.CodeGeneratorResponse.File> else {
                    return
                }
                self.file = newSubscriptValue
            default: return
            }
        }
    }
}
extension Google.Protobuf.Compiler.CodeGeneratorResponse.File.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Google.Protobuf.Compiler.CodeGeneratorResponse.File
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "insertionPoint": return self.insertionPoint
            case "content": return self.content
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "insertionPoint":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.insertionPoint = newSubscriptValue
            case "content":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.content = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
