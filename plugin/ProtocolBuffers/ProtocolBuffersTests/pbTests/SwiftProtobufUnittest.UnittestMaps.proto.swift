// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "unittest_maps.proto"
// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct SwiftProtobufUnittest { }

public extension SwiftProtobufUnittest {
  public struct UnittestMapsRoot {
    public static let `default` = UnittestMapsRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
  }

  final public class MapMessageValue : GeneratedMessage {

    public static func == (lhs: SwiftProtobufUnittest.MapMessageValue, rhs: SwiftProtobufUnittest.MapMessageValue) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasValueInMapMessage == rhs.hasValueInMapMessage) && (!lhs.hasValueInMapMessage || lhs.valueInMapMessage == rhs.valueInMapMessage)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var valueInMapMessage:Int32 = Int32(0)
    public fileprivate(set) var hasValueInMapMessage:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasValueInMapMessage {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:valueInMapMessage)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasValueInMapMessage {
        serialize_size += valueInMapMessage.computeInt32Size(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> SwiftProtobufUnittest.MapMessageValue.Builder {
      return SwiftProtobufUnittest.MapMessageValue.classBuilder() as! SwiftProtobufUnittest.MapMessageValue.Builder
    }
    public func getBuilder() -> SwiftProtobufUnittest.MapMessageValue.Builder {
      return classBuilder() as! SwiftProtobufUnittest.MapMessageValue.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return SwiftProtobufUnittest.MapMessageValue.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return SwiftProtobufUnittest.MapMessageValue.Builder()
    }
    public func toBuilder() throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
      return try SwiftProtobufUnittest.MapMessageValue.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MapMessageValue) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
      return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasValueInMapMessage {
        jsonMap["valueInMapMessage"] = Int(valueInMapMessage)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasValueInMapMessage {
        output += "\(indent) valueInMapMessage: \(valueInMapMessage) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasValueInMapMessage {
               hashCode = (hashCode &* 31) &+ valueInMapMessage.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SwiftProtobufUnittest.MapMessageValue"
    }
    override public func className() -> String {
        return "SwiftProtobufUnittest.MapMessageValue"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:SwiftProtobufUnittest.MapMessageValue = SwiftProtobufUnittest.MapMessageValue()
      public func getMessage() -> SwiftProtobufUnittest.MapMessageValue {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasValueInMapMessage:Bool {
           get {
                return builderResult.hasValueInMapMessage
           }
      }
      public var valueInMapMessage:Int32 {
           get {
                return builderResult.valueInMapMessage
           }
           set (value) {
               builderResult.hasValueInMapMessage = true
               builderResult.valueInMapMessage = value
           }
      }
      @discardableResult
      public func setValueInMapMessage(_ value:Int32) -> SwiftProtobufUnittest.MapMessageValue.Builder {
        self.valueInMapMessage = value
        return self
      }
      @discardableResult
      public func clearValueInMapMessage() -> SwiftProtobufUnittest.MapMessageValue.Builder{
           builderResult.hasValueInMapMessage = false
           builderResult.valueInMapMessage = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> SwiftProtobufUnittest.MapMessageValue.Builder {
        builderResult = SwiftProtobufUnittest.MapMessageValue()
        return self
      }
      override public func clone() throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        return try SwiftProtobufUnittest.MapMessageValue.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> SwiftProtobufUnittest.MapMessageValue {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> SwiftProtobufUnittest.MapMessageValue {
        let returnMe:SwiftProtobufUnittest.MapMessageValue = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:SwiftProtobufUnittest.MapMessageValue) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        if other == SwiftProtobufUnittest.MapMessageValue() {
         return self
        }
        if other.hasValueInMapMessage {
             valueInMapMessage = other.valueInMapMessage
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            valueInMapMessage = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        let resultDecodedBuilder = SwiftProtobufUnittest.MapMessageValue.Builder()
        if let jsonValueValueInMapMessage = jsonMap["valueInMapMessage"] as? Int {
          resultDecodedBuilder.valueInMapMessage = Int32(jsonValueValueInMapMessage)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try SwiftProtobufUnittest.MapMessageValue.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class MessageContainsMap : GeneratedMessage {

    public static func == (lhs: SwiftProtobufUnittest.MessageContainsMap, rhs: SwiftProtobufUnittest.MessageContainsMap) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasMapInt32Int32 == rhs.hasMapInt32Int32) && (!lhs.hasMapInt32Int32 || lhs.mapInt32Int32 == rhs.mapInt32Int32)
      fieldCheck = fieldCheck && (lhs.hasMapInt64Int64 == rhs.hasMapInt64Int64) && (!lhs.hasMapInt64Int64 || lhs.mapInt64Int64 == rhs.mapInt64Int64)
      fieldCheck = fieldCheck && (lhs.hasMapStringString == rhs.hasMapStringString) && (!lhs.hasMapStringString || lhs.mapStringString == rhs.mapStringString)
      fieldCheck = fieldCheck && (lhs.hasMapStringBytes == rhs.hasMapStringBytes) && (!lhs.hasMapStringBytes || lhs.mapStringBytes == rhs.mapStringBytes)
      fieldCheck = fieldCheck && (lhs.hasMapStringMessage == rhs.hasMapStringMessage) && (!lhs.hasMapStringMessage || lhs.mapStringMessage == rhs.mapStringMessage)
      fieldCheck = fieldCheck && (lhs.hasMapInt32Enum == rhs.hasMapInt32Enum) && (!lhs.hasMapInt32Enum || lhs.mapInt32Enum == rhs.mapInt32Enum)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



    //Nested type declaration start

      final public class MapInt32Int32Entry : GeneratedMessage {

        public static func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
          fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var key:Int32 = Int32(0)
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:Int32 = Int32(0)
        public fileprivate(set) var hasValue:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasKey {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:key)
          }
          if hasValue {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:value)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeInt32Size(fieldNumber: 1)
          }
          if hasValue {
            serialize_size += value.computeInt32Size(fieldNumber: 2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasKey {
            jsonMap["key"] = Int(key)
          }
          if hasValue {
            jsonMap["value"] = Int(value)
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value: \(value) \n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry = SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:Int32 {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          @discardableResult
          public func setKey(_ value:Int32) -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            self.key = value
            return self
          }
          @discardableResult
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder{
               builderResult.hasKey = false
               builderResult.key = Int32(0)
               return self
          }
          public var hasValue:Bool {
               get {
                    return builderResult.hasValue
               }
          }
          public var value:Int32 {
               get {
                    return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          @discardableResult
          public func setValue(_ value:Int32) -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            self.value = value
            return self
          }
          @discardableResult
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder{
               builderResult.hasValue = false
               builderResult.value = Int32(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8:
                key = try codedInputStream.readInt32()

              case 16:
                value = try codedInputStream.readInt32()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder()
            if let jsonValueKey = jsonMap["key"] as? Int {
              resultDecodedBuilder.key = Int32(jsonValueKey)
            }
            if let jsonValueValue = jsonMap["value"] as? Int {
              resultDecodedBuilder.value = Int32(jsonValueValue)
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapInt64Int64Entry : GeneratedMessage {

        public static func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
          fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var key:Int64 = Int64(0)
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:Int64 = Int64(0)
        public fileprivate(set) var hasValue:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasKey {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:key)
          }
          if hasValue {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:value)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeInt64Size(fieldNumber: 1)
          }
          if hasValue {
            serialize_size += value.computeInt64Size(fieldNumber: 2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasKey {
            jsonMap["key"] = "\(key)"
          }
          if hasValue {
            jsonMap["value"] = "\(value)"
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value: \(value) \n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry = SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:Int64 {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          @discardableResult
          public func setKey(_ value:Int64) -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            self.key = value
            return self
          }
          @discardableResult
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder{
               builderResult.hasKey = false
               builderResult.key = Int64(0)
               return self
          }
          public var hasValue:Bool {
               get {
                    return builderResult.hasValue
               }
          }
          public var value:Int64 {
               get {
                    return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          @discardableResult
          public func setValue(_ value:Int64) -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            self.value = value
            return self
          }
          @discardableResult
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder{
               builderResult.hasValue = false
               builderResult.value = Int64(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8:
                key = try codedInputStream.readInt64()

              case 16:
                value = try codedInputStream.readInt64()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
              resultDecodedBuilder.key = Int64(jsonValueKey)!
            }
            if let jsonValueValue = jsonMap["value"] as? String {
              resultDecodedBuilder.value = Int64(jsonValueValue)!
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapStringStringEntry : GeneratedMessage {

        public static func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
          fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var key:String = ""
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:String = ""
        public fileprivate(set) var hasValue:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasKey {
            try codedOutputStream.writeString(fieldNumber: 1, value:key)
          }
          if hasValue {
            try codedOutputStream.writeString(fieldNumber: 2, value:value)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeStringSize(fieldNumber: 1)
          }
          if hasValue {
            serialize_size += value.computeStringSize(fieldNumber: 2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasKey {
            jsonMap["key"] = key
          }
          if hasValue {
            jsonMap["value"] = value
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value: \(value) \n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry = SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:String {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          @discardableResult
          public func setKey(_ value:String) -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            self.key = value
            return self
          }
          @discardableResult
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder{
               builderResult.hasKey = false
               builderResult.key = ""
               return self
          }
          public var hasValue:Bool {
               get {
                    return builderResult.hasValue
               }
          }
          public var value:String {
               get {
                    return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          @discardableResult
          public func setValue(_ value:String) -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            self.value = value
            return self
          }
          @discardableResult
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder{
               builderResult.hasValue = false
               builderResult.value = ""
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                key = try codedInputStream.readString()

              case 18:
                value = try codedInputStream.readString()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
              resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueValue = jsonMap["value"] as? String {
              resultDecodedBuilder.value = jsonValueValue
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapStringBytesEntry : GeneratedMessage {

        public static func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
          fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var key:String = ""
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:Data = Data()
        public fileprivate(set) var hasValue:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasKey {
            try codedOutputStream.writeString(fieldNumber: 1, value:key)
          }
          if hasValue {
            try codedOutputStream.writeData(fieldNumber: 2, value:value)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeStringSize(fieldNumber: 1)
          }
          if hasValue {
            serialize_size += value.computeDataSize(fieldNumber: 2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasKey {
            jsonMap["key"] = key
          }
          if hasValue {
            jsonMap["value"] = value.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value: \(value) \n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry = SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:String {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          @discardableResult
          public func setKey(_ value:String) -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            self.key = value
            return self
          }
          @discardableResult
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder{
               builderResult.hasKey = false
               builderResult.key = ""
               return self
          }
          public var hasValue:Bool {
               get {
                    return builderResult.hasValue
               }
          }
          public var value:Data {
               get {
                    return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          @discardableResult
          public func setValue(_ value:Data) -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            self.value = value
            return self
          }
          @discardableResult
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder{
               builderResult.hasValue = false
               builderResult.value = Data()
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                key = try codedInputStream.readString()

              case 18:
                value = try codedInputStream.readData()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
              resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueValue = jsonMap["value"] as? String {
              resultDecodedBuilder.value = Data(base64Encoded:jsonValueValue, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapStringMessageEntry : GeneratedMessage {

        public static func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
          fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var key:String = ""
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:SwiftProtobufUnittest.MapMessageValue!
        public fileprivate(set) var hasValue:Bool = false
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasKey {
            try codedOutputStream.writeString(fieldNumber: 1, value:key)
          }
          if hasValue {
            try codedOutputStream.writeMessage(fieldNumber: 2, value:value)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeStringSize(fieldNumber: 1)
          }
          if hasValue {
              if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
                  serialize_size += varSizevalue
              }
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasKey {
            jsonMap["key"] = key
          }
          if hasValue {
            jsonMap["value"] = try value.encode()
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value {\n"
            if let outDescValue = value {
              output += try outDescValue.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                    if let hashValuevalue = value?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevalue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry = SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:String {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          @discardableResult
          public func setKey(_ value:String) -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            self.key = value
            return self
          }
          @discardableResult
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder{
               builderResult.hasKey = false
               builderResult.key = ""
               return self
          }
          public var hasValue:Bool {
               get {
                   return builderResult.hasValue
               }
          }
          public var value:SwiftProtobufUnittest.MapMessageValue! {
               get {
                   if valueBuilder_ != nil {
                      builderResult.value = valueBuilder_.getMessage()
                   }
                   return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          fileprivate var valueBuilder_:SwiftProtobufUnittest.MapMessageValue.Builder! {
               didSet {
                  builderResult.hasValue = true
               }
          }
          public func getValueBuilder() -> SwiftProtobufUnittest.MapMessageValue.Builder {
            if valueBuilder_ == nil {
               valueBuilder_ = SwiftProtobufUnittest.MapMessageValue.Builder()
               builderResult.value = valueBuilder_.getMessage()
               if value != nil {
                  try! valueBuilder_.mergeFrom(other: value)
               }
            }
            return valueBuilder_
          }
          @discardableResult
          public func setValue(_ value:SwiftProtobufUnittest.MapMessageValue!) -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            self.value = value
            return self
          }
          @discardableResult
          public func mergeValue(value:SwiftProtobufUnittest.MapMessageValue) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            if builderResult.hasValue {
              builderResult.value = try SwiftProtobufUnittest.MapMessageValue.builderWithPrototype(prototype:builderResult.value).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.value = value
            }
            builderResult.hasValue = true
            return self
          }
          @discardableResult
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            valueBuilder_ = nil
            builderResult.hasValue = false
            builderResult.value = nil
            return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if (other.hasValue) {
                try mergeValue(value: other.value)
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                key = try codedInputStream.readString()

              case 18:
                let subBuilder:SwiftProtobufUnittest.MapMessageValue.Builder = SwiftProtobufUnittest.MapMessageValue.Builder()
                if hasValue {
                  try subBuilder.mergeFrom(other: value)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                value = subBuilder.buildPartial()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
              resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueValue = jsonMap["value"] as? Dictionary<String,Any> {
              resultDecodedBuilder.value = try SwiftProtobufUnittest.MapMessageValue.Builder.decodeToBuilder(jsonMap:jsonValueValue).build()

            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapInt32EnumEntry : GeneratedMessage {

        public static func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
          fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var key:Int32 = Int32(0)
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:SwiftProtobufUnittest.MessageContainsMap.EnumMapValue = SwiftProtobufUnittest.MessageContainsMap.EnumMapValue.firstValueEnum
        public fileprivate(set) var hasValue:Bool = false
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasKey {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:key)
          }
          if hasValue {
            try codedOutputStream.writeEnum(fieldNumber: 2, value:value.rawValue)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeInt32Size(fieldNumber: 1)
          }
          if (hasValue) {
            serialize_size += value.rawValue.computeEnumSize(fieldNumber: 2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasKey {
            jsonMap["key"] = Int(key)
          }
          if hasValue {
            jsonMap["value"] = value.toString()
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if (hasValue) {
            output += "\(indent) value: \(value.description)\n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ Int(value.rawValue)
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry = SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:Int32 {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          @discardableResult
          public func setKey(_ value:Int32) -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            self.key = value
            return self
          }
          @discardableResult
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder{
               builderResult.hasKey = false
               builderResult.key = Int32(0)
               return self
          }
            public var hasValue:Bool{
                get {
                    return builderResult.hasValue
                }
            }
            public var value:SwiftProtobufUnittest.MessageContainsMap.EnumMapValue {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.hasValue = true
                    builderResult.value = value
                }
            }
          @discardableResult
            public func setValue(_ value:SwiftProtobufUnittest.MessageContainsMap.EnumMapValue) -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
              self.value = value
              return self
            }
          @discardableResult
            public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
               builderResult.hasValue = false
               builderResult.value = .firstValueEnum
               return self
            }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8:
                key = try codedInputStream.readInt32()

              case 16:
                let valueIntvalue = try codedInputStream.readEnum()
                if let enumsvalue = SwiftProtobufUnittest.MessageContainsMap.EnumMapValue(rawValue:valueIntvalue){
                     value = enumsvalue
                } else {
                     try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntvalue))
                }

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder()
            if let jsonValueKey = jsonMap["key"] as? Int {
              resultDecodedBuilder.key = Int32(jsonValueKey)
            }
            if let jsonValueValue = jsonMap["value"] as? String {
              resultDecodedBuilder.value = try SwiftProtobufUnittest.MessageContainsMap.EnumMapValue.fromString(str: jsonValueValue)
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



      //Enum type declaration start 

      public enum EnumMapValue:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case firstValueEnum = 0
        case secondValueEnum = 1
        public func toString() -> String {
          switch self {
          case .firstValueEnum: return "FirstValueEnum"
          case .secondValueEnum: return "SecondValueEnum"
          }
        }
        public static func fromString(str:String) throws -> SwiftProtobufUnittest.MessageContainsMap.EnumMapValue {
          switch str {
          case "FirstValueEnum":  return .firstValueEnum
          case "SecondValueEnum":  return .secondValueEnum
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .firstValueEnum: return ".firstValueEnum"
          case .secondValueEnum: return ".secondValueEnum"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var hasMapInt32Int32:Bool = false
    public fileprivate(set) var mapInt32Int32:Dictionary<Int32,Int32> = Dictionary<Int32,Int32>()

    public fileprivate(set) var hasMapInt64Int64:Bool = false
    public fileprivate(set) var mapInt64Int64:Dictionary<Int64,Int64> = Dictionary<Int64,Int64>()

    public fileprivate(set) var hasMapStringString:Bool = false
    public fileprivate(set) var mapStringString:Dictionary<String,String> = Dictionary<String,String>()

    public fileprivate(set) var hasMapStringBytes:Bool = false
    public fileprivate(set) var mapStringBytes:Dictionary<String,Data> = Dictionary<String,Data>()

    public fileprivate(set) var hasMapStringMessage:Bool = false
    public fileprivate(set) var mapStringMessage:Dictionary<String,SwiftProtobufUnittest.MapMessageValue> = Dictionary<String,SwiftProtobufUnittest.MapMessageValue>()

    public fileprivate(set) var hasMapInt32Enum:Bool = false
    public fileprivate(set) var mapInt32Enum:Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue> = Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue>()

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasMapInt32Int32 {
          for (keyMapInt32Int32, valueMapInt32Int32) in mapInt32Int32 {
              let valueOfMapInt32Int32 = try! SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().setKey(keyMapInt32Int32).setValue(valueMapInt32Int32).build()
              try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfMapInt32Int32)
          }
      }
      if hasMapInt64Int64 {
          for (keyMapInt64Int64, valueMapInt64Int64) in mapInt64Int64 {
              let valueOfMapInt64Int64 = try! SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().setKey(keyMapInt64Int64).setValue(valueMapInt64Int64).build()
              try codedOutputStream.writeMessage(fieldNumber: 2, value:valueOfMapInt64Int64)
          }
      }
      if hasMapStringString {
          for (keyMapStringString, valueMapStringString) in mapStringString {
              let valueOfMapStringString = try! SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().setKey(keyMapStringString).setValue(valueMapStringString).build()
              try codedOutputStream.writeMessage(fieldNumber: 3, value:valueOfMapStringString)
          }
      }
      if hasMapStringBytes {
          for (keyMapStringBytes, valueMapStringBytes) in mapStringBytes {
              let valueOfMapStringBytes = try! SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().setKey(keyMapStringBytes).setValue(valueMapStringBytes).build()
              try codedOutputStream.writeMessage(fieldNumber: 4, value:valueOfMapStringBytes)
          }
      }
      if hasMapStringMessage {
          for (keyMapStringMessage, valueMapStringMessage) in mapStringMessage {
              let valueOfMapStringMessage = try! SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().setKey(keyMapStringMessage).setValue(valueMapStringMessage).build()
              try codedOutputStream.writeMessage(fieldNumber: 5, value:valueOfMapStringMessage)
          }
      }
      if hasMapInt32Enum {
          for (keyMapInt32Enum, valueMapInt32Enum) in mapInt32Enum {
              let valueOfMapInt32Enum = try! SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().setKey(keyMapInt32Enum).setValue(valueMapInt32Enum).build()
              try codedOutputStream.writeMessage(fieldNumber: 6, value:valueOfMapInt32Enum)
          }
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasMapInt32Int32 {
          for (keyMapInt32Int32, valueMapInt32Int32) in mapInt32Int32 {
              let valueOfMapInt32Int32 = try! SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().setKey(keyMapInt32Int32).setValue(valueMapInt32Int32).build()
              serialize_size += valueOfMapInt32Int32.computeMessageSize(fieldNumber: 1)
          }
      }
      if hasMapInt64Int64 {
          for (keyMapInt64Int64, valueMapInt64Int64) in mapInt64Int64 {
              let valueOfMapInt64Int64 = try! SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().setKey(keyMapInt64Int64).setValue(valueMapInt64Int64).build()
              serialize_size += valueOfMapInt64Int64.computeMessageSize(fieldNumber: 2)
          }
      }
      if hasMapStringString {
          for (keyMapStringString, valueMapStringString) in mapStringString {
              let valueOfMapStringString = try! SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().setKey(keyMapStringString).setValue(valueMapStringString).build()
              serialize_size += valueOfMapStringString.computeMessageSize(fieldNumber: 3)
          }
      }
      if hasMapStringBytes {
          for (keyMapStringBytes, valueMapStringBytes) in mapStringBytes {
              let valueOfMapStringBytes = try! SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().setKey(keyMapStringBytes).setValue(valueMapStringBytes).build()
              serialize_size += valueOfMapStringBytes.computeMessageSize(fieldNumber: 4)
          }
      }
      if hasMapStringMessage {
          for (keyMapStringMessage, valueMapStringMessage) in mapStringMessage {
              let valueOfMapStringMessage = try! SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().setKey(keyMapStringMessage).setValue(valueMapStringMessage).build()
              serialize_size += valueOfMapStringMessage.computeMessageSize(fieldNumber: 5)
          }
      }
      if hasMapInt32Enum {
          for (keyMapInt32Enum, valueMapInt32Enum) in mapInt32Enum {
              let valueOfMapInt32Enum = try! SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().setKey(keyMapInt32Enum).setValue(valueMapInt32Enum).build()
              serialize_size += valueOfMapInt32Enum.computeMessageSize(fieldNumber: 6)
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.Builder {
      return SwiftProtobufUnittest.MessageContainsMap.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.Builder
    }
    public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.Builder {
      return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return SwiftProtobufUnittest.MessageContainsMap.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return SwiftProtobufUnittest.MessageContainsMap.Builder()
    }
    public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
      return try SwiftProtobufUnittest.MessageContainsMap.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasMapInt32Int32 {
          var mapMapInt32Int32 = Dictionary<String, Int>()
          for (keyMapInt32Int32, valueMapInt32Int32) in mapInt32Int32 {
              mapMapInt32Int32["\(keyMapInt32Int32)"] = Int(valueMapInt32Int32)
          }
          jsonMap["mapInt32Int32"] = mapMapInt32Int32
      }
      if hasMapInt64Int64 {
          var mapMapInt64Int64 = Dictionary<String, String>()
          for (keyMapInt64Int64, valueMapInt64Int64) in mapInt64Int64 {
              mapMapInt64Int64["\(keyMapInt64Int64)"] = "\(valueMapInt64Int64)"
          }
          jsonMap["mapInt64Int64"] = mapMapInt64Int64
      }
      if hasMapStringString {
          var mapMapStringString = Dictionary<String, String>()
          for (keyMapStringString, valueMapStringString) in mapStringString {
              mapMapStringString["\(keyMapStringString)"] = valueMapStringString
          }
          jsonMap["mapStringString"] = mapMapStringString
      }
      if hasMapStringBytes {
          var mapMapStringBytes = Dictionary<String, String>()
          for (keyMapStringBytes, valueMapStringBytes) in mapStringBytes {
              mapMapStringBytes["\(keyMapStringBytes)"] = valueMapStringBytes.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
          }
          jsonMap["mapStringBytes"] = mapMapStringBytes
      }
      if hasMapStringMessage {
          var mapMapStringMessage = Dictionary<String, Dictionary<String,Any>>()
          for (keyMapStringMessage, valueMapStringMessage) in mapStringMessage {
              mapMapStringMessage["\(keyMapStringMessage)"] = try valueMapStringMessage.encode()
          }
          jsonMap["mapStringMessage"] = mapMapStringMessage
      }
      if hasMapInt32Enum {
          var mapMapInt32Enum = Dictionary<String, String>()
          for (keyMapInt32Enum, valueMapInt32Enum) in mapInt32Enum {
              mapMapInt32Enum["\(keyMapInt32Enum)"] = valueMapInt32Enum.toString()
          }
          jsonMap["mapInt32Enum"] = mapMapInt32Enum
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasMapInt32Int32 {
        output += "\(indent) mapInt32Int32: \(mapInt32Int32) \n"
      }
      if hasMapInt64Int64 {
        output += "\(indent) mapInt64Int64: \(mapInt64Int64) \n"
      }
      if hasMapStringString {
        output += "\(indent) mapStringString: \(mapStringString) \n"
      }
      if hasMapStringBytes {
        output += "\(indent) mapStringBytes: \(mapStringBytes) \n"
      }
      if hasMapStringMessage {
        output += "\(indent) mapStringMessage: \(mapStringMessage) \n"
      }
      if hasMapInt32Enum {
        output += "\(indent) mapInt32Enum: \(mapInt32Enum) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMapInt32Int32 {
                for (keyMapInt32Int32, valueMapInt32Int32) in mapInt32Int32 {
                    hashCode = (hashCode &* 31) &+ keyMapInt32Int32.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapInt32Int32.hashValue
                }
            }
            if hasMapInt64Int64 {
                for (keyMapInt64Int64, valueMapInt64Int64) in mapInt64Int64 {
                    hashCode = (hashCode &* 31) &+ keyMapInt64Int64.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapInt64Int64.hashValue
                }
            }
            if hasMapStringString {
                for (keyMapStringString, valueMapStringString) in mapStringString {
                    hashCode = (hashCode &* 31) &+ keyMapStringString.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapStringString.hashValue
                }
            }
            if hasMapStringBytes {
                for (keyMapStringBytes, valueMapStringBytes) in mapStringBytes {
                    hashCode = (hashCode &* 31) &+ keyMapStringBytes.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapStringBytes.hashValue
                }
            }
            if hasMapStringMessage {
                for (keyMapStringMessage, valueMapStringMessage) in mapStringMessage {
                    hashCode = (hashCode &* 31) &+ keyMapStringMessage.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapStringMessage.hashValue
                }
            }
            if hasMapInt32Enum {
                for (keyMapInt32Enum, valueMapInt32Enum) in mapInt32Enum {
                    hashCode = (hashCode &* 31) &+ keyMapInt32Enum.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapInt32Enum.hashValue
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SwiftProtobufUnittest.MessageContainsMap"
    }
    override public func className() -> String {
        return "SwiftProtobufUnittest.MessageContainsMap"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:SwiftProtobufUnittest.MessageContainsMap = SwiftProtobufUnittest.MessageContainsMap()
      public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasMapInt32Int32:Bool {
           get {
                return builderResult.hasMapInt32Int32
           }
      }
      public var mapInt32Int32:Dictionary<Int32,Int32> {
           get {
                return builderResult.mapInt32Int32
           }
           set (value) {
               builderResult.hasMapInt32Int32 = true
               builderResult.mapInt32Int32 = value
           }
      }
      @discardableResult
      public func setMapInt32Int32(_ value:Dictionary<Int32,Int32>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapInt32Int32 = value
        return self
      }
      @discardableResult
      public func clearMapInt32Int32() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapInt32Int32 = false
           builderResult.mapInt32Int32 = Dictionary<Int32,Int32>()
           return self
      }
      public var hasMapInt64Int64:Bool {
           get {
                return builderResult.hasMapInt64Int64
           }
      }
      public var mapInt64Int64:Dictionary<Int64,Int64> {
           get {
                return builderResult.mapInt64Int64
           }
           set (value) {
               builderResult.hasMapInt64Int64 = true
               builderResult.mapInt64Int64 = value
           }
      }
      @discardableResult
      public func setMapInt64Int64(_ value:Dictionary<Int64,Int64>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapInt64Int64 = value
        return self
      }
      @discardableResult
      public func clearMapInt64Int64() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapInt64Int64 = false
           builderResult.mapInt64Int64 = Dictionary<Int64,Int64>()
           return self
      }
      public var hasMapStringString:Bool {
           get {
                return builderResult.hasMapStringString
           }
      }
      public var mapStringString:Dictionary<String,String> {
           get {
                return builderResult.mapStringString
           }
           set (value) {
               builderResult.hasMapStringString = true
               builderResult.mapStringString = value
           }
      }
      @discardableResult
      public func setMapStringString(_ value:Dictionary<String,String>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapStringString = value
        return self
      }
      @discardableResult
      public func clearMapStringString() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapStringString = false
           builderResult.mapStringString = Dictionary<String,String>()
           return self
      }
      public var hasMapStringBytes:Bool {
           get {
                return builderResult.hasMapStringBytes
           }
      }
      public var mapStringBytes:Dictionary<String,Data> {
           get {
                return builderResult.mapStringBytes
           }
           set (value) {
               builderResult.hasMapStringBytes = true
               builderResult.mapStringBytes = value
           }
      }
      @discardableResult
      public func setMapStringBytes(_ value:Dictionary<String,Data>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapStringBytes = value
        return self
      }
      @discardableResult
      public func clearMapStringBytes() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapStringBytes = false
           builderResult.mapStringBytes = Dictionary<String,Data>()
           return self
      }
      public var hasMapStringMessage:Bool {
           get {
                return builderResult.hasMapStringMessage
           }
      }
      public var mapStringMessage:Dictionary<String,SwiftProtobufUnittest.MapMessageValue> {
           get {
                return builderResult.mapStringMessage
           }
           set (value) {
               builderResult.hasMapStringMessage = true
               builderResult.mapStringMessage = value
           }
      }
      @discardableResult
      public func setMapStringMessage(_ value:Dictionary<String,SwiftProtobufUnittest.MapMessageValue>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapStringMessage = value
        return self
      }
      @discardableResult
      public func clearMapStringMessage() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapStringMessage = false
           builderResult.mapStringMessage = Dictionary<String,SwiftProtobufUnittest.MapMessageValue>()
           return self
      }
      public var hasMapInt32Enum:Bool {
           get {
                return builderResult.hasMapInt32Enum
           }
      }
      public var mapInt32Enum:Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue> {
           get {
                return builderResult.mapInt32Enum
           }
           set (value) {
               builderResult.hasMapInt32Enum = true
               builderResult.mapInt32Enum = value
           }
      }
      @discardableResult
      public func setMapInt32Enum(_ value:Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapInt32Enum = value
        return self
      }
      @discardableResult
      public func clearMapInt32Enum() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapInt32Enum = false
           builderResult.mapInt32Enum = Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue>()
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        builderResult = SwiftProtobufUnittest.MessageContainsMap()
        return self
      }
      override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        return try SwiftProtobufUnittest.MessageContainsMap.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap {
        let returnMe:SwiftProtobufUnittest.MessageContainsMap = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        if other == SwiftProtobufUnittest.MessageContainsMap() {
         return self
        }
        if other.hasMapInt32Int32 {
             mapInt32Int32 = other.mapInt32Int32
        }
        if other.hasMapInt64Int64 {
             mapInt64Int64 = other.mapInt64Int64
        }
        if other.hasMapStringString {
             mapStringString = other.mapStringString
        }
        if other.hasMapStringBytes {
             mapStringBytes = other.mapStringBytes
        }
        if other.hasMapStringMessage {
             mapStringMessage = other.mapStringMessage
        }
        if other.hasMapInt32Enum {
             mapInt32Enum = other.mapInt32Enum
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder()
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            let buildOfMapInt32Int32 = subBuilder.buildPartial()
            mapInt32Int32[buildOfMapInt32Int32.key] = buildOfMapInt32Int32.value

          case 18:
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder()
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            let buildOfMapInt64Int64 = subBuilder.buildPartial()
            mapInt64Int64[buildOfMapInt64Int64.key] = buildOfMapInt64Int64.value

          case 26:
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder()
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            let buildOfMapStringString = subBuilder.buildPartial()
            mapStringString[buildOfMapStringString.key] = buildOfMapStringString.value

          case 34:
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder()
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            let buildOfMapStringBytes = subBuilder.buildPartial()
            mapStringBytes[buildOfMapStringBytes.key] = buildOfMapStringBytes.value

          case 42:
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder()
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            let buildOfMapStringMessage = subBuilder.buildPartial()
            mapStringMessage[buildOfMapStringMessage.key] = buildOfMapStringMessage.value

          case 50:
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder()
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            let buildOfMapInt32Enum = subBuilder.buildPartial()
            mapInt32Enum[buildOfMapInt32Enum.key] = buildOfMapInt32Enum.value

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.Builder()
        if let jsonValueMapInt32Int32 = jsonMap["mapInt32Int32"] as? Dictionary<String, Int> {
            var mapMapInt32Int32 = Dictionary<Int32, Int32>()
            for (keyMapInt32Int32, valueMapInt32Int32) in jsonValueMapInt32Int32 {
                let keyFromMapInt32Int32 = Int32(keyMapInt32Int32)!
                mapMapInt32Int32[keyFromMapInt32Int32] = Int32(valueMapInt32Int32)
            }
            resultDecodedBuilder.mapInt32Int32 = mapMapInt32Int32
        }
        if let jsonValueMapInt64Int64 = jsonMap["mapInt64Int64"] as? Dictionary<String, String> {
            var mapMapInt64Int64 = Dictionary<Int64, Int64>()
            for (keyMapInt64Int64, valueMapInt64Int64) in jsonValueMapInt64Int64 {
                let keyFromMapInt64Int64 = Int64(keyMapInt64Int64)!
                mapMapInt64Int64[keyFromMapInt64Int64] = Int64(valueMapInt64Int64)!
            }
            resultDecodedBuilder.mapInt64Int64 = mapMapInt64Int64
        }
        if let jsonValueMapStringString = jsonMap["mapStringString"] as? Dictionary<String, String> {
            var mapMapStringString = Dictionary<String, String>()
            for (keyMapStringString, valueMapStringString) in jsonValueMapStringString {
                let keyFromMapStringString = keyMapStringString
                mapMapStringString[keyFromMapStringString] = valueMapStringString
            }
            resultDecodedBuilder.mapStringString = mapMapStringString
        }
        if let jsonValueMapStringBytes = jsonMap["mapStringBytes"] as? Dictionary<String, String> {
            var mapMapStringBytes = Dictionary<String, Data>()
            for (keyMapStringBytes, valueMapStringBytes) in jsonValueMapStringBytes {
                let keyFromMapStringBytes = keyMapStringBytes
                mapMapStringBytes[keyFromMapStringBytes] = Data(base64Encoded:valueMapStringBytes, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            resultDecodedBuilder.mapStringBytes = mapMapStringBytes
        }
        if let jsonValueMapStringMessage = jsonMap["mapStringMessage"] as? Dictionary<String, Dictionary<String,Any>> {
            var mapMapStringMessage = Dictionary<String, SwiftProtobufUnittest.MapMessageValue>()
            for (keyMapStringMessage, valueMapStringMessage) in jsonValueMapStringMessage {
                let keyFromMapStringMessage = keyMapStringMessage
                mapMapStringMessage[keyFromMapStringMessage] = try SwiftProtobufUnittest.MapMessageValue.Builder.decodeToBuilder(jsonMap:valueMapStringMessage).build()

            }
            resultDecodedBuilder.mapStringMessage = mapMapStringMessage
        }
        if let jsonValueMapInt32Enum = jsonMap["mapInt32Enum"] as? Dictionary<String, String> {
            var mapMapInt32Enum = Dictionary<Int32, SwiftProtobufUnittest.MessageContainsMap.EnumMapValue>()
            for (keyMapInt32Enum, valueMapInt32Enum) in jsonValueMapInt32Enum {
                let keyFromMapInt32Enum = Int32(keyMapInt32Enum)!
                mapMapInt32Enum[keyFromMapInt32Enum] = try SwiftProtobufUnittest.MessageContainsMap.EnumMapValue.fromString(str: valueMapInt32Enum)
            }
            resultDecodedBuilder.mapInt32Enum = mapMapInt32Enum
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try SwiftProtobufUnittest.MessageContainsMap.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

}
extension SwiftProtobufUnittest.MapMessageValue: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SwiftProtobufUnittest.MapMessageValue> {
    var mergedArray = Array<SwiftProtobufUnittest.MapMessageValue>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MapMessageValue? {
    return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> SwiftProtobufUnittest.MapMessageValue {
    return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFrom(data: data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MapMessageValue {
    return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MapMessageValue {
    return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MapMessageValue {
    return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MapMessageValue {
    return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MapMessageValue {
    return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension SwiftProtobufUnittest.MessageContainsMap: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap> {
    var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap? {
    return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> SwiftProtobufUnittest.MessageContainsMap {
    return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFrom(data: data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap {
    return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap {
    return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap {
    return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap {
    return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap {
    return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry> {
    var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry? {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFrom(data: data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry> {
    var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry? {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFrom(data: data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry> {
    var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry? {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFrom(data: data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry> {
    var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry? {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFrom(data: data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry> {
    var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry? {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry> {
    var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry? {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFrom(data: data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
    return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
