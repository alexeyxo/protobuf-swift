// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file performance.proto

import Foundation
import ProtocolBuffers


public func == (lhs: PBUser, rhs: PBUser) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasGroup == rhs.hasGroup) && (!lhs.hasGroup || lhs.group == rhs.group)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBGroup, rhs: PBGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOwner == rhs.hasOwner) && (!lhs.hasOwner || lhs.owner == rhs.owner)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBPerfomanceBatch, rhs: PBPerfomanceBatch) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.batch == rhs.batch)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBPerfomance, rhs: PBPerfomance) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasInts == rhs.hasInts) && (!lhs.hasInts || lhs.ints == rhs.ints)
  fieldCheck = fieldCheck && (lhs.hasInts64 == rhs.hasInts64) && (!lhs.hasInts64 || lhs.ints64 == rhs.ints64)
  fieldCheck = fieldCheck && (lhs.hasDoubles == rhs.hasDoubles) && (!lhs.hasDoubles || lhs.doubles == rhs.doubles)
  fieldCheck = fieldCheck && (lhs.hasFloats == rhs.hasFloats) && (!lhs.hasFloats || lhs.floats == rhs.floats)
  fieldCheck = fieldCheck && (lhs.hasStr == rhs.hasStr) && (!lhs.hasStr || lhs.str == rhs.str)
  fieldCheck = fieldCheck && (lhs.hasBytes == rhs.hasBytes) && (!lhs.hasBytes || lhs.bytes == rhs.bytes)
  fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBProtoPoint, rhs: PBProtoPoint) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PBIceCreamCone, rhs: PBIceCreamCone) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasScoops == rhs.hasScoops) && (!lhs.hasScoops || lhs.scoops == rhs.scoops)
  fieldCheck = fieldCheck && (lhs.hasFlavor == rhs.hasFlavor) && (!lhs.hasFlavor || lhs.flavor == rhs.flavor)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct PerformanceRoot {
  public static var sharedInstance : PerformanceRoot {
   struct Static {
       static let instance : PerformanceRoot = PerformanceRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(registry: extensionRegistry)
    Google.Protobuf.SwiftDescriptorRoot.sharedInstance.registerAllExtensions(registry: extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final public class PBUser : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var group:PBGroup!
  public private(set) var hasGroup:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasGroup {
      try output.writeMessage(fieldNumber:1, value:group)
    }
    try unknownFields.writeToCodedOutputStream(output:output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasGroup {
        if let varSizegroup = group?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizegroup
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:InputStream) throws -> Array<PBUser> {
    var mergedArray = Array<PBUser>()
    while let value = try parseFromDelimitedFromInputStream(input: input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:InputStream) throws -> PBUser? {
    return try PBUser.Builder().mergeDelimitedFromInputStream(input: input)?.build()
  }
  public class func parseFromData(data:Data) throws -> PBUser {
    return try PBUser.Builder().mergeFromData(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:Data, extensionRegistry:ExtensionRegistry) throws -> PBUser {
    return try PBUser.Builder().mergeFromData(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:InputStream) throws -> PBUser {
    return try PBUser.Builder().mergeFromInputStream(input: input).build()
  }
  public class func parseFromInputStream(input:InputStream, extensionRegistry:ExtensionRegistry) throws -> PBUser {
    return try PBUser.Builder().mergeFromInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> PBUser {
    return try PBUser.Builder().mergeFromCodedInputStream(input: input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBUser {
    return try PBUser.Builder().mergeFromCodedInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBUser.Builder {
    return PBUser.classBuilder() as! PBUser.Builder
  }
  public func getBuilder() -> PBUser.Builder {
    return classBuilder() as! PBUser.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PBUser.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PBUser.Builder()
  }
  public func toBuilder() throws -> PBUser.Builder {
    return try PBUser.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:PBUser) throws -> PBUser.Builder {
    return try PBUser.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasGroup {
      output += "\(indent) group {\n"
      if let outDescGroup = group {
        output += try outDescGroup.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasGroup {
              if let hashValuegroup = group?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuegroup
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBUser"
  }
  override public func className() -> String {
      return "PBUser"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBUser.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBUser = PBUser()
    public func getMessage() -> PBUser {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasGroup:Bool {
         get {
             return builderResult.hasGroup
         }
    }
    public var group:PBGroup! {
         get {
             if groupBuilder_ != nil {
                builderResult.group = groupBuilder_.getMessage()
             }
             return builderResult.group
         }
         set (value) {
             builderResult.hasGroup = true
             builderResult.group = value
         }
    }
    private var groupBuilder_:PBGroup.Builder! {
         didSet {
            builderResult.hasGroup = true
         }
    }
    public func getGroupBuilder() -> PBGroup.Builder {
      if groupBuilder_ == nil {
         groupBuilder_ = PBGroup.Builder()
         builderResult.group = groupBuilder_.getMessage()
         if group != nil {
            _ = try! groupBuilder_.mergeFrom(other: group)
         }
      }
      return groupBuilder_
    }
    public func setGroup(value:PBGroup!) -> PBUser.Builder {
      self.group = value
      return self
    }
    public func mergeGroup(value:PBGroup) throws -> PBUser.Builder {
      if builderResult.hasGroup {
        builderResult.group = try PBGroup.builderWithPrototype(prototype: builderResult.group).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.group = value
      }
      builderResult.hasGroup = true
      return self
    }
    public func clearGroup() -> PBUser.Builder {
      groupBuilder_ = nil
      builderResult.hasGroup = false
      builderResult.group = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PBUser.Builder {
      builderResult = PBUser()
      return self
    }
    public override func clone() throws -> PBUser.Builder {
      return try PBUser.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> PBUser {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBUser {
      let returnMe:PBUser = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBUser) throws -> PBUser.Builder {
      if other == PBUser() {
       return self
      }
      if other.hasGroup {
          _ = try mergeGroup(value: other.group)
      }
      _ = try mergeUnknownFields(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> PBUser.Builder {
         return try mergeFromCodedInputStream(input: input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBUser.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:PBGroup.Builder = PBGroup.Builder()
          if hasGroup {
           _ = try subBuilder.mergeFrom(other: group)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          group = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input:input, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PBGroup : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var owner:PBUser!
  public private(set) var hasOwner:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasOwner {
      try output.writeMessage(fieldNumber:1, value:owner)
    }
    try unknownFields.writeToCodedOutputStream(output:output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasOwner {
        if let varSizeowner = owner?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizeowner
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:InputStream) throws -> Array<PBGroup> {
    var mergedArray = Array<PBGroup>()
    while let value = try parseFromDelimitedFromInputStream(input: input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:InputStream) throws -> PBGroup? {
    return try PBGroup.Builder().mergeDelimitedFromInputStream(input: input)?.build()
  }
  public class func parseFromData(data:Data) throws -> PBGroup {
    return try PBGroup.Builder().mergeFromData(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:Data, extensionRegistry:ExtensionRegistry) throws -> PBGroup {
    return try PBGroup.Builder().mergeFromData(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:InputStream) throws -> PBGroup {
    return try PBGroup.Builder().mergeFromInputStream(input: input).build()
  }
  public class func parseFromInputStream(input:InputStream, extensionRegistry:ExtensionRegistry) throws -> PBGroup {
    return try PBGroup.Builder().mergeFromInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> PBGroup {
    return try PBGroup.Builder().mergeFromCodedInputStream(input: input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBGroup {
    return try PBGroup.Builder().mergeFromCodedInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBGroup.Builder {
    return PBGroup.classBuilder() as! PBGroup.Builder
  }
  public func getBuilder() -> PBGroup.Builder {
    return classBuilder() as! PBGroup.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PBGroup.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PBGroup.Builder()
  }
  public func toBuilder() throws -> PBGroup.Builder {
    return try PBGroup.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:PBGroup) throws -> PBGroup.Builder {
    return try PBGroup.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasOwner {
      output += "\(indent) owner {\n"
      if let outDescOwner = owner {
        output += try outDescOwner.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasOwner {
              if let hashValueowner = owner?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueowner
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBGroup"
  }
  override public func className() -> String {
      return "PBGroup"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBGroup.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBGroup = PBGroup()
    public func getMessage() -> PBGroup {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasOwner:Bool {
         get {
             return builderResult.hasOwner
         }
    }
    public var owner:PBUser! {
         get {
             if ownerBuilder_ != nil {
                builderResult.owner = ownerBuilder_.getMessage()
             }
             return builderResult.owner
         }
         set (value) {
             builderResult.hasOwner = true
             builderResult.owner = value
         }
    }
    private var ownerBuilder_:PBUser.Builder! {
         didSet {
            builderResult.hasOwner = true
         }
    }
    public func getOwnerBuilder() -> PBUser.Builder {
      if ownerBuilder_ == nil {
         ownerBuilder_ = PBUser.Builder()
         builderResult.owner = ownerBuilder_.getMessage()
         if owner != nil {
            _ = try! ownerBuilder_.mergeFrom(other: owner)
         }
      }
      return ownerBuilder_
    }
    public func setOwner(value:PBUser!) -> PBGroup.Builder {
      self.owner = value
      return self
    }
    public func mergeOwner(value:PBUser) throws -> PBGroup.Builder {
      if builderResult.hasOwner {
        builderResult.owner = try PBUser.builderWithPrototype(prototype: builderResult.owner).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.owner = value
      }
      builderResult.hasOwner = true
      return self
    }
    public func clearOwner() -> PBGroup.Builder {
      ownerBuilder_ = nil
      builderResult.hasOwner = false
      builderResult.owner = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PBGroup.Builder {
      builderResult = PBGroup()
      return self
    }
    public override func clone() throws -> PBGroup.Builder {
      return try PBGroup.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> PBGroup {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBGroup {
      let returnMe:PBGroup = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBGroup) throws -> PBGroup.Builder {
      if other == PBGroup() {
       return self
      }
      if other.hasOwner {
          _ = try mergeOwner(value: other.owner)
      }
      _ = try mergeUnknownFields(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> PBGroup.Builder {
         return try mergeFromCodedInputStream(input: input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBGroup.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:PBUser.Builder = PBUser.Builder()
          if hasOwner {
           _ = try subBuilder.mergeFrom(other: owner)
          }
          try input.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          owner = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input:input, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PBPerfomanceBatch : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var batch:Array<PBPerfomance>  = Array<PBPerfomance>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitbatch:Bool = true
    for oneElementbatch in batch {
        if (!oneElementbatch.isInitialized()) {
            isInitbatch = false
            break 
        }
    }
    if !isInitbatch {
     return isInitbatch
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    for oneElementbatch in batch {
        try output.writeMessage(fieldNumber:1, value:oneElementbatch)
    }
    try unknownFields.writeToCodedOutputStream(output:output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementbatch in batch {
        serialize_size += oneElementbatch.computeMessageSize(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:InputStream) throws -> Array<PBPerfomanceBatch> {
    var mergedArray = Array<PBPerfomanceBatch>()
    while let value = try parseFromDelimitedFromInputStream(input: input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:InputStream) throws -> PBPerfomanceBatch? {
    return try PBPerfomanceBatch.Builder().mergeDelimitedFromInputStream(input: input)?.build()
  }
  public class func parseFromData(data:Data) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFromData(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:Data, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFromData(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:InputStream) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFromInputStream(input: input).build()
  }
  public class func parseFromInputStream(input:InputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFromInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFromCodedInputStream(input: input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch {
    return try PBPerfomanceBatch.Builder().mergeFromCodedInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBPerfomanceBatch.Builder {
    return PBPerfomanceBatch.classBuilder() as! PBPerfomanceBatch.Builder
  }
  public func getBuilder() -> PBPerfomanceBatch.Builder {
    return classBuilder() as! PBPerfomanceBatch.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PBPerfomanceBatch.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PBPerfomanceBatch.Builder()
  }
  public func toBuilder() throws -> PBPerfomanceBatch.Builder {
    return try PBPerfomanceBatch.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:PBPerfomanceBatch) throws -> PBPerfomanceBatch.Builder {
    return try PBPerfomanceBatch.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    var batchElementIndex:Int = 0
    for oneElementbatch in batch {
        output += "\(indent) batch[\(batchElementIndex)] {\n"
        output += try oneElementbatch.getDescription(indent:"\(indent)  ")
        output += "\(indent)}\n"
        batchElementIndex += 1
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementbatch in batch {
              hashCode = (hashCode &* 31) &+ oneElementbatch.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBPerfomanceBatch"
  }
  override public func className() -> String {
      return "PBPerfomanceBatch"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBPerfomanceBatch.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBPerfomanceBatch = PBPerfomanceBatch()
    public func getMessage() -> PBPerfomanceBatch {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var batch:Array<PBPerfomance> {
         get {
             return builderResult.batch
         }
         set (value) {
             builderResult.batch = value
         }
    }
    public func setBatch(value:Array<PBPerfomance>) -> PBPerfomanceBatch.Builder {
      self.batch = value
      return self
    }
    public func clearBatch() -> PBPerfomanceBatch.Builder {
      builderResult.batch.removeAll(keepingCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PBPerfomanceBatch.Builder {
      builderResult = PBPerfomanceBatch()
      return self
    }
    public override func clone() throws -> PBPerfomanceBatch.Builder {
      return try PBPerfomanceBatch.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> PBPerfomanceBatch {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBPerfomanceBatch {
      let returnMe:PBPerfomanceBatch = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBPerfomanceBatch) throws -> PBPerfomanceBatch.Builder {
      if other == PBPerfomanceBatch() {
       return self
      }
      if !other.batch.isEmpty  {
         builderResult.batch += other.batch
      }
      _ = try mergeUnknownFields(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> PBPerfomanceBatch.Builder {
         return try mergeFromCodedInputStream(input: input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder = PBPerfomance.Builder()
          try input.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
          batch += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input:input, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PBPerfomance : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var ints:Int32 = Int32(0)

  public private(set) var hasInts:Bool = false
  public private(set) var ints64:Int64 = Int64(0)

  public private(set) var hasInts64:Bool = false
  public private(set) var doubles:Double = Double(0)

  public private(set) var hasDoubles:Bool = false
  public private(set) var floats:Float = Float(0)

  public private(set) var hasFloats:Bool = false
  public private(set) var str:String = ""

  public private(set) var hasStr:Bool = false
  public private(set) var bytes:Data = Data()

  public private(set) var hasBytes:Bool = false
  public private(set) var description_:String = ""

  public private(set) var hasDescription:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasInts {
      return false
    }
    if !hasInts64 {
      return false
    }
    if !hasDoubles {
      return false
    }
    if !hasFloats {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasInts {
      try output.writeInt32(fieldNumber:1, value:ints)
    }
    if hasInts64 {
      try output.writeInt64(fieldNumber:2, value:ints64)
    }
    if hasDoubles {
      try output.writeDouble(fieldNumber:3, value:doubles)
    }
    if hasFloats {
      try output.writeFloat(fieldNumber:4, value:floats)
    }
    if hasStr {
      try output.writeString(fieldNumber:5, value:str)
    }
    if hasBytes {
      try output.writeData(fieldNumber:6, value:bytes)
    }
    if hasDescription {
      try output.writeString(fieldNumber:7, value:description_)
    }
    try unknownFields.writeToCodedOutputStream(output:output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasInts {
      serialize_size += ints.computeInt32Size(fieldNumber: 1)
    }
    if hasInts64 {
      serialize_size += ints64.computeInt64Size(fieldNumber: 2)
    }
    if hasDoubles {
      serialize_size += doubles.computeDoubleSize(fieldNumber: 3)
    }
    if hasFloats {
      serialize_size += floats.computeFloatSize(fieldNumber: 4)
    }
    if hasStr {
      serialize_size += str.computeStringSize(fieldNumber: 5)
    }
    if hasBytes {
      serialize_size += bytes.computeDataSize(fieldNumber: 6)
    }
    if hasDescription {
      serialize_size += description_.computeStringSize(fieldNumber: 7)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:InputStream) throws -> Array<PBPerfomance> {
    var mergedArray = Array<PBPerfomance>()
    while let value = try parseFromDelimitedFromInputStream(input: input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:InputStream) throws -> PBPerfomance? {
    return try PBPerfomance.Builder().mergeDelimitedFromInputStream(input: input)?.build()
  }
  public class func parseFromData(data:Data) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFromData(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:Data, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFromData(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:InputStream) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFromInputStream(input: input).build()
  }
  public class func parseFromInputStream(input:InputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFromInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFromCodedInputStream(input: input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance {
    return try PBPerfomance.Builder().mergeFromCodedInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBPerfomance.Builder {
    return PBPerfomance.classBuilder() as! PBPerfomance.Builder
  }
  public func getBuilder() -> PBPerfomance.Builder {
    return classBuilder() as! PBPerfomance.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PBPerfomance.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PBPerfomance.Builder()
  }
  public func toBuilder() throws -> PBPerfomance.Builder {
    return try PBPerfomance.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:PBPerfomance) throws -> PBPerfomance.Builder {
    return try PBPerfomance.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasInts {
      output += "\(indent) ints: \(ints) \n"
    }
    if hasInts64 {
      output += "\(indent) ints64: \(ints64) \n"
    }
    if hasDoubles {
      output += "\(indent) doubles: \(doubles) \n"
    }
    if hasFloats {
      output += "\(indent) floats: \(floats) \n"
    }
    if hasStr {
      output += "\(indent) str: \(str) \n"
    }
    if hasBytes {
      output += "\(indent) bytes: \(bytes) \n"
    }
    if hasDescription {
      output += "\(indent) description_: \(description_) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasInts {
             hashCode = (hashCode &* 31) &+ ints.hashValue
          }
          if hasInts64 {
             hashCode = (hashCode &* 31) &+ ints64.hashValue
          }
          if hasDoubles {
             hashCode = (hashCode &* 31) &+ doubles.hashValue
          }
          if hasFloats {
             hashCode = (hashCode &* 31) &+ floats.hashValue
          }
          if hasStr {
             hashCode = (hashCode &* 31) &+ str.hashValue
          }
          if hasBytes {
             hashCode = (hashCode &* 31) &+ bytes.hashValue
          }
          if hasDescription {
             hashCode = (hashCode &* 31) &+ description_.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBPerfomance"
  }
  override public func className() -> String {
      return "PBPerfomance"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBPerfomance.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBPerfomance = PBPerfomance()
    public func getMessage() -> PBPerfomance {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasInts:Bool {
         get {
              return builderResult.hasInts
         }
    }
    public var ints:Int32 {
         get {
              return builderResult.ints
         }
         set (value) {
             builderResult.hasInts = true
             builderResult.ints = value
         }
    }
    public func setInts(value:Int32) -> PBPerfomance.Builder {
      self.ints = value
      return self
    }
    public func clearInts() -> PBPerfomance.Builder{
         builderResult.hasInts = false
         builderResult.ints = Int32(0)
         return self
    }
    public var hasInts64:Bool {
         get {
              return builderResult.hasInts64
         }
    }
    public var ints64:Int64 {
         get {
              return builderResult.ints64
         }
         set (value) {
             builderResult.hasInts64 = true
             builderResult.ints64 = value
         }
    }
    public func setInts64(value:Int64) -> PBPerfomance.Builder {
      self.ints64 = value
      return self
    }
    public func clearInts64() -> PBPerfomance.Builder{
         builderResult.hasInts64 = false
         builderResult.ints64 = Int64(0)
         return self
    }
    public var hasDoubles:Bool {
         get {
              return builderResult.hasDoubles
         }
    }
    public var doubles:Double {
         get {
              return builderResult.doubles
         }
         set (value) {
             builderResult.hasDoubles = true
             builderResult.doubles = value
         }
    }
    public func setDoubles(value:Double) -> PBPerfomance.Builder {
      self.doubles = value
      return self
    }
    public func clearDoubles() -> PBPerfomance.Builder{
         builderResult.hasDoubles = false
         builderResult.doubles = Double(0)
         return self
    }
    public var hasFloats:Bool {
         get {
              return builderResult.hasFloats
         }
    }
    public var floats:Float {
         get {
              return builderResult.floats
         }
         set (value) {
             builderResult.hasFloats = true
             builderResult.floats = value
         }
    }
    public func setFloats(value:Float) -> PBPerfomance.Builder {
      self.floats = value
      return self
    }
    public func clearFloats() -> PBPerfomance.Builder{
         builderResult.hasFloats = false
         builderResult.floats = Float(0)
         return self
    }
    public var hasStr:Bool {
         get {
              return builderResult.hasStr
         }
    }
    public var str:String {
         get {
              return builderResult.str
         }
         set (value) {
             builderResult.hasStr = true
             builderResult.str = value
         }
    }
    public func setStr(value:String) -> PBPerfomance.Builder {
      self.str = value
      return self
    }
    public func clearStr() -> PBPerfomance.Builder{
         builderResult.hasStr = false
         builderResult.str = ""
         return self
    }
    public var hasBytes:Bool {
         get {
              return builderResult.hasBytes
         }
    }
    public var bytes:Data {
         get {
              return builderResult.bytes
         }
         set (value) {
             builderResult.hasBytes = true
             builderResult.bytes = value
         }
    }
    public func setBytes(value:Data) -> PBPerfomance.Builder {
      self.bytes = value
      return self
    }
    public func clearBytes() -> PBPerfomance.Builder{
         builderResult.hasBytes = false
         builderResult.bytes = Data()
         return self
    }
    public var hasDescription:Bool {
         get {
              return builderResult.hasDescription
         }
    }
    public var description_:String {
         get {
              return builderResult.description_
         }
         set (value) {
             builderResult.hasDescription = true
             builderResult.description_ = value
         }
    }
    public func setDescription(value:String) -> PBPerfomance.Builder {
      self.description_ = value
      return self
    }
    public func clearDescription() -> PBPerfomance.Builder{
         builderResult.hasDescription = false
         builderResult.description_ = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PBPerfomance.Builder {
      builderResult = PBPerfomance()
      return self
    }
    public override func clone() throws -> PBPerfomance.Builder {
      return try PBPerfomance.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> PBPerfomance {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBPerfomance {
      let returnMe:PBPerfomance = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBPerfomance) throws -> PBPerfomance.Builder {
      if other == PBPerfomance() {
       return self
      }
      if other.hasInts {
           ints = other.ints
      }
      if other.hasInts64 {
           ints64 = other.ints64
      }
      if other.hasDoubles {
           doubles = other.doubles
      }
      if other.hasFloats {
           floats = other.floats
      }
      if other.hasStr {
           str = other.str
      }
      if other.hasBytes {
           bytes = other.bytes
      }
      if other.hasDescription {
           description_ = other.description_
      }
      _ = try mergeUnknownFields(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> PBPerfomance.Builder {
         return try mergeFromCodedInputStream(input: input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          ints = try input.readInt32()

        case 16:
          ints64 = try input.readInt64()

        case 25:
          doubles = try input.readDouble()

        case 37:
          floats = try input.readFloat()

        case 42:
          str = try input.readString()

        case 50:
          bytes = try input.readData()

        case 58:
          description_ = try input.readString()

        default:
          if (!(try parseUnknownField(input:input, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PBProtoPoint : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var latitude:Float = Float(0)

  public private(set) var hasLatitude:Bool = false
  public private(set) var longitude:Float = Float(0)

  public private(set) var hasLongitude:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasLatitude {
      return false
    }
    if !hasLongitude {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasLatitude {
      try output.writeFloat(fieldNumber:1, value:latitude)
    }
    if hasLongitude {
      try output.writeFloat(fieldNumber:2, value:longitude)
    }
    try unknownFields.writeToCodedOutputStream(output:output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasLatitude {
      serialize_size += latitude.computeFloatSize(fieldNumber: 1)
    }
    if hasLongitude {
      serialize_size += longitude.computeFloatSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:InputStream) throws -> Array<PBProtoPoint> {
    var mergedArray = Array<PBProtoPoint>()
    while let value = try parseFromDelimitedFromInputStream(input: input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:InputStream) throws -> PBProtoPoint? {
    return try PBProtoPoint.Builder().mergeDelimitedFromInputStream(input: input)?.build()
  }
  public class func parseFromData(data:Data) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFromData(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:Data, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFromData(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:InputStream) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFromInputStream(input: input).build()
  }
  public class func parseFromInputStream(input:InputStream, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFromInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFromCodedInputStream(input: input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint {
    return try PBProtoPoint.Builder().mergeFromCodedInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBProtoPoint.Builder {
    return PBProtoPoint.classBuilder() as! PBProtoPoint.Builder
  }
  public func getBuilder() -> PBProtoPoint.Builder {
    return classBuilder() as! PBProtoPoint.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PBProtoPoint.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PBProtoPoint.Builder()
  }
  public func toBuilder() throws -> PBProtoPoint.Builder {
    return try PBProtoPoint.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:PBProtoPoint) throws -> PBProtoPoint.Builder {
    return try PBProtoPoint.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasLatitude {
      output += "\(indent) latitude: \(latitude) \n"
    }
    if hasLongitude {
      output += "\(indent) longitude: \(longitude) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLatitude {
             hashCode = (hashCode &* 31) &+ latitude.hashValue
          }
          if hasLongitude {
             hashCode = (hashCode &* 31) &+ longitude.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBProtoPoint"
  }
  override public func className() -> String {
      return "PBProtoPoint"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBProtoPoint.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBProtoPoint = PBProtoPoint()
    public func getMessage() -> PBProtoPoint {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasLatitude:Bool {
         get {
              return builderResult.hasLatitude
         }
    }
    public var latitude:Float {
         get {
              return builderResult.latitude
         }
         set (value) {
             builderResult.hasLatitude = true
             builderResult.latitude = value
         }
    }
    public func setLatitude(value:Float) -> PBProtoPoint.Builder {
      self.latitude = value
      return self
    }
    public func clearLatitude() -> PBProtoPoint.Builder{
         builderResult.hasLatitude = false
         builderResult.latitude = Float(0)
         return self
    }
    public var hasLongitude:Bool {
         get {
              return builderResult.hasLongitude
         }
    }
    public var longitude:Float {
         get {
              return builderResult.longitude
         }
         set (value) {
             builderResult.hasLongitude = true
             builderResult.longitude = value
         }
    }
    public func setLongitude(value:Float) -> PBProtoPoint.Builder {
      self.longitude = value
      return self
    }
    public func clearLongitude() -> PBProtoPoint.Builder{
         builderResult.hasLongitude = false
         builderResult.longitude = Float(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PBProtoPoint.Builder {
      builderResult = PBProtoPoint()
      return self
    }
    public override func clone() throws -> PBProtoPoint.Builder {
      return try PBProtoPoint.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> PBProtoPoint {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBProtoPoint {
      let returnMe:PBProtoPoint = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBProtoPoint) throws -> PBProtoPoint.Builder {
      if other == PBProtoPoint() {
       return self
      }
      if other.hasLatitude {
           latitude = other.latitude
      }
      if other.hasLongitude {
           longitude = other.longitude
      }
      _ = try mergeUnknownFields(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> PBProtoPoint.Builder {
         return try mergeFromCodedInputStream(input: input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 13:
          latitude = try input.readFloat()

        case 21:
          longitude = try input.readFloat()

        default:
          if (!(try parseUnknownField(input:input, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PBIceCreamCone : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum PBFlavor:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case Chocolate = 1
      case Vanilla = 2

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .Chocolate: return ".Chocolate"
              case .Vanilla: return ".Vanilla"
          }
      }
    }

    //Enum type declaration end 

  public private(set) var scoops:Int32 = Int32(0)

  public private(set) var hasScoops:Bool = false
  public private(set) var flavor:PBIceCreamCone.PBFlavor = PBIceCreamCone.PBFlavor.Chocolate
  public private(set) var hasFlavor:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasScoops {
      try output.writeInt32(fieldNumber:1, value:scoops)
    }
    if hasFlavor {
      try output.writeEnum(fieldNumber:2, value:flavor.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output:output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasScoops {
      serialize_size += scoops.computeInt32Size(fieldNumber: 1)
    }
    if (hasFlavor) {
      serialize_size += flavor.rawValue.computeEnumSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:InputStream) throws -> Array<PBIceCreamCone> {
    var mergedArray = Array<PBIceCreamCone>()
    while let value = try parseFromDelimitedFromInputStream(input: input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:InputStream) throws -> PBIceCreamCone? {
    return try PBIceCreamCone.Builder().mergeDelimitedFromInputStream(input: input)?.build()
  }
  public class func parseFromData(data:Data) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFromData(data: data, extensionRegistry:PerformanceRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:Data, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFromData(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:InputStream) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFromInputStream(input: input).build()
  }
  public class func parseFromInputStream(input:InputStream, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFromInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFromCodedInputStream(input: input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone {
    return try PBIceCreamCone.Builder().mergeFromCodedInputStream(input: input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> PBIceCreamCone.Builder {
    return PBIceCreamCone.classBuilder() as! PBIceCreamCone.Builder
  }
  public func getBuilder() -> PBIceCreamCone.Builder {
    return classBuilder() as! PBIceCreamCone.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return PBIceCreamCone.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return PBIceCreamCone.Builder()
  }
  public func toBuilder() throws -> PBIceCreamCone.Builder {
    return try PBIceCreamCone.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:PBIceCreamCone) throws -> PBIceCreamCone.Builder {
    return try PBIceCreamCone.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasScoops {
      output += "\(indent) scoops: \(scoops) \n"
    }
    if (hasFlavor) {
      output += "\(indent) flavor: \(flavor.description)\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasScoops {
             hashCode = (hashCode &* 31) &+ scoops.hashValue
          }
          if hasFlavor {
             hashCode = (hashCode &* 31) &+ Int(flavor.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBIceCreamCone"
  }
  override public func className() -> String {
      return "PBIceCreamCone"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBIceCreamCone.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PBIceCreamCone = PBIceCreamCone()
    public func getMessage() -> PBIceCreamCone {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasScoops:Bool {
         get {
              return builderResult.hasScoops
         }
    }
    public var scoops:Int32 {
         get {
              return builderResult.scoops
         }
         set (value) {
             builderResult.hasScoops = true
             builderResult.scoops = value
         }
    }
    public func setScoops(value:Int32) -> PBIceCreamCone.Builder {
      self.scoops = value
      return self
    }
    public func clearScoops() -> PBIceCreamCone.Builder{
         builderResult.hasScoops = false
         builderResult.scoops = Int32(0)
         return self
    }
      public var hasFlavor:Bool{
          get {
              return builderResult.hasFlavor
          }
      }
      public var flavor:PBIceCreamCone.PBFlavor {
          get {
              return builderResult.flavor
          }
          set (value) {
              builderResult.hasFlavor = true
              builderResult.flavor = value
          }
      }
      public func setFlavor(value:PBIceCreamCone.PBFlavor) -> PBIceCreamCone.Builder {
        self.flavor = value
        return self
      }
      public func clearFlavor() -> PBIceCreamCone.Builder {
         builderResult.hasFlavor = false
         builderResult.flavor = .Chocolate
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PBIceCreamCone.Builder {
      builderResult = PBIceCreamCone()
      return self
    }
    public override func clone() throws -> PBIceCreamCone.Builder {
      return try PBIceCreamCone.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> PBIceCreamCone {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PBIceCreamCone {
      let returnMe:PBIceCreamCone = builderResult
      return returnMe
    }
    public func mergeFrom(other:PBIceCreamCone) throws -> PBIceCreamCone.Builder {
      if other == PBIceCreamCone() {
       return self
      }
      if other.hasScoops {
           scoops = other.scoops
      }
      if other.hasFlavor {
           flavor = other.flavor
      }
      _ = try mergeUnknownFields(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> PBIceCreamCone.Builder {
         return try mergeFromCodedInputStream(input: input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          scoops = try input.readInt32()

        case 16:
          let valueIntflavor = try input.readEnum()
          if let enumsflavor = PBIceCreamCone.PBFlavor(rawValue:valueIntflavor){
               flavor = enumsflavor
          } else {
               _ = try unknownFieldsBuilder.mergeVarintField(number: 2, value:Int64(valueIntflavor))
          }

        default:
          if (!(try parseUnknownField(input:input, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}


// @@protoc_insertion_point(global_scope)
