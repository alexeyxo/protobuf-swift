/// Generated by the Protocol Buffers 3.6.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "performance.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


internal struct PerformanceRoot {
    internal static let `default` = PerformanceRoot()
    internal var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
        Google.Protobuf.SwiftDescriptorRoot.default.registerAllExtensions(registry: extensionRegistry)
    }
    internal func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final internal class PBUser : GeneratedMessage {
    internal typealias BuilderType = PBUser.Builder

    internal static func == (lhs: PBUser, rhs: PBUser) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasGroup == rhs.hasGroup) && (!lhs.hasGroup || lhs.group == rhs.group)
        fieldCheck = fieldCheck && (lhs.hasGroupName == rhs.hasGroupName) && (!lhs.hasGroupName || lhs.groupName == rhs.groupName)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    internal fileprivate(set) var group:PBGroup!
    internal fileprivate(set) var hasGroup:Bool = false
    internal fileprivate(set) var groupName:String! = nil
    internal fileprivate(set) var hasGroupName:Bool = false

    required internal init() {
        super.init()
    }
    override internal func isInitialized() throws {
    }
    override internal func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasGroup {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:group)
        }
        if hasGroupName {
            try codedOutputStream.writeString(fieldNumber: 2, value:groupName)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasGroup {
            if let varSizegroup = group?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizegroup
            }
        }
        if hasGroupName {
            serialize_size += groupName.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    internal class func getBuilder() -> PBUser.Builder {
        return PBUser.classBuilder() as! PBUser.Builder
    }
    internal func getBuilder() -> PBUser.Builder {
        return classBuilder() as! PBUser.Builder
    }
    override internal class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBUser.Builder()
    }
    override internal func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBUser.Builder()
    }
    internal func toBuilder() throws -> PBUser.Builder {
        return try PBUser.builderWithPrototype(prototype:self)
    }
    internal class func builderWithPrototype(prototype:PBUser) throws -> PBUser.Builder {
        return try PBUser.Builder().mergeFrom(other:prototype)
    }
    override internal func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasGroup {
            jsonMap["group"] = try group.encode()
        }
        if hasGroupName {
            jsonMap["groupName"] = groupName
        }
        return jsonMap
    }
    override class internal func decode(jsonMap:Dictionary<String,Any>) throws -> PBUser {
        return try PBUser.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class internal func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBUser {
        return try PBUser.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override internal func getDescription(indent:String) throws -> String {
        var output = ""
        if hasGroup {
            output += "\(indent) group {\n"
            if let outDescGroup = group {
                output += try outDescGroup.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasGroupName {
            output += "\(indent) groupName: \(String(describing: groupName)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasGroup {
                if let hashValuegroup = group?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegroup
                }
            }
            if hasGroupName {
                hashCode = (hashCode &* 31) &+ groupName.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "PBUser"
    }
    override internal func className() -> String {
        return "PBUser"
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PBUser = PBUser()
        internal func getMessage() -> PBUser {
            return builderResult
        }

        required override internal init () {
            super.init()
        }
        internal var group:PBGroup! {
            get {
                if groupBuilder_ != nil {
                    builderResult.group = groupBuilder_.getMessage()
                }
                return builderResult.group
            }
            set (value) {
                builderResult.hasGroup = value != nil
                builderResult.group = value
            }
        }
        internal var hasGroup:Bool {
            get {
                return builderResult.hasGroup
            }
        }
        fileprivate var groupBuilder_:PBGroup.Builder! {
            didSet {
                builderResult.hasGroup = true
            }
        }
        internal func getGroupBuilder() -> PBGroup.Builder {
            if groupBuilder_ == nil {
                groupBuilder_ = PBGroup.Builder()
                builderResult.group = groupBuilder_.getMessage()
                if group != nil {
                    try! groupBuilder_.mergeFrom(other: group)
                }
            }
            return groupBuilder_
        }
        @discardableResult
        internal func setGroup(_ value:PBGroup!) -> PBUser.Builder {
            self.group = value
            return self
        }
        @discardableResult
        internal func mergeGroup(value:PBGroup) throws -> PBUser.Builder {
            if builderResult.hasGroup {
                builderResult.group = try PBGroup.builderWithPrototype(prototype:builderResult.group).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.group = value
            }
            builderResult.hasGroup = true
            return self
        }
        @discardableResult
        internal func clearGroup() -> PBUser.Builder {
            groupBuilder_ = nil
            builderResult.hasGroup = false
            builderResult.group = nil
            return self
        }
        internal var groupName:String {
            get {
                return builderResult.groupName
            }
            set (value) {
                builderResult.hasGroupName = true
                builderResult.groupName = value
            }
        }
        internal var hasGroupName:Bool {
            get {
                return builderResult.hasGroupName
            }
        }
        @discardableResult
        internal func setGroupName(_ value:String) -> PBUser.Builder {
            self.groupName = value
            return self
        }
        @discardableResult
        internal func clearGroupName() -> PBUser.Builder{
            builderResult.hasGroupName = false
            builderResult.groupName = nil
            return self
        }
        override internal var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override internal func clear() -> PBUser.Builder {
            builderResult = PBUser()
            return self
        }
        override internal func clone() throws -> PBUser.Builder {
            return try PBUser.builderWithPrototype(prototype:builderResult)
        }
        override internal func build() throws -> PBUser {
            try checkInitialized()
            return buildPartial()
        }
        internal func buildPartial() -> PBUser {
            let returnMe:PBUser = builderResult
            return returnMe
        }
        @discardableResult
        internal func mergeFrom(other:PBUser) throws -> PBUser.Builder {
            if other == PBUser() {
                return self
            }
            if (other.hasGroup) {
                try mergeGroup(value: other.group)
            }
            if other.hasGroupName {
                groupName = other.groupName
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream) throws -> PBUser.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBUser.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:PBGroup.Builder = PBGroup.Builder()
                    if hasGroup {
                        try subBuilder.mergeFrom(other: group)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    group = subBuilder.buildPartial()

                case 18:
                    groupName = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override internal func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PBUser.Builder {
            let resultDecodedBuilder = PBUser.Builder()
            if let jsonValueGroup = jsonMap["group"] as? Dictionary<String,Any> {
                resultDecodedBuilder.group = try PBGroup.Builder.decodeToBuilder(jsonMap:jsonValueGroup).build()

            }
            if let jsonValueGroupName = jsonMap["groupName"] as? String {
                resultDecodedBuilder.groupName = jsonValueGroupName
            }
            return resultDecodedBuilder
        }
        override class internal func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBUser.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PBUser.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final internal class PBGroup : GeneratedMessage {
    internal typealias BuilderType = PBGroup.Builder

    internal static func == (lhs: PBGroup, rhs: PBGroup) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasOwner == rhs.hasOwner) && (!lhs.hasOwner || lhs.owner == rhs.owner)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    internal fileprivate(set) var owner:PBUser!
    internal fileprivate(set) var hasOwner:Bool = false
    required internal init() {
        super.init()
    }
    override internal func isInitialized() throws {
    }
    override internal func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasOwner {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:owner)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasOwner {
            if let varSizeowner = owner?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeowner
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    internal class func getBuilder() -> PBGroup.Builder {
        return PBGroup.classBuilder() as! PBGroup.Builder
    }
    internal func getBuilder() -> PBGroup.Builder {
        return classBuilder() as! PBGroup.Builder
    }
    override internal class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBGroup.Builder()
    }
    override internal func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBGroup.Builder()
    }
    internal func toBuilder() throws -> PBGroup.Builder {
        return try PBGroup.builderWithPrototype(prototype:self)
    }
    internal class func builderWithPrototype(prototype:PBGroup) throws -> PBGroup.Builder {
        return try PBGroup.Builder().mergeFrom(other:prototype)
    }
    override internal func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasOwner {
            jsonMap["owner"] = try owner.encode()
        }
        return jsonMap
    }
    override class internal func decode(jsonMap:Dictionary<String,Any>) throws -> PBGroup {
        return try PBGroup.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class internal func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBGroup {
        return try PBGroup.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override internal func getDescription(indent:String) throws -> String {
        var output = ""
        if hasOwner {
            output += "\(indent) owner {\n"
            if let outDescOwner = owner {
                output += try outDescOwner.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasOwner {
                if let hashValueowner = owner?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueowner
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "PBGroup"
    }
    override internal func className() -> String {
        return "PBGroup"
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PBGroup = PBGroup()
        internal func getMessage() -> PBGroup {
            return builderResult
        }

        required override internal init () {
            super.init()
        }
        internal var owner:PBUser! {
            get {
                if ownerBuilder_ != nil {
                    builderResult.owner = ownerBuilder_.getMessage()
                }
                return builderResult.owner
            }
            set (value) {
                builderResult.hasOwner = value != nil
                builderResult.owner = value
            }
        }
        internal var hasOwner:Bool {
            get {
                return builderResult.hasOwner
            }
        }
        fileprivate var ownerBuilder_:PBUser.Builder! {
            didSet {
                builderResult.hasOwner = true
            }
        }
        internal func getOwnerBuilder() -> PBUser.Builder {
            if ownerBuilder_ == nil {
                ownerBuilder_ = PBUser.Builder()
                builderResult.owner = ownerBuilder_.getMessage()
                if owner != nil {
                    try! ownerBuilder_.mergeFrom(other: owner)
                }
            }
            return ownerBuilder_
        }
        @discardableResult
        internal func setOwner(_ value:PBUser!) -> PBGroup.Builder {
            self.owner = value
            return self
        }
        @discardableResult
        internal func mergeOwner(value:PBUser) throws -> PBGroup.Builder {
            if builderResult.hasOwner {
                builderResult.owner = try PBUser.builderWithPrototype(prototype:builderResult.owner).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.owner = value
            }
            builderResult.hasOwner = true
            return self
        }
        @discardableResult
        internal func clearOwner() -> PBGroup.Builder {
            ownerBuilder_ = nil
            builderResult.hasOwner = false
            builderResult.owner = nil
            return self
        }
        override internal var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override internal func clear() -> PBGroup.Builder {
            builderResult = PBGroup()
            return self
        }
        override internal func clone() throws -> PBGroup.Builder {
            return try PBGroup.builderWithPrototype(prototype:builderResult)
        }
        override internal func build() throws -> PBGroup {
            try checkInitialized()
            return buildPartial()
        }
        internal func buildPartial() -> PBGroup {
            let returnMe:PBGroup = builderResult
            return returnMe
        }
        @discardableResult
        internal func mergeFrom(other:PBGroup) throws -> PBGroup.Builder {
            if other == PBGroup() {
                return self
            }
            if (other.hasOwner) {
                try mergeOwner(value: other.owner)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream) throws -> PBGroup.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBGroup.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:PBUser.Builder = PBUser.Builder()
                    if hasOwner {
                        try subBuilder.mergeFrom(other: owner)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    owner = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override internal func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PBGroup.Builder {
            let resultDecodedBuilder = PBGroup.Builder()
            if let jsonValueOwner = jsonMap["owner"] as? Dictionary<String,Any> {
                resultDecodedBuilder.owner = try PBUser.Builder.decodeToBuilder(jsonMap:jsonValueOwner).build()

            }
            return resultDecodedBuilder
        }
        override class internal func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBGroup.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PBGroup.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final internal class PBPerfomanceBatch : GeneratedMessage {
    internal typealias BuilderType = PBPerfomanceBatch.Builder

    internal static func == (lhs: PBPerfomanceBatch, rhs: PBPerfomanceBatch) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.batch == rhs.batch)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    internal fileprivate(set) var batch:Array<PBPerfomance>  = Array<PBPerfomance>()
    required internal init() {
        super.init()
    }
    override internal func isInitialized() throws {
        for oneElementBatch in batch {
            try oneElementBatch.isInitialized()
        }
    }
    override internal func writeTo(codedOutputStream: CodedOutputStream) throws {
        for oneElementBatch in batch {
              try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementBatch)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        for oneElementBatch in batch {
            serialize_size += oneElementBatch.computeMessageSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    internal class func getBuilder() -> PBPerfomanceBatch.Builder {
        return PBPerfomanceBatch.classBuilder() as! PBPerfomanceBatch.Builder
    }
    internal func getBuilder() -> PBPerfomanceBatch.Builder {
        return classBuilder() as! PBPerfomanceBatch.Builder
    }
    override internal class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBPerfomanceBatch.Builder()
    }
    override internal func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBPerfomanceBatch.Builder()
    }
    internal func toBuilder() throws -> PBPerfomanceBatch.Builder {
        return try PBPerfomanceBatch.builderWithPrototype(prototype:self)
    }
    internal class func builderWithPrototype(prototype:PBPerfomanceBatch) throws -> PBPerfomanceBatch.Builder {
        return try PBPerfomanceBatch.Builder().mergeFrom(other:prototype)
    }
    override internal func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if !batch.isEmpty {
            var jsonArrayBatch:Array<Dictionary<String,Any>> = []
            for oneValueBatch in batch {
                let ecodedMessageBatch = try oneValueBatch.encode()
                jsonArrayBatch.append(ecodedMessageBatch)
            }
            jsonMap["batch"] = jsonArrayBatch
        }
        return jsonMap
    }
    override class internal func decode(jsonMap:Dictionary<String,Any>) throws -> PBPerfomanceBatch {
        return try PBPerfomanceBatch.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class internal func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBPerfomanceBatch {
        return try PBPerfomanceBatch.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override internal func getDescription(indent:String) throws -> String {
        var output = ""
        var batchElementIndex:Int = 0
        for oneElementBatch in batch {
            output += "\(indent) batch[\(batchElementIndex)] {\n"
            output += try oneElementBatch.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            batchElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementBatch in batch {
                hashCode = (hashCode &* 31) &+ oneElementBatch.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "PBPerfomanceBatch"
    }
    override internal func className() -> String {
        return "PBPerfomanceBatch"
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PBPerfomanceBatch = PBPerfomanceBatch()
        internal func getMessage() -> PBPerfomanceBatch {
            return builderResult
        }

        required override internal init () {
            super.init()
        }
        internal var batch:Array<PBPerfomance> {
            get {
                return builderResult.batch
            }
            set (value) {
                builderResult.batch = value
            }
        }
        @discardableResult
        internal func setBatch(_ value:Array<PBPerfomance>) -> PBPerfomanceBatch.Builder {
            self.batch = value
            return self
        }
        @discardableResult
        internal func clearBatch() -> PBPerfomanceBatch.Builder {
            builderResult.batch.removeAll(keepingCapacity: false)
            return self
        }
        override internal var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override internal func clear() -> PBPerfomanceBatch.Builder {
            builderResult = PBPerfomanceBatch()
            return self
        }
        override internal func clone() throws -> PBPerfomanceBatch.Builder {
            return try PBPerfomanceBatch.builderWithPrototype(prototype:builderResult)
        }
        override internal func build() throws -> PBPerfomanceBatch {
            try checkInitialized()
            return buildPartial()
        }
        internal func buildPartial() -> PBPerfomanceBatch {
            let returnMe:PBPerfomanceBatch = builderResult
            return returnMe
        }
        @discardableResult
        internal func mergeFrom(other:PBPerfomanceBatch) throws -> PBPerfomanceBatch.Builder {
            if other == PBPerfomanceBatch() {
                return self
            }
            if !other.batch.isEmpty  {
                 builderResult.batch += other.batch
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream) throws -> PBPerfomanceBatch.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder = PBPerfomance.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    batch.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override internal func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PBPerfomanceBatch.Builder {
            let resultDecodedBuilder = PBPerfomanceBatch.Builder()
            if let jsonValueBatch = jsonMap["batch"] as? Array<Dictionary<String,Any>> {
                var jsonArrayBatch:Array<PBPerfomance> = []
                for oneValueBatch in jsonValueBatch {
                    let messageFromStringBatch = try PBPerfomance.Builder.decodeToBuilder(jsonMap:oneValueBatch).build()

                    jsonArrayBatch.append(messageFromStringBatch)
                }
                resultDecodedBuilder.batch = jsonArrayBatch
            }
            return resultDecodedBuilder
        }
        override class internal func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBPerfomanceBatch.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PBPerfomanceBatch.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final internal class PBPerfomance : GeneratedMessage {
    internal typealias BuilderType = PBPerfomance.Builder

    internal static func == (lhs: PBPerfomance, rhs: PBPerfomance) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasInts == rhs.hasInts) && (!lhs.hasInts || lhs.ints == rhs.ints)
        fieldCheck = fieldCheck && (lhs.hasInts64 == rhs.hasInts64) && (!lhs.hasInts64 || lhs.ints64 == rhs.ints64)
        fieldCheck = fieldCheck && (lhs.hasDoubles == rhs.hasDoubles) && (!lhs.hasDoubles || lhs.doubles == rhs.doubles)
        fieldCheck = fieldCheck && (lhs.hasFloats == rhs.hasFloats) && (!lhs.hasFloats || lhs.floats == rhs.floats)
        fieldCheck = fieldCheck && (lhs.hasStr == rhs.hasStr) && (!lhs.hasStr || lhs.str == rhs.str)
        fieldCheck = fieldCheck && (lhs.hasBytes == rhs.hasBytes) && (!lhs.hasBytes || lhs.bytes == rhs.bytes)
        fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    internal fileprivate(set) var ints:Int32! = nil
    internal fileprivate(set) var hasInts:Bool = false

    internal fileprivate(set) var ints64:Int64! = nil
    internal fileprivate(set) var hasInts64:Bool = false

    internal fileprivate(set) var doubles:Double! = nil
    internal fileprivate(set) var hasDoubles:Bool = false

    internal fileprivate(set) var floats:Float! = nil
    internal fileprivate(set) var hasFloats:Bool = false

    internal fileprivate(set) var str:String! = nil
    internal fileprivate(set) var hasStr:Bool = false

    internal fileprivate(set) var bytes:Data! = nil
    internal fileprivate(set) var hasBytes:Bool = false

    internal fileprivate(set) var description_:String! = nil
    internal fileprivate(set) var hasDescription:Bool = false

    required internal init() {
        super.init()
    }
    override internal func isInitialized() throws {
        if !hasInts {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(PBPerfomance.self): field \"ints\" mark required")
        }
        if !hasInts64 {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(PBPerfomance.self): field \"ints64\" mark required")
        }
        if !hasDoubles {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(PBPerfomance.self): field \"doubles\" mark required")
        }
        if !hasFloats {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(PBPerfomance.self): field \"floats\" mark required")
        }
    }
    override internal func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasInts {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:ints)
        }
        if hasInts64 {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:ints64)
        }
        if hasDoubles {
            try codedOutputStream.writeDouble(fieldNumber: 3, value:doubles)
        }
        if hasFloats {
            try codedOutputStream.writeFloat(fieldNumber: 4, value:floats)
        }
        if hasStr {
            try codedOutputStream.writeString(fieldNumber: 5, value:str)
        }
        if hasBytes {
            try codedOutputStream.writeData(fieldNumber: 6, value:bytes)
        }
        if hasDescription {
            try codedOutputStream.writeString(fieldNumber: 7, value:description_)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasInts {
            serialize_size += ints.computeInt32Size(fieldNumber: 1)
        }
        if hasInts64 {
            serialize_size += ints64.computeInt64Size(fieldNumber: 2)
        }
        if hasDoubles {
            serialize_size += doubles.computeDoubleSize(fieldNumber: 3)
        }
        if hasFloats {
            serialize_size += floats.computeFloatSize(fieldNumber: 4)
        }
        if hasStr {
            serialize_size += str.computeStringSize(fieldNumber: 5)
        }
        if hasBytes {
            serialize_size += bytes.computeDataSize(fieldNumber: 6)
        }
        if hasDescription {
            serialize_size += description_.computeStringSize(fieldNumber: 7)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    internal class func getBuilder() -> PBPerfomance.Builder {
        return PBPerfomance.classBuilder() as! PBPerfomance.Builder
    }
    internal func getBuilder() -> PBPerfomance.Builder {
        return classBuilder() as! PBPerfomance.Builder
    }
    override internal class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBPerfomance.Builder()
    }
    override internal func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBPerfomance.Builder()
    }
    internal func toBuilder() throws -> PBPerfomance.Builder {
        return try PBPerfomance.builderWithPrototype(prototype:self)
    }
    internal class func builderWithPrototype(prototype:PBPerfomance) throws -> PBPerfomance.Builder {
        return try PBPerfomance.Builder().mergeFrom(other:prototype)
    }
    override internal func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasInts {
            jsonMap["ints"] = Int(ints)
        }
        if hasInts64 {
            jsonMap["ints64"] = "\(ints64!)"
        }
        if hasDoubles {
            jsonMap["doubles"] = Double(doubles)
        }
        if hasFloats {
            jsonMap["floats"] = Float(floats)
        }
        if hasStr {
            jsonMap["str"] = str
        }
        if hasBytes {
            jsonMap["bytes"] = bytes.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        if hasDescription {
            jsonMap["description"] = description_
        }
        return jsonMap
    }
    override class internal func decode(jsonMap:Dictionary<String,Any>) throws -> PBPerfomance {
        return try PBPerfomance.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class internal func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBPerfomance {
        return try PBPerfomance.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override internal func getDescription(indent:String) throws -> String {
        var output = ""
        if hasInts {
            output += "\(indent) ints: \(String(describing: ints)) \n"
        }
        if hasInts64 {
            output += "\(indent) ints64: \(String(describing: ints64)) \n"
        }
        if hasDoubles {
            output += "\(indent) doubles: \(String(describing: doubles)) \n"
        }
        if hasFloats {
            output += "\(indent) floats: \(String(describing: floats)) \n"
        }
        if hasStr {
            output += "\(indent) str: \(String(describing: str)) \n"
        }
        if hasBytes {
            output += "\(indent) bytes: \(String(describing: bytes)) \n"
        }
        if hasDescription {
            output += "\(indent) description: \(String(describing: description_)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasInts {
                hashCode = (hashCode &* 31) &+ ints.hashValue
            }
            if hasInts64 {
                hashCode = (hashCode &* 31) &+ ints64.hashValue
            }
            if hasDoubles {
                hashCode = (hashCode &* 31) &+ doubles.hashValue
            }
            if hasFloats {
                hashCode = (hashCode &* 31) &+ floats.hashValue
            }
            if hasStr {
                hashCode = (hashCode &* 31) &+ str.hashValue
            }
            if hasBytes {
                hashCode = (hashCode &* 31) &+ bytes.hashValue
            }
            if hasDescription {
                hashCode = (hashCode &* 31) &+ description_.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "PBPerfomance"
    }
    override internal func className() -> String {
        return "PBPerfomance"
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PBPerfomance = PBPerfomance()
        internal func getMessage() -> PBPerfomance {
            return builderResult
        }

        required override internal init () {
            super.init()
        }
        internal var ints:Int32 {
            get {
                return builderResult.ints
            }
            set (value) {
                builderResult.hasInts = true
                builderResult.ints = value
            }
        }
        internal var hasInts:Bool {
            get {
                return builderResult.hasInts
            }
        }
        @discardableResult
        internal func setInts(_ value:Int32) -> PBPerfomance.Builder {
            self.ints = value
            return self
        }
        @discardableResult
        internal func clearInts() -> PBPerfomance.Builder{
            builderResult.hasInts = false
            builderResult.ints = nil
            return self
        }
        internal var ints64:Int64 {
            get {
                return builderResult.ints64
            }
            set (value) {
                builderResult.hasInts64 = true
                builderResult.ints64 = value
            }
        }
        internal var hasInts64:Bool {
            get {
                return builderResult.hasInts64
            }
        }
        @discardableResult
        internal func setInts64(_ value:Int64) -> PBPerfomance.Builder {
            self.ints64 = value
            return self
        }
        @discardableResult
        internal func clearInts64() -> PBPerfomance.Builder{
            builderResult.hasInts64 = false
            builderResult.ints64 = nil
            return self
        }
        internal var doubles:Double {
            get {
                return builderResult.doubles
            }
            set (value) {
                builderResult.hasDoubles = true
                builderResult.doubles = value
            }
        }
        internal var hasDoubles:Bool {
            get {
                return builderResult.hasDoubles
            }
        }
        @discardableResult
        internal func setDoubles(_ value:Double) -> PBPerfomance.Builder {
            self.doubles = value
            return self
        }
        @discardableResult
        internal func clearDoubles() -> PBPerfomance.Builder{
            builderResult.hasDoubles = false
            builderResult.doubles = nil
            return self
        }
        internal var floats:Float {
            get {
                return builderResult.floats
            }
            set (value) {
                builderResult.hasFloats = true
                builderResult.floats = value
            }
        }
        internal var hasFloats:Bool {
            get {
                return builderResult.hasFloats
            }
        }
        @discardableResult
        internal func setFloats(_ value:Float) -> PBPerfomance.Builder {
            self.floats = value
            return self
        }
        @discardableResult
        internal func clearFloats() -> PBPerfomance.Builder{
            builderResult.hasFloats = false
            builderResult.floats = nil
            return self
        }
        internal var str:String {
            get {
                return builderResult.str
            }
            set (value) {
                builderResult.hasStr = true
                builderResult.str = value
            }
        }
        internal var hasStr:Bool {
            get {
                return builderResult.hasStr
            }
        }
        @discardableResult
        internal func setStr(_ value:String) -> PBPerfomance.Builder {
            self.str = value
            return self
        }
        @discardableResult
        internal func clearStr() -> PBPerfomance.Builder{
            builderResult.hasStr = false
            builderResult.str = nil
            return self
        }
        internal var bytes:Data {
            get {
                return builderResult.bytes
            }
            set (value) {
                builderResult.hasBytes = true
                builderResult.bytes = value
            }
        }
        internal var hasBytes:Bool {
            get {
                return builderResult.hasBytes
            }
        }
        @discardableResult
        internal func setBytes(_ value:Data) -> PBPerfomance.Builder {
            self.bytes = value
            return self
        }
        @discardableResult
        internal func clearBytes() -> PBPerfomance.Builder{
            builderResult.hasBytes = false
            builderResult.bytes = nil
            return self
        }
        internal var description_:String {
            get {
                return builderResult.description_
            }
            set (value) {
                builderResult.hasDescription = true
                builderResult.description_ = value
            }
        }
        internal var hasDescription:Bool {
            get {
                return builderResult.hasDescription
            }
        }
        @discardableResult
        internal func setDescription(_ value:String) -> PBPerfomance.Builder {
            self.description_ = value
            return self
        }
        @discardableResult
        internal func clearDescription() -> PBPerfomance.Builder{
            builderResult.hasDescription = false
            builderResult.description_ = nil
            return self
        }
        override internal var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override internal func clear() -> PBPerfomance.Builder {
            builderResult = PBPerfomance()
            return self
        }
        override internal func clone() throws -> PBPerfomance.Builder {
            return try PBPerfomance.builderWithPrototype(prototype:builderResult)
        }
        override internal func build() throws -> PBPerfomance {
            try checkInitialized()
            return buildPartial()
        }
        internal func buildPartial() -> PBPerfomance {
            let returnMe:PBPerfomance = builderResult
            return returnMe
        }
        @discardableResult
        internal func mergeFrom(other:PBPerfomance) throws -> PBPerfomance.Builder {
            if other == PBPerfomance() {
                return self
            }
            if other.hasInts {
                ints = other.ints
            }
            if other.hasInts64 {
                ints64 = other.ints64
            }
            if other.hasDoubles {
                doubles = other.doubles
            }
            if other.hasFloats {
                floats = other.floats
            }
            if other.hasStr {
                str = other.str
            }
            if other.hasBytes {
                bytes = other.bytes
            }
            if other.hasDescription {
                description_ = other.description_
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream) throws -> PBPerfomance.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    ints = try codedInputStream.readInt32()

                case 16:
                    ints64 = try codedInputStream.readInt64()

                case 25:
                    doubles = try codedInputStream.readDouble()

                case 37:
                    floats = try codedInputStream.readFloat()

                case 42:
                    str = try codedInputStream.readString()

                case 50:
                    bytes = try codedInputStream.readData()

                case 58:
                    description_ = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override internal func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PBPerfomance.Builder {
            let resultDecodedBuilder = PBPerfomance.Builder()
            if let jsonValueInts = jsonMap["ints"] as? Int {
                resultDecodedBuilder.ints = Int32(jsonValueInts)
            } else if let jsonValueInts = jsonMap["ints"] as? String {
                resultDecodedBuilder.ints = Int32(jsonValueInts)!
            }
            if let jsonValueInts64 = jsonMap["ints64"] as? String {
                resultDecodedBuilder.ints64 = Int64(jsonValueInts64)!
            } else if let jsonValueInts64 = jsonMap["ints64"] as? Int {
                resultDecodedBuilder.ints64 = Int64(jsonValueInts64)
            }
            if let jsonValueDoubles = jsonMap["doubles"] as? Double {
                resultDecodedBuilder.doubles = Double(jsonValueDoubles)
            } else if let jsonValueDoubles = jsonMap["doubles"] as? String {
                resultDecodedBuilder.doubles = Double(jsonValueDoubles)!
            }
            if let jsonValueFloats = jsonMap["floats"] as? Float {
                resultDecodedBuilder.floats = Float(jsonValueFloats)
            } else if let jsonValueFloats = jsonMap["floats"] as? String {
                resultDecodedBuilder.floats = Float(jsonValueFloats)!
            }
            if let jsonValueStr = jsonMap["str"] as? String {
                resultDecodedBuilder.str = jsonValueStr
            }
            if let jsonValueBytes = jsonMap["bytes"] as? String {
                resultDecodedBuilder.bytes = Data(base64Encoded:jsonValueBytes, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            if let jsonValueDescription = jsonMap["description"] as? String {
                resultDecodedBuilder.description_ = jsonValueDescription
            }
            return resultDecodedBuilder
        }
        override class internal func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBPerfomance.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PBPerfomance.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final internal class PBProtoPoint : GeneratedMessage {
    internal typealias BuilderType = PBProtoPoint.Builder

    internal static func == (lhs: PBProtoPoint, rhs: PBProtoPoint) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
        fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    internal fileprivate(set) var latitude:Float! = nil
    internal fileprivate(set) var hasLatitude:Bool = false

    internal fileprivate(set) var longitude:Float! = nil
    internal fileprivate(set) var hasLongitude:Bool = false

    required internal init() {
        super.init()
    }
    override internal func isInitialized() throws {
        if !hasLatitude {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(PBProtoPoint.self): field \"latitude\" mark required")
        }
        if !hasLongitude {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(PBProtoPoint.self): field \"longitude\" mark required")
        }
    }
    override internal func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasLatitude {
            try codedOutputStream.writeFloat(fieldNumber: 1, value:latitude)
        }
        if hasLongitude {
            try codedOutputStream.writeFloat(fieldNumber: 2, value:longitude)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasLatitude {
            serialize_size += latitude.computeFloatSize(fieldNumber: 1)
        }
        if hasLongitude {
            serialize_size += longitude.computeFloatSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    internal class func getBuilder() -> PBProtoPoint.Builder {
        return PBProtoPoint.classBuilder() as! PBProtoPoint.Builder
    }
    internal func getBuilder() -> PBProtoPoint.Builder {
        return classBuilder() as! PBProtoPoint.Builder
    }
    override internal class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBProtoPoint.Builder()
    }
    override internal func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBProtoPoint.Builder()
    }
    internal func toBuilder() throws -> PBProtoPoint.Builder {
        return try PBProtoPoint.builderWithPrototype(prototype:self)
    }
    internal class func builderWithPrototype(prototype:PBProtoPoint) throws -> PBProtoPoint.Builder {
        return try PBProtoPoint.Builder().mergeFrom(other:prototype)
    }
    override internal func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasLatitude {
            jsonMap["latitude"] = Float(latitude)
        }
        if hasLongitude {
            jsonMap["longitude"] = Float(longitude)
        }
        return jsonMap
    }
    override class internal func decode(jsonMap:Dictionary<String,Any>) throws -> PBProtoPoint {
        return try PBProtoPoint.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class internal func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBProtoPoint {
        return try PBProtoPoint.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override internal func getDescription(indent:String) throws -> String {
        var output = ""
        if hasLatitude {
            output += "\(indent) latitude: \(String(describing: latitude)) \n"
        }
        if hasLongitude {
            output += "\(indent) longitude: \(String(describing: longitude)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasLatitude {
                hashCode = (hashCode &* 31) &+ latitude.hashValue
            }
            if hasLongitude {
                hashCode = (hashCode &* 31) &+ longitude.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "PBProtoPoint"
    }
    override internal func className() -> String {
        return "PBProtoPoint"
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PBProtoPoint = PBProtoPoint()
        internal func getMessage() -> PBProtoPoint {
            return builderResult
        }

        required override internal init () {
            super.init()
        }
        internal var latitude:Float {
            get {
                return builderResult.latitude
            }
            set (value) {
                builderResult.hasLatitude = true
                builderResult.latitude = value
            }
        }
        internal var hasLatitude:Bool {
            get {
                return builderResult.hasLatitude
            }
        }
        @discardableResult
        internal func setLatitude(_ value:Float) -> PBProtoPoint.Builder {
            self.latitude = value
            return self
        }
        @discardableResult
        internal func clearLatitude() -> PBProtoPoint.Builder{
            builderResult.hasLatitude = false
            builderResult.latitude = nil
            return self
        }
        internal var longitude:Float {
            get {
                return builderResult.longitude
            }
            set (value) {
                builderResult.hasLongitude = true
                builderResult.longitude = value
            }
        }
        internal var hasLongitude:Bool {
            get {
                return builderResult.hasLongitude
            }
        }
        @discardableResult
        internal func setLongitude(_ value:Float) -> PBProtoPoint.Builder {
            self.longitude = value
            return self
        }
        @discardableResult
        internal func clearLongitude() -> PBProtoPoint.Builder{
            builderResult.hasLongitude = false
            builderResult.longitude = nil
            return self
        }
        override internal var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override internal func clear() -> PBProtoPoint.Builder {
            builderResult = PBProtoPoint()
            return self
        }
        override internal func clone() throws -> PBProtoPoint.Builder {
            return try PBProtoPoint.builderWithPrototype(prototype:builderResult)
        }
        override internal func build() throws -> PBProtoPoint {
            try checkInitialized()
            return buildPartial()
        }
        internal func buildPartial() -> PBProtoPoint {
            let returnMe:PBProtoPoint = builderResult
            return returnMe
        }
        @discardableResult
        internal func mergeFrom(other:PBProtoPoint) throws -> PBProtoPoint.Builder {
            if other == PBProtoPoint() {
                return self
            }
            if other.hasLatitude {
                latitude = other.latitude
            }
            if other.hasLongitude {
                longitude = other.longitude
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream) throws -> PBProtoPoint.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 13:
                    latitude = try codedInputStream.readFloat()

                case 21:
                    longitude = try codedInputStream.readFloat()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override internal func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PBProtoPoint.Builder {
            let resultDecodedBuilder = PBProtoPoint.Builder()
            if let jsonValueLatitude = jsonMap["latitude"] as? Float {
                resultDecodedBuilder.latitude = Float(jsonValueLatitude)
            } else if let jsonValueLatitude = jsonMap["latitude"] as? String {
                resultDecodedBuilder.latitude = Float(jsonValueLatitude)!
            }
            if let jsonValueLongitude = jsonMap["longitude"] as? Float {
                resultDecodedBuilder.longitude = Float(jsonValueLongitude)
            } else if let jsonValueLongitude = jsonMap["longitude"] as? String {
                resultDecodedBuilder.longitude = Float(jsonValueLongitude)!
            }
            return resultDecodedBuilder
        }
        override class internal func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBProtoPoint.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PBProtoPoint.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final internal class PBIceCreamCone : GeneratedMessage {
    internal typealias BuilderType = PBIceCreamCone.Builder

    internal static func == (lhs: PBIceCreamCone, rhs: PBIceCreamCone) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasScoops == rhs.hasScoops) && (!lhs.hasScoops || lhs.scoops == rhs.scoops)
        fieldCheck = fieldCheck && (lhs.hasFlavor == rhs.hasFlavor) && (!lhs.hasFlavor || lhs.flavor == rhs.flavor)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



        //Enum type declaration start 

        internal enum PBFlavor:Int32, GeneratedEnum {
            case chocolate = 1
            case vanilla = 2
            internal func toString() -> String {
                switch self {
                case .chocolate: return "CHOCOLATE"
                case .vanilla: return "VANILLA"
                }
            }
            internal static func fromString(_ str:String) throws -> PBIceCreamCone.PBFlavor {
                switch str {
                case "CHOCOLATE":    return .chocolate
                case "VANILLA":    return .vanilla
                default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                }
            }
            internal var debugDescription:String { return getDescription() }
            internal var description:String { return getDescription() }
            private func getDescription() -> String { 
                switch self {
                case .chocolate: return ".chocolate"
                case .vanilla: return ".vanilla"
                }
            }
            internal var hashValue:Int {
                return self.rawValue.hashValue
            }
            internal static func ==(lhs:PBFlavor, rhs:PBFlavor) -> Bool {
                return lhs.hashValue == rhs.hashValue
            }
        }

        //Enum type declaration end 

    internal fileprivate(set) var scoops:Int32! = nil
    internal fileprivate(set) var hasScoops:Bool = false

    internal fileprivate(set) var flavor:PBIceCreamCone.PBFlavor = PBIceCreamCone.PBFlavor.chocolate
    internal fileprivate(set) var hasFlavor:Bool = false
    required internal init() {
        super.init()
    }
    override internal func isInitialized() throws {
    }
    override internal func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasScoops {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:scoops)
        }
        if hasFlavor {
            try codedOutputStream.writeEnum(fieldNumber: 2, value:flavor.rawValue)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasScoops {
            serialize_size += scoops.computeInt32Size(fieldNumber: 1)
        }
        if (hasFlavor) {
            serialize_size += flavor.rawValue.computeEnumSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    internal class func getBuilder() -> PBIceCreamCone.Builder {
        return PBIceCreamCone.classBuilder() as! PBIceCreamCone.Builder
    }
    internal func getBuilder() -> PBIceCreamCone.Builder {
        return classBuilder() as! PBIceCreamCone.Builder
    }
    override internal class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBIceCreamCone.Builder()
    }
    override internal func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBIceCreamCone.Builder()
    }
    internal func toBuilder() throws -> PBIceCreamCone.Builder {
        return try PBIceCreamCone.builderWithPrototype(prototype:self)
    }
    internal class func builderWithPrototype(prototype:PBIceCreamCone) throws -> PBIceCreamCone.Builder {
        return try PBIceCreamCone.Builder().mergeFrom(other:prototype)
    }
    override internal func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasScoops {
            jsonMap["scoops"] = Int(scoops)
        }
        if hasFlavor {
            jsonMap["flavor"] = flavor.toString()
        }
        return jsonMap
    }
    override class internal func decode(jsonMap:Dictionary<String,Any>) throws -> PBIceCreamCone {
        return try PBIceCreamCone.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class internal func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBIceCreamCone {
        return try PBIceCreamCone.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override internal func getDescription(indent:String) throws -> String {
        var output = ""
        if hasScoops {
            output += "\(indent) scoops: \(String(describing: scoops)) \n"
        }
        if (hasFlavor) {
            output += "\(indent) flavor: \(flavor.description)\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasScoops {
                hashCode = (hashCode &* 31) &+ scoops.hashValue
            }
            if hasFlavor {
                 hashCode = (hashCode &* 31) &+ flavor.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "PBIceCreamCone"
    }
    override internal func className() -> String {
        return "PBIceCreamCone"
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PBIceCreamCone = PBIceCreamCone()
        internal func getMessage() -> PBIceCreamCone {
            return builderResult
        }

        required override internal init () {
            super.init()
        }
        internal var scoops:Int32 {
            get {
                return builderResult.scoops
            }
            set (value) {
                builderResult.hasScoops = true
                builderResult.scoops = value
            }
        }
        internal var hasScoops:Bool {
            get {
                return builderResult.hasScoops
            }
        }
        @discardableResult
        internal func setScoops(_ value:Int32) -> PBIceCreamCone.Builder {
            self.scoops = value
            return self
        }
        @discardableResult
        internal func clearScoops() -> PBIceCreamCone.Builder{
            builderResult.hasScoops = false
            builderResult.scoops = nil
            return self
        }
            internal var flavor:PBIceCreamCone.PBFlavor {
                get {
                    return builderResult.flavor
                }
                set (value) {
                    builderResult.hasFlavor = true
                    builderResult.flavor = value
                }
            }
            internal var hasFlavor:Bool{
                get {
                    return builderResult.hasFlavor
                }
            }
        @discardableResult
            internal func setFlavor(_ value:PBIceCreamCone.PBFlavor) -> PBIceCreamCone.Builder {
              self.flavor = value
              return self
            }
        @discardableResult
            internal func clearFlavor() -> PBIceCreamCone.Builder {
               builderResult.hasFlavor = false
               builderResult.flavor = .chocolate
               return self
            }
        override internal var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override internal func clear() -> PBIceCreamCone.Builder {
            builderResult = PBIceCreamCone()
            return self
        }
        override internal func clone() throws -> PBIceCreamCone.Builder {
            return try PBIceCreamCone.builderWithPrototype(prototype:builderResult)
        }
        override internal func build() throws -> PBIceCreamCone {
            try checkInitialized()
            return buildPartial()
        }
        internal func buildPartial() -> PBIceCreamCone {
            let returnMe:PBIceCreamCone = builderResult
            return returnMe
        }
        @discardableResult
        internal func mergeFrom(other:PBIceCreamCone) throws -> PBIceCreamCone.Builder {
            if other == PBIceCreamCone() {
                return self
            }
            if other.hasScoops {
                scoops = other.scoops
            }
            if other.hasFlavor {
                flavor = other.flavor
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream) throws -> PBIceCreamCone.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    scoops = try codedInputStream.readInt32()

                case 16:
                    let valueIntflavor = try codedInputStream.readEnum()
                    if let enumsflavor = PBIceCreamCone.PBFlavor(rawValue:valueIntflavor){
                        flavor = enumsflavor
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntflavor))
                    }

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override internal func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PBIceCreamCone.Builder {
            let resultDecodedBuilder = PBIceCreamCone.Builder()
            if let jsonValueScoops = jsonMap["scoops"] as? Int {
                resultDecodedBuilder.scoops = Int32(jsonValueScoops)
            } else if let jsonValueScoops = jsonMap["scoops"] as? String {
                resultDecodedBuilder.scoops = Int32(jsonValueScoops)!
            }
            if let jsonValueFlavor = jsonMap["flavor"] as? String {
                resultDecodedBuilder.flavor = try PBIceCreamCone.PBFlavor.fromString(jsonValueFlavor)
            }
            return resultDecodedBuilder
        }
        override class internal func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBIceCreamCone.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PBIceCreamCone.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

///Subuilders
final internal class PBFoo : GeneratedMessage {
    internal typealias BuilderType = PBFoo.Builder

    internal static func == (lhs: PBFoo, rhs: PBFoo) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasVal == rhs.hasVal) && (!lhs.hasVal || lhs.val == rhs.val)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    /// some other fields.
    internal fileprivate(set) var val:Int32! = nil
    internal fileprivate(set) var hasVal:Bool = false

    required internal init() {
        super.init()
    }
    override internal func isInitialized() throws {
    }
    override internal func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasVal {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:val)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasVal {
            serialize_size += val.computeInt32Size(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    internal class func getBuilder() -> PBFoo.Builder {
        return PBFoo.classBuilder() as! PBFoo.Builder
    }
    internal func getBuilder() -> PBFoo.Builder {
        return classBuilder() as! PBFoo.Builder
    }
    override internal class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBFoo.Builder()
    }
    override internal func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBFoo.Builder()
    }
    internal func toBuilder() throws -> PBFoo.Builder {
        return try PBFoo.builderWithPrototype(prototype:self)
    }
    internal class func builderWithPrototype(prototype:PBFoo) throws -> PBFoo.Builder {
        return try PBFoo.Builder().mergeFrom(other:prototype)
    }
    override internal func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasVal {
            jsonMap["val"] = Int(val)
        }
        return jsonMap
    }
    override class internal func decode(jsonMap:Dictionary<String,Any>) throws -> PBFoo {
        return try PBFoo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class internal func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBFoo {
        return try PBFoo.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override internal func getDescription(indent:String) throws -> String {
        var output = ""
        if hasVal {
            output += "\(indent) val: \(String(describing: val)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVal {
                hashCode = (hashCode &* 31) &+ val.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "PBFoo"
    }
    override internal func className() -> String {
        return "PBFoo"
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PBFoo = PBFoo()
        internal func getMessage() -> PBFoo {
            return builderResult
        }

        required override internal init () {
            super.init()
        }
        /// some other fields.
        internal var val:Int32 {
            get {
                return builderResult.val
            }
            set (value) {
                builderResult.hasVal = true
                builderResult.val = value
            }
        }
        internal var hasVal:Bool {
            get {
                return builderResult.hasVal
            }
        }
        @discardableResult
        internal func setVal(_ value:Int32) -> PBFoo.Builder {
            self.val = value
            return self
        }
        @discardableResult
        internal func clearVal() -> PBFoo.Builder{
            builderResult.hasVal = false
            builderResult.val = nil
            return self
        }
        override internal var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override internal func clear() -> PBFoo.Builder {
            builderResult = PBFoo()
            return self
        }
        override internal func clone() throws -> PBFoo.Builder {
            return try PBFoo.builderWithPrototype(prototype:builderResult)
        }
        override internal func build() throws -> PBFoo {
            try checkInitialized()
            return buildPartial()
        }
        internal func buildPartial() -> PBFoo {
            let returnMe:PBFoo = builderResult
            return returnMe
        }
        @discardableResult
        internal func mergeFrom(other:PBFoo) throws -> PBFoo.Builder {
            if other == PBFoo() {
                return self
            }
            if other.hasVal {
                val = other.val
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream) throws -> PBFoo.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBFoo.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    val = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override internal func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PBFoo.Builder {
            let resultDecodedBuilder = PBFoo.Builder()
            if let jsonValueVal = jsonMap["val"] as? Int {
                resultDecodedBuilder.val = Int32(jsonValueVal)
            } else if let jsonValueVal = jsonMap["val"] as? String {
                resultDecodedBuilder.val = Int32(jsonValueVal)!
            }
            return resultDecodedBuilder
        }
        override class internal func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBFoo.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PBFoo.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final internal class PBBar : GeneratedMessage {
    internal typealias BuilderType = PBBar.Builder

    internal static func == (lhs: PBBar, rhs: PBBar) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasFoo == rhs.hasFoo) && (!lhs.hasFoo || lhs.foo == rhs.foo)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    internal fileprivate(set) var foo:PBFoo!
    internal fileprivate(set) var hasFoo:Bool = false
    required internal init() {
        super.init()
    }
    override internal func isInitialized() throws {
    }
    override internal func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasFoo {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:foo)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFoo {
            if let varSizefoo = foo?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizefoo
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    internal class func getBuilder() -> PBBar.Builder {
        return PBBar.classBuilder() as! PBBar.Builder
    }
    internal func getBuilder() -> PBBar.Builder {
        return classBuilder() as! PBBar.Builder
    }
    override internal class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBBar.Builder()
    }
    override internal func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBBar.Builder()
    }
    internal func toBuilder() throws -> PBBar.Builder {
        return try PBBar.builderWithPrototype(prototype:self)
    }
    internal class func builderWithPrototype(prototype:PBBar) throws -> PBBar.Builder {
        return try PBBar.Builder().mergeFrom(other:prototype)
    }
    override internal func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasFoo {
            jsonMap["foo"] = try foo.encode()
        }
        return jsonMap
    }
    override class internal func decode(jsonMap:Dictionary<String,Any>) throws -> PBBar {
        return try PBBar.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class internal func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBBar {
        return try PBBar.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override internal func getDescription(indent:String) throws -> String {
        var output = ""
        if hasFoo {
            output += "\(indent) foo {\n"
            if let outDescFoo = foo {
                output += try outDescFoo.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasFoo {
                if let hashValuefoo = foo?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuefoo
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "PBBar"
    }
    override internal func className() -> String {
        return "PBBar"
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PBBar = PBBar()
        internal func getMessage() -> PBBar {
            return builderResult
        }

        required override internal init () {
            super.init()
        }
        /// some other fields.
        internal var foo:PBFoo! {
            get {
                if fooBuilder_ != nil {
                    builderResult.foo = fooBuilder_.getMessage()
                }
                return builderResult.foo
            }
            set (value) {
                builderResult.hasFoo = value != nil
                builderResult.foo = value
            }
        }
        internal var hasFoo:Bool {
            get {
                return builderResult.hasFoo
            }
        }
        fileprivate var fooBuilder_:PBFoo.Builder! {
            didSet {
                builderResult.hasFoo = true
            }
        }
        internal func getFooBuilder() -> PBFoo.Builder {
            if fooBuilder_ == nil {
                fooBuilder_ = PBFoo.Builder()
                builderResult.foo = fooBuilder_.getMessage()
                if foo != nil {
                    try! fooBuilder_.mergeFrom(other: foo)
                }
            }
            return fooBuilder_
        }
        @discardableResult
        internal func setFoo(_ value:PBFoo!) -> PBBar.Builder {
            self.foo = value
            return self
        }
        @discardableResult
        internal func mergeFoo(value:PBFoo) throws -> PBBar.Builder {
            if builderResult.hasFoo {
                builderResult.foo = try PBFoo.builderWithPrototype(prototype:builderResult.foo).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.foo = value
            }
            builderResult.hasFoo = true
            return self
        }
        @discardableResult
        internal func clearFoo() -> PBBar.Builder {
            fooBuilder_ = nil
            builderResult.hasFoo = false
            builderResult.foo = nil
            return self
        }
        override internal var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override internal func clear() -> PBBar.Builder {
            builderResult = PBBar()
            return self
        }
        override internal func clone() throws -> PBBar.Builder {
            return try PBBar.builderWithPrototype(prototype:builderResult)
        }
        override internal func build() throws -> PBBar {
            try checkInitialized()
            return buildPartial()
        }
        internal func buildPartial() -> PBBar {
            let returnMe:PBBar = builderResult
            return returnMe
        }
        @discardableResult
        internal func mergeFrom(other:PBBar) throws -> PBBar.Builder {
            if other == PBBar() {
                return self
            }
            if (other.hasFoo) {
                try mergeFoo(value: other.foo)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream) throws -> PBBar.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBBar.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:PBFoo.Builder = PBFoo.Builder()
                    if hasFoo {
                        try subBuilder.mergeFrom(other: foo)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    foo = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override internal func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PBBar.Builder {
            let resultDecodedBuilder = PBBar.Builder()
            if let jsonValueFoo = jsonMap["foo"] as? Dictionary<String,Any> {
                resultDecodedBuilder.foo = try PBFoo.Builder.decodeToBuilder(jsonMap:jsonValueFoo).build()

            }
            return resultDecodedBuilder
        }
        override class internal func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBBar.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PBBar.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final internal class PBBaz : GeneratedMessage {
    internal typealias BuilderType = PBBaz.Builder

    internal static func == (lhs: PBBaz, rhs: PBBaz) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasBar == rhs.hasBar) && (!lhs.hasBar || lhs.bar == rhs.bar)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    internal fileprivate(set) var bar:PBBar!
    internal fileprivate(set) var hasBar:Bool = false
    required internal init() {
        super.init()
    }
    override internal func isInitialized() throws {
    }
    override internal func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasBar {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:bar)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasBar {
            if let varSizebar = bar?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizebar
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    internal class func getBuilder() -> PBBaz.Builder {
        return PBBaz.classBuilder() as! PBBaz.Builder
    }
    internal func getBuilder() -> PBBaz.Builder {
        return classBuilder() as! PBBaz.Builder
    }
    override internal class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBBaz.Builder()
    }
    override internal func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PBBaz.Builder()
    }
    internal func toBuilder() throws -> PBBaz.Builder {
        return try PBBaz.builderWithPrototype(prototype:self)
    }
    internal class func builderWithPrototype(prototype:PBBaz) throws -> PBBaz.Builder {
        return try PBBaz.Builder().mergeFrom(other:prototype)
    }
    override internal func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasBar {
            jsonMap["bar"] = try bar.encode()
        }
        return jsonMap
    }
    override class internal func decode(jsonMap:Dictionary<String,Any>) throws -> PBBaz {
        return try PBBaz.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class internal func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBBaz {
        return try PBBaz.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override internal func getDescription(indent:String) throws -> String {
        var output = ""
        if hasBar {
            output += "\(indent) bar {\n"
            if let outDescBar = bar {
                output += try outDescBar.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override internal var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasBar {
                if let hashValuebar = bar?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuebar
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override internal class func className() -> String {
        return "PBBaz"
    }
    override internal func className() -> String {
        return "PBBaz"
    }
    //Meta information declaration end

    final internal class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PBBaz = PBBaz()
        internal func getMessage() -> PBBaz {
            return builderResult
        }

        required override internal init () {
            super.init()
        }
        /// some other fields.
        internal var bar:PBBar! {
            get {
                if barBuilder_ != nil {
                    builderResult.bar = barBuilder_.getMessage()
                }
                return builderResult.bar
            }
            set (value) {
                builderResult.hasBar = value != nil
                builderResult.bar = value
            }
        }
        internal var hasBar:Bool {
            get {
                return builderResult.hasBar
            }
        }
        fileprivate var barBuilder_:PBBar.Builder! {
            didSet {
                builderResult.hasBar = true
            }
        }
        internal func getBarBuilder() -> PBBar.Builder {
            if barBuilder_ == nil {
                barBuilder_ = PBBar.Builder()
                builderResult.bar = barBuilder_.getMessage()
                if bar != nil {
                    try! barBuilder_.mergeFrom(other: bar)
                }
            }
            return barBuilder_
        }
        @discardableResult
        internal func setBar(_ value:PBBar!) -> PBBaz.Builder {
            self.bar = value
            return self
        }
        @discardableResult
        internal func mergeBar(value:PBBar) throws -> PBBaz.Builder {
            if builderResult.hasBar {
                builderResult.bar = try PBBar.builderWithPrototype(prototype:builderResult.bar).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.bar = value
            }
            builderResult.hasBar = true
            return self
        }
        @discardableResult
        internal func clearBar() -> PBBaz.Builder {
            barBuilder_ = nil
            builderResult.hasBar = false
            builderResult.bar = nil
            return self
        }
        override internal var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override internal func clear() -> PBBaz.Builder {
            builderResult = PBBaz()
            return self
        }
        override internal func clone() throws -> PBBaz.Builder {
            return try PBBaz.builderWithPrototype(prototype:builderResult)
        }
        override internal func build() throws -> PBBaz {
            try checkInitialized()
            return buildPartial()
        }
        internal func buildPartial() -> PBBaz {
            let returnMe:PBBaz = builderResult
            return returnMe
        }
        @discardableResult
        internal func mergeFrom(other:PBBaz) throws -> PBBaz.Builder {
            if other == PBBaz() {
                return self
            }
            if (other.hasBar) {
                try mergeBar(value: other.bar)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream) throws -> PBBaz.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override internal func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBBaz.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:PBBar.Builder = PBBar.Builder()
                    if hasBar {
                        try subBuilder.mergeFrom(other: bar)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    bar = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override internal func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PBBaz.Builder {
            let resultDecodedBuilder = PBBaz.Builder()
            if let jsonValueBar = jsonMap["bar"] as? Dictionary<String,Any> {
                resultDecodedBuilder.bar = try PBBar.Builder.decodeToBuilder(jsonMap:jsonValueBar).build()

            }
            return resultDecodedBuilder
        }
        override class internal func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PBBaz.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PBBaz.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension PBUser: GeneratedMessageProtocol {
    internal class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBUser> {
        var mergedArray = Array<PBUser>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    internal class func parseDelimitedFrom(inputStream: InputStream) throws -> PBUser? {
        return try PBUser.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    internal class func parseFrom(data: Data) throws -> PBUser {
        return try PBUser.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.default.extensionRegistry).build()
    }
    internal class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBUser {
        return try PBUser.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(inputStream: InputStream) throws -> PBUser {
        return try PBUser.Builder().mergeFrom(inputStream: inputStream).build()
    }
    internal class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBUser {
        return try PBUser.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream) throws -> PBUser {
        return try PBUser.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBUser {
        return try PBUser.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    internal subscript(key: String) -> Any? {
        switch key {
        case "group": return self.group
        case "groupName": return self.groupName
        default: return nil
        }
    }
}
extension PBUser.Builder: GeneratedMessageBuilderProtocol {
    internal typealias GeneratedMessageType = PBUser
    internal subscript(key: String) -> Any? {
        get { 
            switch key {
            case "group": return self.group
            case "groupName": return self.groupName
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "group":
                guard let newSubscriptValue = newSubscriptValue as? PBGroup else {
                    return
                }
                self.group = newSubscriptValue
            case "groupName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupName = newSubscriptValue
            default: return
            }
        }
    }
}
extension PBGroup: GeneratedMessageProtocol {
    internal class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBGroup> {
        var mergedArray = Array<PBGroup>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    internal class func parseDelimitedFrom(inputStream: InputStream) throws -> PBGroup? {
        return try PBGroup.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    internal class func parseFrom(data: Data) throws -> PBGroup {
        return try PBGroup.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.default.extensionRegistry).build()
    }
    internal class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBGroup {
        return try PBGroup.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(inputStream: InputStream) throws -> PBGroup {
        return try PBGroup.Builder().mergeFrom(inputStream: inputStream).build()
    }
    internal class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBGroup {
        return try PBGroup.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream) throws -> PBGroup {
        return try PBGroup.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBGroup {
        return try PBGroup.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    internal subscript(key: String) -> Any? {
        switch key {
        case "owner": return self.owner
        default: return nil
        }
    }
}
extension PBGroup.Builder: GeneratedMessageBuilderProtocol {
    internal typealias GeneratedMessageType = PBGroup
    internal subscript(key: String) -> Any? {
        get { 
            switch key {
            case "owner": return self.owner
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "owner":
                guard let newSubscriptValue = newSubscriptValue as? PBUser else {
                    return
                }
                self.owner = newSubscriptValue
            default: return
            }
        }
    }
}
extension PBPerfomanceBatch: GeneratedMessageProtocol {
    internal class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBPerfomanceBatch> {
        var mergedArray = Array<PBPerfomanceBatch>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    internal class func parseDelimitedFrom(inputStream: InputStream) throws -> PBPerfomanceBatch? {
        return try PBPerfomanceBatch.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    internal class func parseFrom(data: Data) throws -> PBPerfomanceBatch {
        return try PBPerfomanceBatch.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.default.extensionRegistry).build()
    }
    internal class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch {
        return try PBPerfomanceBatch.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(inputStream: InputStream) throws -> PBPerfomanceBatch {
        return try PBPerfomanceBatch.Builder().mergeFrom(inputStream: inputStream).build()
    }
    internal class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch {
        return try PBPerfomanceBatch.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream) throws -> PBPerfomanceBatch {
        return try PBPerfomanceBatch.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomanceBatch {
        return try PBPerfomanceBatch.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    internal subscript(key: String) -> Any? {
        switch key {
        case "batch": return self.batch
        default: return nil
        }
    }
}
extension PBPerfomanceBatch.Builder: GeneratedMessageBuilderProtocol {
    internal typealias GeneratedMessageType = PBPerfomanceBatch
    internal subscript(key: String) -> Any? {
        get { 
            switch key {
            case "batch": return self.batch
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "batch":
                guard let newSubscriptValue = newSubscriptValue as? Array<PBPerfomance> else {
                    return
                }
                self.batch = newSubscriptValue
            default: return
            }
        }
    }
}
extension PBPerfomance: GeneratedMessageProtocol {
    internal class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBPerfomance> {
        var mergedArray = Array<PBPerfomance>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    internal class func parseDelimitedFrom(inputStream: InputStream) throws -> PBPerfomance? {
        return try PBPerfomance.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    internal class func parseFrom(data: Data) throws -> PBPerfomance {
        return try PBPerfomance.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.default.extensionRegistry).build()
    }
    internal class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance {
        return try PBPerfomance.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(inputStream: InputStream) throws -> PBPerfomance {
        return try PBPerfomance.Builder().mergeFrom(inputStream: inputStream).build()
    }
    internal class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance {
        return try PBPerfomance.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream) throws -> PBPerfomance {
        return try PBPerfomance.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBPerfomance {
        return try PBPerfomance.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    internal subscript(key: String) -> Any? {
        switch key {
        case "ints": return self.ints
        case "ints64": return self.ints64
        case "doubles": return self.doubles
        case "floats": return self.floats
        case "str": return self.str
        case "bytes": return self.bytes
        case "description_": return self.description_
        default: return nil
        }
    }
}
extension PBPerfomance.Builder: GeneratedMessageBuilderProtocol {
    internal typealias GeneratedMessageType = PBPerfomance
    internal subscript(key: String) -> Any? {
        get { 
            switch key {
            case "ints": return self.ints
            case "ints64": return self.ints64
            case "doubles": return self.doubles
            case "floats": return self.floats
            case "str": return self.str
            case "bytes": return self.bytes
            case "description_": return self.description_
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "ints":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.ints = newSubscriptValue
            case "ints64":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.ints64 = newSubscriptValue
            case "doubles":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.doubles = newSubscriptValue
            case "floats":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.floats = newSubscriptValue
            case "str":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.str = newSubscriptValue
            case "bytes":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.bytes = newSubscriptValue
            case "description_":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.description_ = newSubscriptValue
            default: return
            }
        }
    }
}
extension PBProtoPoint: GeneratedMessageProtocol {
    internal class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBProtoPoint> {
        var mergedArray = Array<PBProtoPoint>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    internal class func parseDelimitedFrom(inputStream: InputStream) throws -> PBProtoPoint? {
        return try PBProtoPoint.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    internal class func parseFrom(data: Data) throws -> PBProtoPoint {
        return try PBProtoPoint.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.default.extensionRegistry).build()
    }
    internal class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint {
        return try PBProtoPoint.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(inputStream: InputStream) throws -> PBProtoPoint {
        return try PBProtoPoint.Builder().mergeFrom(inputStream: inputStream).build()
    }
    internal class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint {
        return try PBProtoPoint.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream) throws -> PBProtoPoint {
        return try PBProtoPoint.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBProtoPoint {
        return try PBProtoPoint.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    internal subscript(key: String) -> Any? {
        switch key {
        case "latitude": return self.latitude
        case "longitude": return self.longitude
        default: return nil
        }
    }
}
extension PBProtoPoint.Builder: GeneratedMessageBuilderProtocol {
    internal typealias GeneratedMessageType = PBProtoPoint
    internal subscript(key: String) -> Any? {
        get { 
            switch key {
            case "latitude": return self.latitude
            case "longitude": return self.longitude
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "latitude":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.latitude = newSubscriptValue
            case "longitude":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.longitude = newSubscriptValue
            default: return
            }
        }
    }
}
extension PBIceCreamCone: GeneratedMessageProtocol {
    internal class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBIceCreamCone> {
        var mergedArray = Array<PBIceCreamCone>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    internal class func parseDelimitedFrom(inputStream: InputStream) throws -> PBIceCreamCone? {
        return try PBIceCreamCone.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    internal class func parseFrom(data: Data) throws -> PBIceCreamCone {
        return try PBIceCreamCone.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.default.extensionRegistry).build()
    }
    internal class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone {
        return try PBIceCreamCone.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(inputStream: InputStream) throws -> PBIceCreamCone {
        return try PBIceCreamCone.Builder().mergeFrom(inputStream: inputStream).build()
    }
    internal class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone {
        return try PBIceCreamCone.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream) throws -> PBIceCreamCone {
        return try PBIceCreamCone.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBIceCreamCone {
        return try PBIceCreamCone.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    internal subscript(key: String) -> Any? {
        switch key {
        case "scoops": return self.scoops
        case "flavor": return self.flavor
        default: return nil
        }
    }
}
extension PBIceCreamCone.Builder: GeneratedMessageBuilderProtocol {
    internal typealias GeneratedMessageType = PBIceCreamCone
    internal subscript(key: String) -> Any? {
        get { 
            switch key {
            case "scoops": return self.scoops
            case "flavor": return self.flavor
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "scoops":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.scoops = newSubscriptValue
            case "flavor":
                guard let newSubscriptValue = newSubscriptValue as? PBIceCreamCone.PBFlavor else {
                    return
                }
                self.flavor = newSubscriptValue
            default: return
            }
        }
    }
}
extension PBFoo: GeneratedMessageProtocol {
    internal class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBFoo> {
        var mergedArray = Array<PBFoo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    internal class func parseDelimitedFrom(inputStream: InputStream) throws -> PBFoo? {
        return try PBFoo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    internal class func parseFrom(data: Data) throws -> PBFoo {
        return try PBFoo.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.default.extensionRegistry).build()
    }
    internal class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBFoo {
        return try PBFoo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(inputStream: InputStream) throws -> PBFoo {
        return try PBFoo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    internal class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBFoo {
        return try PBFoo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream) throws -> PBFoo {
        return try PBFoo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBFoo {
        return try PBFoo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    internal subscript(key: String) -> Any? {
        switch key {
        case "val": return self.val
        default: return nil
        }
    }
}
extension PBFoo.Builder: GeneratedMessageBuilderProtocol {
    internal typealias GeneratedMessageType = PBFoo
    internal subscript(key: String) -> Any? {
        get { 
            switch key {
            case "val": return self.val
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "val":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.val = newSubscriptValue
            default: return
            }
        }
    }
}
extension PBBar: GeneratedMessageProtocol {
    internal class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBBar> {
        var mergedArray = Array<PBBar>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    internal class func parseDelimitedFrom(inputStream: InputStream) throws -> PBBar? {
        return try PBBar.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    internal class func parseFrom(data: Data) throws -> PBBar {
        return try PBBar.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.default.extensionRegistry).build()
    }
    internal class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBBar {
        return try PBBar.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(inputStream: InputStream) throws -> PBBar {
        return try PBBar.Builder().mergeFrom(inputStream: inputStream).build()
    }
    internal class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBBar {
        return try PBBar.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream) throws -> PBBar {
        return try PBBar.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBBar {
        return try PBBar.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    internal subscript(key: String) -> Any? {
        switch key {
        case "foo": return self.foo
        default: return nil
        }
    }
}
extension PBBar.Builder: GeneratedMessageBuilderProtocol {
    internal typealias GeneratedMessageType = PBBar
    internal subscript(key: String) -> Any? {
        get { 
            switch key {
            case "foo": return self.foo
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "foo":
                guard let newSubscriptValue = newSubscriptValue as? PBFoo else {
                    return
                }
                self.foo = newSubscriptValue
            default: return
            }
        }
    }
}
extension PBBaz: GeneratedMessageProtocol {
    internal class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PBBaz> {
        var mergedArray = Array<PBBaz>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    internal class func parseDelimitedFrom(inputStream: InputStream) throws -> PBBaz? {
        return try PBBaz.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    internal class func parseFrom(data: Data) throws -> PBBaz {
        return try PBBaz.Builder().mergeFrom(data: data, extensionRegistry:PerformanceRoot.default.extensionRegistry).build()
    }
    internal class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PBBaz {
        return try PBBaz.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(inputStream: InputStream) throws -> PBBaz {
        return try PBBaz.Builder().mergeFrom(inputStream: inputStream).build()
    }
    internal class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PBBaz {
        return try PBBaz.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream) throws -> PBBaz {
        return try PBBaz.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    internal class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PBBaz {
        return try PBBaz.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    internal subscript(key: String) -> Any? {
        switch key {
        case "bar": return self.bar
        default: return nil
        }
    }
}
extension PBBaz.Builder: GeneratedMessageBuilderProtocol {
    internal typealias GeneratedMessageType = PBBaz
    internal subscript(key: String) -> Any? {
        get { 
            switch key {
            case "bar": return self.bar
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "bar":
                guard let newSubscriptValue = newSubscriptValue as? PBBar else {
                    return
                }
                self.bar = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
