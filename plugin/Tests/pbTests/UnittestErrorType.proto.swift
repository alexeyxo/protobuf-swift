/// Generated by the Protocol Buffers 3.6.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "unittest_error_type.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct UnittestErrorTypeRoot {
    public static let `default` = UnittestErrorTypeRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
        Google.Protobuf.SwiftDescriptorRoot.default.registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}



//Enum type declaration start 

public enum ServiceError:Error, GeneratedEnum {
    public typealias RawValue = Int32

    case badRequest
    case internalServerError

    public init?(rawValue: RawValue) {
        switch rawValue {
        case 0: self = .badRequest
        case 1: self = .internalServerError
        default: return nil
        }
    }

    public var rawValue: RawValue {
        switch self {
        case .badRequest: return 0
        case .internalServerError: return 1
        }
    }

    public func throwException() throws {
        throw self
    }
    public func toString() -> String {
        switch self {
        case .badRequest: return "BadRequest"
        case .internalServerError: return "InternalServerError"
        }
    }
    public static func fromString(_ str:String) throws -> ServiceError {
        switch str {
        case "BadRequest":    return .badRequest
        case "InternalServerError":    return .internalServerError
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
        }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
        case .badRequest: return ".badRequest"
        case .internalServerError: return ".internalServerError"
        }
    }
    public var hashValue:Int {
        return self.rawValue.hashValue
    }
    public static func ==(lhs:ServiceError, rhs:ServiceError) -> Bool {
        return lhs.hashValue == rhs.hashValue
    }
}

//Enum type declaration end 

final public class UserProfile : GeneratedMessage {
    public typealias BuilderType = UserProfile.Builder

    public static func == (lhs: UserProfile, rhs: UserProfile) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasFirstName == rhs.hasFirstName) && (!lhs.hasFirstName || lhs.firstName == rhs.firstName)
        fieldCheck = fieldCheck && (lhs.hasLastName == rhs.hasLastName) && (!lhs.hasLastName || lhs.lastName == rhs.lastName)
        fieldCheck = fieldCheck && (lhs.hasAvatarUrl == rhs.hasAvatarUrl) && (!lhs.hasAvatarUrl || lhs.avatarUrl == rhs.avatarUrl)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



    //Nested type declaration start

    final public class Request : GeneratedMessage {
        public typealias BuilderType = UserProfile.Request.Builder

        public static func == (lhs: UserProfile.Request, rhs: UserProfile.Request) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:String! = nil
        public fileprivate(set) var hasUserId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
            if !hasUserId {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(UserProfile.Request.self): field \"userId\" mark required")
            }
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeString(fieldNumber: 1, value:userId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> UserProfile.Request.Builder {
            return UserProfile.Request.classBuilder() as! UserProfile.Request.Builder
        }
        public func getBuilder() -> UserProfile.Request.Builder {
            return classBuilder() as! UserProfile.Request.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return UserProfile.Request.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return UserProfile.Request.Builder()
        }
        public func toBuilder() throws -> UserProfile.Request.Builder {
            return try UserProfile.Request.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:UserProfile.Request) throws -> UserProfile.Request.Builder {
            return try UserProfile.Request.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = userId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Request {
            return try UserProfile.Request.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> UserProfile.Request {
            return try UserProfile.Request.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(String(describing: userId)) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "UserProfile.Request"
        }
        override public func className() -> String {
            return "UserProfile.Request"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:UserProfile.Request = UserProfile.Request()
            public func getMessage() -> UserProfile.Request {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:String {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:String) -> UserProfile.Request.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> UserProfile.Request.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> UserProfile.Request.Builder {
                builderResult = UserProfile.Request()
                return self
            }
            override public func clone() throws -> UserProfile.Request.Builder {
                return try UserProfile.Request.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> UserProfile.Request {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> UserProfile.Request {
                let returnMe:UserProfile.Request = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:UserProfile.Request) throws -> UserProfile.Request.Builder {
                if other == UserProfile.Request() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Request.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Request.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Request.Builder {
                let resultDecodedBuilder = UserProfile.Request.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = jsonValueUserId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> UserProfile.Request.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try UserProfile.Request.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    //Nested type declaration end



    //Nested type declaration start

    final public class Response : GeneratedMessage {
        public typealias BuilderType = UserProfile.Response.Builder

        public static func == (lhs: UserProfile.Response, rhs: UserProfile.Response) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasProfile == rhs.hasProfile) && (!lhs.hasProfile || lhs.profile == rhs.profile)
            fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
            fieldCheck = fieldCheck && (lhs.hasException == rhs.hasException) && (!lhs.hasException || lhs.exception == rhs.exception)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var profile:UserProfile!
        public fileprivate(set) var hasProfile:Bool = false
        public fileprivate(set) var error:ServiceError = ServiceError.badRequest
        public fileprivate(set) var hasError:Bool = false
        public fileprivate(set) var exception:UserProfile.Exception!
        public fileprivate(set) var hasException:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
            if hasException {
                try exception.isInitialized()
            }
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasProfile {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:profile)
            }
            if hasError {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:error.rawValue)
            }
            if hasException {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:exception)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasProfile {
                if let varSizeprofile = profile?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeprofile
                }
            }
            if (hasError) {
                serialize_size += error.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasException {
                if let varSizeexception = exception?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeexception
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> UserProfile.Response.Builder {
            return UserProfile.Response.classBuilder() as! UserProfile.Response.Builder
        }
        public func getBuilder() -> UserProfile.Response.Builder {
            return classBuilder() as! UserProfile.Response.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return UserProfile.Response.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return UserProfile.Response.Builder()
        }
        public func toBuilder() throws -> UserProfile.Response.Builder {
            return try UserProfile.Response.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:UserProfile.Response) throws -> UserProfile.Response.Builder {
            return try UserProfile.Response.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasProfile {
                jsonMap["profile"] = try profile.encode()
            }
            if hasError {
                jsonMap["error"] = error.toString()
            }
            if hasException {
                jsonMap["exception"] = try exception.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Response {
            return try UserProfile.Response.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> UserProfile.Response {
            return try UserProfile.Response.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasProfile {
                output += "\(indent) profile {\n"
                if let outDescProfile = profile {
                    output += try outDescProfile.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if (hasError) {
                output += "\(indent) error: \(error.description)\n"
            }
            if hasException {
                output += "\(indent) exception {\n"
                if let outDescException = exception {
                    output += try outDescException.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasProfile {
                    if let hashValueprofile = profile?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueprofile
                    }
                }
                if hasError {
                     hashCode = (hashCode &* 31) &+ error.hashValue
                }
                if hasException {
                    if let hashValueexception = exception?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueexception
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "UserProfile.Response"
        }
        override public func className() -> String {
            return "UserProfile.Response"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:UserProfile.Response = UserProfile.Response()
            public func getMessage() -> UserProfile.Response {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var profile:UserProfile! {
                get {
                    if profileBuilder_ != nil {
                        builderResult.profile = profileBuilder_.getMessage()
                    }
                    return builderResult.profile
                }
                set (value) {
                    builderResult.hasProfile = value != nil
                    builderResult.profile = value
                }
            }
            public var hasProfile:Bool {
                get {
                    return builderResult.hasProfile
                }
            }
            fileprivate var profileBuilder_:UserProfile.Builder! {
                didSet {
                    builderResult.hasProfile = true
                }
            }
            public func getProfileBuilder() -> UserProfile.Builder {
                if profileBuilder_ == nil {
                    profileBuilder_ = UserProfile.Builder()
                    builderResult.profile = profileBuilder_.getMessage()
                    if profile != nil {
                        try! profileBuilder_.mergeFrom(other: profile)
                    }
                }
                return profileBuilder_
            }
            @discardableResult
            public func setProfile(_ value:UserProfile!) -> UserProfile.Response.Builder {
                self.profile = value
                return self
            }
            @discardableResult
            public func mergeProfile(value:UserProfile) throws -> UserProfile.Response.Builder {
                if builderResult.hasProfile {
                    builderResult.profile = try UserProfile.builderWithPrototype(prototype:builderResult.profile).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.profile = value
                }
                builderResult.hasProfile = true
                return self
            }
            @discardableResult
            public func clearProfile() -> UserProfile.Response.Builder {
                profileBuilder_ = nil
                builderResult.hasProfile = false
                builderResult.profile = nil
                return self
            }
                public var error:ServiceError {
                    get {
                        return builderResult.error
                    }
                    set (value) {
                        builderResult.hasError = true
                        builderResult.error = value
                    }
                }
                public var hasError:Bool{
                    get {
                        return builderResult.hasError
                    }
                }
            @discardableResult
                public func setError(_ value:ServiceError) -> UserProfile.Response.Builder {
                  self.error = value
                  return self
                }
            @discardableResult
                public func clearError() -> UserProfile.Response.Builder {
                   builderResult.hasError = false
                   builderResult.error = .badRequest
                   return self
                }
            public var exception:UserProfile.Exception! {
                get {
                    if exceptionBuilder_ != nil {
                        builderResult.exception = exceptionBuilder_.getMessage()
                    }
                    return builderResult.exception
                }
                set (value) {
                    builderResult.hasException = value != nil
                    builderResult.exception = value
                }
            }
            public var hasException:Bool {
                get {
                    return builderResult.hasException
                }
            }
            fileprivate var exceptionBuilder_:UserProfile.Exception.Builder! {
                didSet {
                    builderResult.hasException = true
                }
            }
            public func getExceptionBuilder() -> UserProfile.Exception.Builder {
                if exceptionBuilder_ == nil {
                    exceptionBuilder_ = UserProfile.Exception.Builder()
                    builderResult.exception = exceptionBuilder_.getMessage()
                    if exception != nil {
                        try! exceptionBuilder_.mergeFrom(other: exception)
                    }
                }
                return exceptionBuilder_
            }
            @discardableResult
            public func setException(_ value:UserProfile.Exception!) -> UserProfile.Response.Builder {
                self.exception = value
                return self
            }
            @discardableResult
            public func mergeException(value:UserProfile.Exception) throws -> UserProfile.Response.Builder {
                if builderResult.hasException {
                    builderResult.exception = try UserProfile.Exception.builderWithPrototype(prototype:builderResult.exception).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.exception = value
                }
                builderResult.hasException = true
                return self
            }
            @discardableResult
            public func clearException() -> UserProfile.Response.Builder {
                exceptionBuilder_ = nil
                builderResult.hasException = false
                builderResult.exception = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> UserProfile.Response.Builder {
                builderResult = UserProfile.Response()
                return self
            }
            override public func clone() throws -> UserProfile.Response.Builder {
                return try UserProfile.Response.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> UserProfile.Response {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> UserProfile.Response {
                let returnMe:UserProfile.Response = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:UserProfile.Response) throws -> UserProfile.Response.Builder {
                if other == UserProfile.Response() {
                    return self
                }
                if (other.hasProfile) {
                    try mergeProfile(value: other.profile)
                }
                if other.hasError {
                    error = other.error
                }
                if (other.hasException) {
                    try mergeException(value: other.exception)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Response.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Response.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:UserProfile.Builder = UserProfile.Builder()
                        if hasProfile {
                            try subBuilder.mergeFrom(other: profile)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        profile = subBuilder.buildPartial()

                    case 16:
                        let valueInterror = try codedInputStream.readEnum()
                        if let enumserror = ServiceError(rawValue:valueInterror){
                            error = enumserror
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueInterror))
                        }

                    case 26:
                        let subBuilder:UserProfile.Exception.Builder = UserProfile.Exception.Builder()
                        if hasException {
                            try subBuilder.mergeFrom(other: exception)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        exception = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Response.Builder {
                let resultDecodedBuilder = UserProfile.Response.Builder()
                if let jsonValueProfile = jsonMap["profile"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.profile = try UserProfile.Builder.decodeToBuilder(jsonMap:jsonValueProfile).build()

                }
                if let jsonValueError = jsonMap["error"] as? String {
                    resultDecodedBuilder.error = try ServiceError.fromString(jsonValueError)
                }
                if let jsonValueException = jsonMap["exception"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.exception = try UserProfile.Exception.Builder.decodeToBuilder(jsonMap:jsonValueException).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> UserProfile.Response.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try UserProfile.Response.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    //Nested type declaration end



    //Nested type declaration start

    final public class Exception : GeneratedMessage, Error {
        public typealias BuilderType = UserProfile.Exception.Builder

        public static func == (lhs: UserProfile.Exception, rhs: UserProfile.Exception) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasErrorCode == rhs.hasErrorCode) && (!lhs.hasErrorCode || lhs.errorCode == rhs.errorCode)
            fieldCheck = fieldCheck && (lhs.hasErrorDescription == rhs.hasErrorDescription) && (!lhs.hasErrorDescription || lhs.errorDescription == rhs.errorDescription)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var errorCode:Int32! = nil
        public fileprivate(set) var hasErrorCode:Bool = false

        public fileprivate(set) var errorDescription:String! = nil
        public fileprivate(set) var hasErrorDescription:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
            if !hasErrorCode {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(UserProfile.Exception.self): field \"errorCode\" mark required")
            }
            if !hasErrorDescription {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(UserProfile.Exception.self): field \"errorDescription\" mark required")
            }
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasErrorCode {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:errorCode)
            }
            if hasErrorDescription {
                try codedOutputStream.writeString(fieldNumber: 2, value:errorDescription)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasErrorCode {
                serialize_size += errorCode.computeInt32Size(fieldNumber: 1)
            }
            if hasErrorDescription {
                serialize_size += errorDescription.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> UserProfile.Exception.Builder {
            return UserProfile.Exception.classBuilder() as! UserProfile.Exception.Builder
        }
        public func getBuilder() -> UserProfile.Exception.Builder {
            return classBuilder() as! UserProfile.Exception.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return UserProfile.Exception.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return UserProfile.Exception.Builder()
        }
        public func toBuilder() throws -> UserProfile.Exception.Builder {
            return try UserProfile.Exception.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:UserProfile.Exception) throws -> UserProfile.Exception.Builder {
            return try UserProfile.Exception.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasErrorCode {
                jsonMap["errorCode"] = Int(errorCode)
            }
            if hasErrorDescription {
                jsonMap["errorDescription"] = errorDescription
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Exception {
            return try UserProfile.Exception.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> UserProfile.Exception {
            return try UserProfile.Exception.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasErrorCode {
                output += "\(indent) errorCode: \(String(describing: errorCode)) \n"
            }
            if hasErrorDescription {
                output += "\(indent) errorDescription: \(String(describing: errorDescription)) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasErrorCode {
                    hashCode = (hashCode &* 31) &+ errorCode.hashValue
                }
                if hasErrorDescription {
                    hashCode = (hashCode &* 31) &+ errorDescription.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "UserProfile.Exception"
        }
        override public func className() -> String {
            return "UserProfile.Exception"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:UserProfile.Exception = UserProfile.Exception()
            public func getMessage() -> UserProfile.Exception {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var errorCode:Int32 {
                get {
                    return builderResult.errorCode
                }
                set (value) {
                    builderResult.hasErrorCode = true
                    builderResult.errorCode = value
                }
            }
            public var hasErrorCode:Bool {
                get {
                    return builderResult.hasErrorCode
                }
            }
            @discardableResult
            public func setErrorCode(_ value:Int32) -> UserProfile.Exception.Builder {
                self.errorCode = value
                return self
            }
            @discardableResult
            public func clearErrorCode() -> UserProfile.Exception.Builder{
                builderResult.hasErrorCode = false
                builderResult.errorCode = nil
                return self
            }
            public var errorDescription:String {
                get {
                    return builderResult.errorDescription
                }
                set (value) {
                    builderResult.hasErrorDescription = true
                    builderResult.errorDescription = value
                }
            }
            public var hasErrorDescription:Bool {
                get {
                    return builderResult.hasErrorDescription
                }
            }
            @discardableResult
            public func setErrorDescription(_ value:String) -> UserProfile.Exception.Builder {
                self.errorDescription = value
                return self
            }
            @discardableResult
            public func clearErrorDescription() -> UserProfile.Exception.Builder{
                builderResult.hasErrorDescription = false
                builderResult.errorDescription = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> UserProfile.Exception.Builder {
                builderResult = UserProfile.Exception()
                return self
            }
            override public func clone() throws -> UserProfile.Exception.Builder {
                return try UserProfile.Exception.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> UserProfile.Exception {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> UserProfile.Exception {
                let returnMe:UserProfile.Exception = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:UserProfile.Exception) throws -> UserProfile.Exception.Builder {
                if other == UserProfile.Exception() {
                    return self
                }
                if other.hasErrorCode {
                    errorCode = other.errorCode
                }
                if other.hasErrorDescription {
                    errorDescription = other.errorDescription
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Exception.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Exception.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        errorCode = try codedInputStream.readInt32()

                    case 18:
                        errorDescription = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Exception.Builder {
                let resultDecodedBuilder = UserProfile.Exception.Builder()
                if let jsonValueErrorCode = jsonMap["errorCode"] as? Int {
                    resultDecodedBuilder.errorCode = Int32(jsonValueErrorCode)
                } else if let jsonValueErrorCode = jsonMap["errorCode"] as? String {
                    resultDecodedBuilder.errorCode = Int32(jsonValueErrorCode)!
                }
                if let jsonValueErrorDescription = jsonMap["errorDescription"] as? String {
                    resultDecodedBuilder.errorDescription = jsonValueErrorDescription
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> UserProfile.Exception.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try UserProfile.Exception.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    //Nested type declaration end

    public fileprivate(set) var firstName:String! = nil
    public fileprivate(set) var hasFirstName:Bool = false

    public fileprivate(set) var lastName:String! = nil
    public fileprivate(set) var hasLastName:Bool = false

    public fileprivate(set) var avatarUrl:String! = nil
    public fileprivate(set) var hasAvatarUrl:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasFirstName {
            try codedOutputStream.writeString(fieldNumber: 1, value:firstName)
        }
        if hasLastName {
            try codedOutputStream.writeString(fieldNumber: 2, value:lastName)
        }
        if hasAvatarUrl {
            try codedOutputStream.writeString(fieldNumber: 3, value:avatarUrl)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFirstName {
            serialize_size += firstName.computeStringSize(fieldNumber: 1)
        }
        if hasLastName {
            serialize_size += lastName.computeStringSize(fieldNumber: 2)
        }
        if hasAvatarUrl {
            serialize_size += avatarUrl.computeStringSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> UserProfile.Builder {
        return UserProfile.classBuilder() as! UserProfile.Builder
    }
    public func getBuilder() -> UserProfile.Builder {
        return classBuilder() as! UserProfile.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserProfile.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserProfile.Builder()
    }
    public func toBuilder() throws -> UserProfile.Builder {
        return try UserProfile.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:UserProfile) throws -> UserProfile.Builder {
        return try UserProfile.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasFirstName {
            jsonMap["firstName"] = firstName
        }
        if hasLastName {
            jsonMap["lastName"] = lastName
        }
        if hasAvatarUrl {
            jsonMap["avatarUrl"] = avatarUrl
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserProfile {
        return try UserProfile.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> UserProfile {
        return try UserProfile.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasFirstName {
            output += "\(indent) firstName: \(String(describing: firstName)) \n"
        }
        if hasLastName {
            output += "\(indent) lastName: \(String(describing: lastName)) \n"
        }
        if hasAvatarUrl {
            output += "\(indent) avatarUrl: \(String(describing: avatarUrl)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasFirstName {
                hashCode = (hashCode &* 31) &+ firstName.hashValue
            }
            if hasLastName {
                hashCode = (hashCode &* 31) &+ lastName.hashValue
            }
            if hasAvatarUrl {
                hashCode = (hashCode &* 31) &+ avatarUrl.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "UserProfile"
    }
    override public func className() -> String {
        return "UserProfile"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:UserProfile = UserProfile()
        public func getMessage() -> UserProfile {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var firstName:String {
            get {
                return builderResult.firstName
            }
            set (value) {
                builderResult.hasFirstName = true
                builderResult.firstName = value
            }
        }
        public var hasFirstName:Bool {
            get {
                return builderResult.hasFirstName
            }
        }
        @discardableResult
        public func setFirstName(_ value:String) -> UserProfile.Builder {
            self.firstName = value
            return self
        }
        @discardableResult
        public func clearFirstName() -> UserProfile.Builder{
            builderResult.hasFirstName = false
            builderResult.firstName = nil
            return self
        }
        public var lastName:String {
            get {
                return builderResult.lastName
            }
            set (value) {
                builderResult.hasLastName = true
                builderResult.lastName = value
            }
        }
        public var hasLastName:Bool {
            get {
                return builderResult.hasLastName
            }
        }
        @discardableResult
        public func setLastName(_ value:String) -> UserProfile.Builder {
            self.lastName = value
            return self
        }
        @discardableResult
        public func clearLastName() -> UserProfile.Builder{
            builderResult.hasLastName = false
            builderResult.lastName = nil
            return self
        }
        public var avatarUrl:String {
            get {
                return builderResult.avatarUrl
            }
            set (value) {
                builderResult.hasAvatarUrl = true
                builderResult.avatarUrl = value
            }
        }
        public var hasAvatarUrl:Bool {
            get {
                return builderResult.hasAvatarUrl
            }
        }
        @discardableResult
        public func setAvatarUrl(_ value:String) -> UserProfile.Builder {
            self.avatarUrl = value
            return self
        }
        @discardableResult
        public func clearAvatarUrl() -> UserProfile.Builder{
            builderResult.hasAvatarUrl = false
            builderResult.avatarUrl = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> UserProfile.Builder {
            builderResult = UserProfile()
            return self
        }
        override public func clone() throws -> UserProfile.Builder {
            return try UserProfile.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> UserProfile {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> UserProfile {
            let returnMe:UserProfile = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:UserProfile) throws -> UserProfile.Builder {
            if other == UserProfile() {
                return self
            }
            if other.hasFirstName {
                firstName = other.firstName
            }
            if other.hasLastName {
                lastName = other.lastName
            }
            if other.hasAvatarUrl {
                avatarUrl = other.avatarUrl
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    firstName = try codedInputStream.readString()

                case 18:
                    lastName = try codedInputStream.readString()

                case 26:
                    avatarUrl = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Builder {
            let resultDecodedBuilder = UserProfile.Builder()
            if let jsonValueFirstName = jsonMap["firstName"] as? String {
                resultDecodedBuilder.firstName = jsonValueFirstName
            }
            if let jsonValueLastName = jsonMap["lastName"] as? String {
                resultDecodedBuilder.lastName = jsonValueLastName
            }
            if let jsonValueAvatarUrl = jsonMap["avatarUrl"] as? String {
                resultDecodedBuilder.avatarUrl = jsonValueAvatarUrl
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> UserProfile.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try UserProfile.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension UserProfile: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserProfile> {
        var mergedArray = Array<UserProfile>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserProfile? {
        return try UserProfile.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> UserProfile {
        return try UserProfile.Builder().mergeFrom(data: data, extensionRegistry:UnittestErrorTypeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserProfile {
        return try UserProfile.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> UserProfile {
        return try UserProfile.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile {
        return try UserProfile.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserProfile {
        return try UserProfile.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile {
        return try UserProfile.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "firstName": return self.firstName
        case "lastName": return self.lastName
        case "avatarUrl": return self.avatarUrl
        default: return nil
        }
    }
}
extension UserProfile.Request: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserProfile.Request> {
        var mergedArray = Array<UserProfile.Request>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserProfile.Request? {
        return try UserProfile.Request.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> UserProfile.Request {
        return try UserProfile.Request.Builder().mergeFrom(data: data, extensionRegistry:UnittestErrorTypeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Request {
        return try UserProfile.Request.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> UserProfile.Request {
        return try UserProfile.Request.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Request {
        return try UserProfile.Request.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Request {
        return try UserProfile.Request.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Request {
        return try UserProfile.Request.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        default: return nil
        }
    }
}
extension UserProfile.Response: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserProfile.Response> {
        var mergedArray = Array<UserProfile.Response>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserProfile.Response? {
        return try UserProfile.Response.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> UserProfile.Response {
        return try UserProfile.Response.Builder().mergeFrom(data: data, extensionRegistry:UnittestErrorTypeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Response {
        return try UserProfile.Response.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> UserProfile.Response {
        return try UserProfile.Response.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Response {
        return try UserProfile.Response.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Response {
        return try UserProfile.Response.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Response {
        return try UserProfile.Response.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "profile": return self.profile
        case "error": return self.error
        case "exception": return self.exception
        default: return nil
        }
    }
}
extension UserProfile.Exception: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserProfile.Exception> {
        var mergedArray = Array<UserProfile.Exception>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserProfile.Exception? {
        return try UserProfile.Exception.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> UserProfile.Exception {
        return try UserProfile.Exception.Builder().mergeFrom(data: data, extensionRegistry:UnittestErrorTypeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Exception {
        return try UserProfile.Exception.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> UserProfile.Exception {
        return try UserProfile.Exception.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Exception {
        return try UserProfile.Exception.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Exception {
        return try UserProfile.Exception.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Exception {
        return try UserProfile.Exception.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "errorCode": return self.errorCode
        case "errorDescription": return self.errorDescription
        default: return nil
        }
    }
}
extension UserProfile.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = UserProfile
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "firstName": return self.firstName
            case "lastName": return self.lastName
            case "avatarUrl": return self.avatarUrl
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "firstName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.firstName = newSubscriptValue
            case "lastName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.lastName = newSubscriptValue
            case "avatarUrl":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.avatarUrl = newSubscriptValue
            default: return
            }
        }
    }
}
extension UserProfile.Request.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = UserProfile.Request
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            default: return
            }
        }
    }
}
extension UserProfile.Response.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = UserProfile.Response
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "profile": return self.profile
            case "error": return self.error
            case "exception": return self.exception
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "profile":
                guard let newSubscriptValue = newSubscriptValue as? UserProfile else {
                    return
                }
                self.profile = newSubscriptValue
            case "error":
                guard let newSubscriptValue = newSubscriptValue as? ServiceError else {
                    return
                }
                self.error = newSubscriptValue
            case "exception":
                guard let newSubscriptValue = newSubscriptValue as? UserProfile.Exception else {
                    return
                }
                self.exception = newSubscriptValue
            default: return
            }
        }
    }
}
extension UserProfile.Exception.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = UserProfile.Exception
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "errorCode": return self.errorCode
            case "errorDescription": return self.errorDescription
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "errorCode":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.errorCode = newSubscriptValue
            case "errorDescription":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.errorDescription = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
