/// Generated by the Protocol Buffers 3.6.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "unittest_optimize_for.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public extension ProtobufUnittest{}

public var TestOptimizedForSizetestExtension:ConcreateExtensionField {
    get {
        return ProtobufUnittest.UnittestOptimizeForRoot.default.TestOptimizedForSizetestExtensionStatic
    }
}
public var TestOptimizedForSizetestExtension2:ConcreateExtensionField {
    get {
        return ProtobufUnittest.UnittestOptimizeForRoot.default.TestOptimizedForSizetestExtension2Static
    }
}
public extension ProtobufUnittest {
    public struct UnittestOptimizeForRoot {
        public static let `default` = UnittestOptimizeForRoot()
        var TestOptimizedForSizetestExtensionStatic:ConcreateExtensionField
        var TestOptimizedForSizetestExtension2Static:ConcreateExtensionField
        public var extensionRegistry:ExtensionRegistry

        init() {
            TestOptimizedForSizetestExtensionStatic = ConcreateExtensionField(type:ExtensionType.extensionTypeInt32, extendedClass:ProtobufUnittest.TestOptimizedForSize.self, fieldNumber: 1234, defaultValue:nil, messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
            TestOptimizedForSizetestExtension2Static = ConcreateExtensionField(type:ExtensionType.extensionTypeMessage, extendedClass:ProtobufUnittest.TestOptimizedForSize.self, fieldNumber: 1235, defaultValue:ProtobufUnittest.TestRequiredOptimizedForSize(), messageOrGroupClass:ProtobufUnittest.TestRequiredOptimizedForSize.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            ProtobufUnittest.UnittestRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
            registry.addExtension(extensions: TestOptimizedForSizetestExtensionStatic)
            registry.addExtension(extensions: TestOptimizedForSizetestExtension2Static)
        }
    }

    final public class TestOptimizedForSize : ExtendableMessage {
        public typealias BuilderType = ProtobufUnittest.TestOptimizedForSize.Builder

        public static func == (lhs: ProtobufUnittest.TestOptimizedForSize, rhs: ProtobufUnittest.TestOptimizedForSize) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasI == rhs.hasI) && (!lhs.hasI || lhs.i == rhs.i)
            fieldCheck = fieldCheck && (lhs.hasIntegerField == rhs.hasIntegerField) && (!lhs.hasIntegerField || lhs.integerField == rhs.integerField)
            fieldCheck = fieldCheck && (lhs.hasStringField == rhs.hasStringField) && (!lhs.hasStringField || lhs.stringField == rhs.stringField)
            fieldCheck = fieldCheck && (lhs.hasMsg == rhs.hasMsg) && (!lhs.hasMsg || lhs.msg == rhs.msg)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:536870912)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Foo {
            case oneOfFooNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .oneOfFooNotSet: return false
                default: return true
                }
            }
            case integerField(Int32)

            public static func getIntegerField(_ value:Foo) -> Int32? {
                switch value {
                case .integerField(let otherValue): return otherValue
                default: return nil
                }
            }
            public func getIntegerField() -> Int32? {
                switch self {
                case .integerField(let otherValue): return otherValue
                default: return nil
                }
            }
            case stringField(String)

            public static func getStringField(_ value:Foo) -> String? {
                switch value {
                case .stringField(let otherValue): return otherValue
                default: return nil
                }
            }
            public func getStringField() -> String? {
                switch self {
                case .stringField(let otherValue): return otherValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageFoo:TestOptimizedForSize.Foo =  TestOptimizedForSize.Foo.oneOfFooNotSet
        public func getOneOfFoo() ->  TestOptimizedForSize.Foo {
            let copyObjectFoo = storageFoo
            return copyObjectFoo
        }
        public fileprivate(set) var i:Int32! = nil
        public fileprivate(set) var hasI:Bool = false

        public fileprivate(set) var msg:ProtobufUnittest.ForeignMessage!
        public fileprivate(set) var hasMsg:Bool = false
        public fileprivate(set) var integerField:Int32!{
            get {
                return TestOptimizedForSize.Foo.getIntegerField(storageFoo)
            }
            set (newvalue) {
                storageFoo = TestOptimizedForSize.Foo.integerField(newvalue)
            }
        }
        public fileprivate(set) var hasIntegerField:Bool {
            get {
                return TestOptimizedForSize.Foo.getIntegerField(storageFoo) != nil
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var stringField:String!{
            get {
                return TestOptimizedForSize.Foo.getStringField(storageFoo)
            }
            set (newvalue) {
                storageFoo = TestOptimizedForSize.Foo.stringField(newvalue)
            }
        }
        public fileprivate(set) var hasStringField:Bool {
            get {
                return TestOptimizedForSize.Foo.getStringField(storageFoo) != nil
            }
            set(newValue) {
            }
        }
        public class func testExtension() -> ConcreateExtensionField {
               return TestOptimizedForSizetestExtension
        }
        public class func testExtension2() -> ConcreateExtensionField {
               return TestOptimizedForSizetestExtension2
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
            try extensionsAreInitialized()}
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasI {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:i)
            }
            if hasIntegerField {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:integerField)
            }
            if hasStringField {
                try codedOutputStream.writeString(fieldNumber: 3, value:stringField)
            }
            if hasMsg {
                try codedOutputStream.writeMessage(fieldNumber: 19, value:msg)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:536870912)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasI {
                serialize_size += i.computeInt32Size(fieldNumber: 1)
            }
            if hasIntegerField {
                serialize_size += integerField.computeInt32Size(fieldNumber: 2)
            }
            if hasStringField {
                serialize_size += stringField.computeStringSize(fieldNumber: 3)
            }
            if hasMsg {
                if let varSizemsg = msg?.computeMessageSize(fieldNumber: 19) {
                    serialize_size += varSizemsg
                }
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> ProtobufUnittest.TestOptimizedForSize.Builder {
            return ProtobufUnittest.TestOptimizedForSize.classBuilder() as! ProtobufUnittest.TestOptimizedForSize.Builder
        }
        public func getBuilder() -> ProtobufUnittest.TestOptimizedForSize.Builder {
            return classBuilder() as! ProtobufUnittest.TestOptimizedForSize.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return ProtobufUnittest.TestOptimizedForSize.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return ProtobufUnittest.TestOptimizedForSize.Builder()
        }
        public func toBuilder() throws -> ProtobufUnittest.TestOptimizedForSize.Builder {
            return try ProtobufUnittest.TestOptimizedForSize.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:ProtobufUnittest.TestOptimizedForSize) throws -> ProtobufUnittest.TestOptimizedForSize.Builder {
            return try ProtobufUnittest.TestOptimizedForSize.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasI {
                jsonMap["i"] = Int(i)
            }
            if hasMsg {
                jsonMap["msg"] = try msg.encode()
            }
            if hasIntegerField {
                jsonMap["integerField"] = Int(integerField)
            }
            if hasStringField {
                jsonMap["stringField"] = stringField
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ProtobufUnittest.TestOptimizedForSize {
            return try ProtobufUnittest.TestOptimizedForSize.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> ProtobufUnittest.TestOptimizedForSize {
            return try ProtobufUnittest.TestOptimizedForSize.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasI {
                output += "\(indent) i: \(String(describing: i)) \n"
            }
            if hasIntegerField {
                output += "\(indent) integerField: \(String(describing: integerField)) \n"
            }
            if hasStringField {
                output += "\(indent) stringField: \(String(describing: stringField)) \n"
            }
            if hasMsg {
                output += "\(indent) msg {\n"
                if let outDescMsg = msg {
                    output += try outDescMsg.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:536870912, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasI {
                    hashCode = (hashCode &* 31) &+ i.hashValue
                }
                if hasIntegerField {
                    hashCode = (hashCode &* 31) &+ integerField.hashValue
                }
                if hasStringField {
                    hashCode = (hashCode &* 31) &+ stringField.hashValue
                }
                if hasMsg {
                    if let hashValuemsg = msg?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemsg
                    }
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:536870912))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "ProtobufUnittest.TestOptimizedForSize"
        }
        override public func className() -> String {
            return "ProtobufUnittest.TestOptimizedForSize"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:ProtobufUnittest.TestOptimizedForSize = ProtobufUnittest.TestOptimizedForSize()
            public func getMessage() -> ProtobufUnittest.TestOptimizedForSize {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public func setFoo(_ oneOf:TestOptimizedForSize.Foo) ->  ProtobufUnittest.TestOptimizedForSize.Builder {
                builderResult.storageFoo = oneOf
                return self
            }
            public var i:Int32 {
                get {
                    return builderResult.i
                }
                set (value) {
                    builderResult.hasI = true
                    builderResult.i = value
                }
            }
            public var hasI:Bool {
                get {
                    return builderResult.hasI
                }
            }
            @discardableResult
            public func setI(_ value:Int32) -> ProtobufUnittest.TestOptimizedForSize.Builder {
                self.i = value
                return self
            }
            @discardableResult
            public func clearI() -> ProtobufUnittest.TestOptimizedForSize.Builder{
                builderResult.hasI = false
                builderResult.i = nil
                return self
            }
            public var msg:ProtobufUnittest.ForeignMessage! {
                get {
                    if msgBuilder_ != nil {
                        builderResult.msg = msgBuilder_.getMessage()
                    }
                    return builderResult.msg
                }
                set (value) {
                    builderResult.hasMsg = value != nil
                    builderResult.msg = value
                }
            }
            public var hasMsg:Bool {
                get {
                    return builderResult.hasMsg
                }
            }
            fileprivate var msgBuilder_:ProtobufUnittest.ForeignMessage.Builder! {
                didSet {
                    builderResult.hasMsg = true
                }
            }
            public func getMsgBuilder() -> ProtobufUnittest.ForeignMessage.Builder {
                if msgBuilder_ == nil {
                    msgBuilder_ = ProtobufUnittest.ForeignMessage.Builder()
                    builderResult.msg = msgBuilder_.getMessage()
                    if msg != nil {
                        try! msgBuilder_.mergeFrom(other: msg)
                    }
                }
                return msgBuilder_
            }
            @discardableResult
            public func setMsg(_ value:ProtobufUnittest.ForeignMessage!) -> ProtobufUnittest.TestOptimizedForSize.Builder {
                self.msg = value
                return self
            }
            @discardableResult
            public func mergeMsg(value:ProtobufUnittest.ForeignMessage) throws -> ProtobufUnittest.TestOptimizedForSize.Builder {
                if builderResult.hasMsg {
                    builderResult.msg = try ProtobufUnittest.ForeignMessage.builderWithPrototype(prototype:builderResult.msg).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.msg = value
                }
                builderResult.hasMsg = true
                return self
            }
            @discardableResult
            public func clearMsg() -> ProtobufUnittest.TestOptimizedForSize.Builder {
                msgBuilder_ = nil
                builderResult.hasMsg = false
                builderResult.msg = nil
                return self
            }
            public var integerField:Int32 {
                get {
                    return builderResult.integerField
                }
                set (value) {
                    builderResult.hasIntegerField = true
                    builderResult.integerField = value
                }
            }
            public var hasIntegerField:Bool {
                get {
                    return builderResult.hasIntegerField
                }
            }
            @discardableResult
            public func setIntegerField(_ value:Int32) -> ProtobufUnittest.TestOptimizedForSize.Builder {
                self.integerField = value
                return self
            }
            @discardableResult
            public func clearIntegerField() -> ProtobufUnittest.TestOptimizedForSize.Builder{
                builderResult.hasIntegerField = false
                builderResult.integerField = nil
                return self
            }
            public var stringField:String {
                get {
                    return builderResult.stringField
                }
                set (value) {
                    builderResult.hasStringField = true
                    builderResult.stringField = value
                }
            }
            public var hasStringField:Bool {
                get {
                    return builderResult.hasStringField
                }
            }
            @discardableResult
            public func setStringField(_ value:String) -> ProtobufUnittest.TestOptimizedForSize.Builder {
                self.stringField = value
                return self
            }
            @discardableResult
            public func clearStringField() -> ProtobufUnittest.TestOptimizedForSize.Builder{
                builderResult.hasStringField = false
                builderResult.stringField = nil
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> ProtobufUnittest.TestOptimizedForSize.Builder {
                builderResult = ProtobufUnittest.TestOptimizedForSize()
                return self
            }
            override public func clone() throws -> ProtobufUnittest.TestOptimizedForSize.Builder {
                return try ProtobufUnittest.TestOptimizedForSize.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> ProtobufUnittest.TestOptimizedForSize {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> ProtobufUnittest.TestOptimizedForSize {
                let returnMe:ProtobufUnittest.TestOptimizedForSize = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:ProtobufUnittest.TestOptimizedForSize) throws -> ProtobufUnittest.TestOptimizedForSize.Builder {
                if other == ProtobufUnittest.TestOptimizedForSize() {
                    return self
                }
                if other.hasI {
                    i = other.i
                }
                if (other.hasMsg) {
                    try mergeMsg(value: other.msg)
                }
                if other.hasIntegerField {
                    integerField = other.integerField
                }
                if other.hasStringField {
                    stringField = other.stringField
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ProtobufUnittest.TestOptimizedForSize.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestOptimizedForSize.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        i = try codedInputStream.readInt32()

                    case 16:
                        integerField = try codedInputStream.readInt32()

                    case 26:
                        stringField = try codedInputStream.readString()

                    case 154:
                        let subBuilder:ProtobufUnittest.ForeignMessage.Builder = ProtobufUnittest.ForeignMessage.Builder()
                        if hasMsg {
                            try subBuilder.mergeFrom(other: msg)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        msg = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ProtobufUnittest.TestOptimizedForSize.Builder {
                let resultDecodedBuilder = ProtobufUnittest.TestOptimizedForSize.Builder()
                if let jsonValueI = jsonMap["i"] as? Int {
                    resultDecodedBuilder.i = Int32(jsonValueI)
                } else if let jsonValueI = jsonMap["i"] as? String {
                    resultDecodedBuilder.i = Int32(jsonValueI)!
                }
                if let jsonValueMsg = jsonMap["msg"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.msg = try ProtobufUnittest.ForeignMessage.Builder.decodeToBuilder(jsonMap:jsonValueMsg).build()

                }
                if let jsonValueIntegerField = jsonMap["integerField"] as? Int {
                    resultDecodedBuilder.integerField = Int32(jsonValueIntegerField)
                } else if let jsonValueIntegerField = jsonMap["integerField"] as? String {
                    resultDecodedBuilder.integerField = Int32(jsonValueIntegerField)!
                }
                if let jsonValueStringField = jsonMap["stringField"] as? String {
                    resultDecodedBuilder.stringField = jsonValueStringField
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> ProtobufUnittest.TestOptimizedForSize.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try ProtobufUnittest.TestOptimizedForSize.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TestRequiredOptimizedForSize : GeneratedMessage {
        public typealias BuilderType = ProtobufUnittest.TestRequiredOptimizedForSize.Builder

        public static func == (lhs: ProtobufUnittest.TestRequiredOptimizedForSize, rhs: ProtobufUnittest.TestRequiredOptimizedForSize) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasX == rhs.hasX) && (!lhs.hasX || lhs.x == rhs.x)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var x:Int32! = nil
        public fileprivate(set) var hasX:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
            if !hasX {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(ProtobufUnittest.TestRequiredOptimizedForSize.self): field \"x\" mark required")
            }
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasX {
                try codedOutputStream.writeInt32(fieldNumber: 1, value:x)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasX {
                serialize_size += x.computeInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
            return ProtobufUnittest.TestRequiredOptimizedForSize.classBuilder() as! ProtobufUnittest.TestRequiredOptimizedForSize.Builder
        }
        public func getBuilder() -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
            return classBuilder() as! ProtobufUnittest.TestRequiredOptimizedForSize.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return ProtobufUnittest.TestRequiredOptimizedForSize.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return ProtobufUnittest.TestRequiredOptimizedForSize.Builder()
        }
        public func toBuilder() throws -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
            return try ProtobufUnittest.TestRequiredOptimizedForSize.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:ProtobufUnittest.TestRequiredOptimizedForSize) throws -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
            return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasX {
                jsonMap["x"] = Int(x)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ProtobufUnittest.TestRequiredOptimizedForSize {
            return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> ProtobufUnittest.TestRequiredOptimizedForSize {
            return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasX {
                output += "\(indent) x: \(String(describing: x)) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasX {
                    hashCode = (hashCode &* 31) &+ x.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "ProtobufUnittest.TestRequiredOptimizedForSize"
        }
        override public func className() -> String {
            return "ProtobufUnittest.TestRequiredOptimizedForSize"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:ProtobufUnittest.TestRequiredOptimizedForSize = ProtobufUnittest.TestRequiredOptimizedForSize()
            public func getMessage() -> ProtobufUnittest.TestRequiredOptimizedForSize {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var x:Int32 {
                get {
                    return builderResult.x
                }
                set (value) {
                    builderResult.hasX = true
                    builderResult.x = value
                }
            }
            public var hasX:Bool {
                get {
                    return builderResult.hasX
                }
            }
            @discardableResult
            public func setX(_ value:Int32) -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
                self.x = value
                return self
            }
            @discardableResult
            public func clearX() -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder{
                builderResult.hasX = false
                builderResult.x = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
                builderResult = ProtobufUnittest.TestRequiredOptimizedForSize()
                return self
            }
            override public func clone() throws -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
                return try ProtobufUnittest.TestRequiredOptimizedForSize.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> ProtobufUnittest.TestRequiredOptimizedForSize {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> ProtobufUnittest.TestRequiredOptimizedForSize {
                let returnMe:ProtobufUnittest.TestRequiredOptimizedForSize = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:ProtobufUnittest.TestRequiredOptimizedForSize) throws -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
                if other == ProtobufUnittest.TestRequiredOptimizedForSize() {
                    return self
                }
                if other.hasX {
                    x = other.x
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        x = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
                let resultDecodedBuilder = ProtobufUnittest.TestRequiredOptimizedForSize.Builder()
                if let jsonValueX = jsonMap["x"] as? Int {
                    resultDecodedBuilder.x = Int32(jsonValueX)
                } else if let jsonValueX = jsonMap["x"] as? String {
                    resultDecodedBuilder.x = Int32(jsonValueX)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TestOptionalOptimizedForSize : GeneratedMessage {
        public typealias BuilderType = ProtobufUnittest.TestOptionalOptimizedForSize.Builder

        public static func == (lhs: ProtobufUnittest.TestOptionalOptimizedForSize, rhs: ProtobufUnittest.TestOptionalOptimizedForSize) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasO == rhs.hasO) && (!lhs.hasO || lhs.o == rhs.o)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var o:ProtobufUnittest.TestRequiredOptimizedForSize!
        public fileprivate(set) var hasO:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
            if hasO {
                try o.isInitialized()
            }
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasO {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:o)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasO {
                if let varSizeo = o?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeo
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
            return ProtobufUnittest.TestOptionalOptimizedForSize.classBuilder() as! ProtobufUnittest.TestOptionalOptimizedForSize.Builder
        }
        public func getBuilder() -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
            return classBuilder() as! ProtobufUnittest.TestOptionalOptimizedForSize.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return ProtobufUnittest.TestOptionalOptimizedForSize.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return ProtobufUnittest.TestOptionalOptimizedForSize.Builder()
        }
        public func toBuilder() throws -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
            return try ProtobufUnittest.TestOptionalOptimizedForSize.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:ProtobufUnittest.TestOptionalOptimizedForSize) throws -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
            return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasO {
                jsonMap["o"] = try o.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ProtobufUnittest.TestOptionalOptimizedForSize {
            return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> ProtobufUnittest.TestOptionalOptimizedForSize {
            return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasO {
                output += "\(indent) o {\n"
                if let outDescO = o {
                    output += try outDescO.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasO {
                    if let hashValueo = o?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueo
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "ProtobufUnittest.TestOptionalOptimizedForSize"
        }
        override public func className() -> String {
            return "ProtobufUnittest.TestOptionalOptimizedForSize"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:ProtobufUnittest.TestOptionalOptimizedForSize = ProtobufUnittest.TestOptionalOptimizedForSize()
            public func getMessage() -> ProtobufUnittest.TestOptionalOptimizedForSize {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var o:ProtobufUnittest.TestRequiredOptimizedForSize! {
                get {
                    if oBuilder_ != nil {
                        builderResult.o = oBuilder_.getMessage()
                    }
                    return builderResult.o
                }
                set (value) {
                    builderResult.hasO = value != nil
                    builderResult.o = value
                }
            }
            public var hasO:Bool {
                get {
                    return builderResult.hasO
                }
            }
            fileprivate var oBuilder_:ProtobufUnittest.TestRequiredOptimizedForSize.Builder! {
                didSet {
                    builderResult.hasO = true
                }
            }
            public func getOBuilder() -> ProtobufUnittest.TestRequiredOptimizedForSize.Builder {
                if oBuilder_ == nil {
                    oBuilder_ = ProtobufUnittest.TestRequiredOptimizedForSize.Builder()
                    builderResult.o = oBuilder_.getMessage()
                    if o != nil {
                        try! oBuilder_.mergeFrom(other: o)
                    }
                }
                return oBuilder_
            }
            @discardableResult
            public func setO(_ value:ProtobufUnittest.TestRequiredOptimizedForSize!) -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                self.o = value
                return self
            }
            @discardableResult
            public func mergeO(value:ProtobufUnittest.TestRequiredOptimizedForSize) throws -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                if builderResult.hasO {
                    builderResult.o = try ProtobufUnittest.TestRequiredOptimizedForSize.builderWithPrototype(prototype:builderResult.o).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.o = value
                }
                builderResult.hasO = true
                return self
            }
            @discardableResult
            public func clearO() -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                oBuilder_ = nil
                builderResult.hasO = false
                builderResult.o = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                builderResult = ProtobufUnittest.TestOptionalOptimizedForSize()
                return self
            }
            override public func clone() throws -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                return try ProtobufUnittest.TestOptionalOptimizedForSize.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> ProtobufUnittest.TestOptionalOptimizedForSize {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> ProtobufUnittest.TestOptionalOptimizedForSize {
                let returnMe:ProtobufUnittest.TestOptionalOptimizedForSize = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:ProtobufUnittest.TestOptionalOptimizedForSize) throws -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                if other == ProtobufUnittest.TestOptionalOptimizedForSize() {
                    return self
                }
                if (other.hasO) {
                    try mergeO(value: other.o)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:ProtobufUnittest.TestRequiredOptimizedForSize.Builder = ProtobufUnittest.TestRequiredOptimizedForSize.Builder()
                        if hasO {
                            try subBuilder.mergeFrom(other: o)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        o = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                let resultDecodedBuilder = ProtobufUnittest.TestOptionalOptimizedForSize.Builder()
                if let jsonValueO = jsonMap["o"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.o = try ProtobufUnittest.TestRequiredOptimizedForSize.Builder.decodeToBuilder(jsonMap:jsonValueO).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> ProtobufUnittest.TestOptionalOptimizedForSize.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension ProtobufUnittest.TestOptimizedForSize: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ProtobufUnittest.TestOptimizedForSize> {
        var mergedArray = Array<ProtobufUnittest.TestOptimizedForSize>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ProtobufUnittest.TestOptimizedForSize? {
        return try ProtobufUnittest.TestOptimizedForSize.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ProtobufUnittest.TestOptimizedForSize {
        return try ProtobufUnittest.TestOptimizedForSize.Builder().mergeFrom(data: data, extensionRegistry:ProtobufUnittest.UnittestOptimizeForRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestOptimizedForSize {
        return try ProtobufUnittest.TestOptimizedForSize.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ProtobufUnittest.TestOptimizedForSize {
        return try ProtobufUnittest.TestOptimizedForSize.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestOptimizedForSize {
        return try ProtobufUnittest.TestOptimizedForSize.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ProtobufUnittest.TestOptimizedForSize {
        return try ProtobufUnittest.TestOptimizedForSize.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestOptimizedForSize {
        return try ProtobufUnittest.TestOptimizedForSize.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "i": return self.i
        case "msg": return self.msg
        case "integerField": return self.integerField
        case "stringField": return self.stringField
        default: return nil
        }
    }
}
extension ProtobufUnittest.TestOptimizedForSize.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ProtobufUnittest.TestOptimizedForSize
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "i": return self.i
            case "msg": return self.msg
            case "integerField": return self.integerField
            case "stringField": return self.stringField
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "i":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.i = newSubscriptValue
            case "msg":
                guard let newSubscriptValue = newSubscriptValue as? ProtobufUnittest.ForeignMessage else {
                    return
                }
                self.msg = newSubscriptValue
            case "integerField":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.integerField = newSubscriptValue
            case "stringField":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.stringField = newSubscriptValue
            default: return
            }
        }
    }
}
extension ProtobufUnittest.TestRequiredOptimizedForSize: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ProtobufUnittest.TestRequiredOptimizedForSize> {
        var mergedArray = Array<ProtobufUnittest.TestRequiredOptimizedForSize>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ProtobufUnittest.TestRequiredOptimizedForSize? {
        return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ProtobufUnittest.TestRequiredOptimizedForSize {
        return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder().mergeFrom(data: data, extensionRegistry:ProtobufUnittest.UnittestOptimizeForRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestRequiredOptimizedForSize {
        return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ProtobufUnittest.TestRequiredOptimizedForSize {
        return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestRequiredOptimizedForSize {
        return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ProtobufUnittest.TestRequiredOptimizedForSize {
        return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestRequiredOptimizedForSize {
        return try ProtobufUnittest.TestRequiredOptimizedForSize.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "x": return self.x
        default: return nil
        }
    }
}
extension ProtobufUnittest.TestRequiredOptimizedForSize.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ProtobufUnittest.TestRequiredOptimizedForSize
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "x": return self.x
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "x":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.x = newSubscriptValue
            default: return
            }
        }
    }
}
extension ProtobufUnittest.TestOptionalOptimizedForSize: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ProtobufUnittest.TestOptionalOptimizedForSize> {
        var mergedArray = Array<ProtobufUnittest.TestOptionalOptimizedForSize>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ProtobufUnittest.TestOptionalOptimizedForSize? {
        return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ProtobufUnittest.TestOptionalOptimizedForSize {
        return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder().mergeFrom(data: data, extensionRegistry:ProtobufUnittest.UnittestOptimizeForRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestOptionalOptimizedForSize {
        return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ProtobufUnittest.TestOptionalOptimizedForSize {
        return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestOptionalOptimizedForSize {
        return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ProtobufUnittest.TestOptionalOptimizedForSize {
        return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ProtobufUnittest.TestOptionalOptimizedForSize {
        return try ProtobufUnittest.TestOptionalOptimizedForSize.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "o": return self.o
        default: return nil
        }
    }
}
extension ProtobufUnittest.TestOptionalOptimizedForSize.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ProtobufUnittest.TestOptionalOptimizedForSize
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "o": return self.o
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "o":
                guard let newSubscriptValue = newSubscriptValue as? ProtobufUnittest.TestRequiredOptimizedForSize else {
                    return
                }
                self.o = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
